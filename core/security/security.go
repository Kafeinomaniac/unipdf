//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ee "bytes";_e "crypto/aes";_f "crypto/cipher";_faa "crypto/md5";_c "crypto/rand";_fa "crypto/rc4";_b "crypto/sha256";_fd "crypto/sha512";_edg "encoding/binary";_ed "errors";_eeb "fmt";_cb "github.com/unidoc/unipdf/v3/common";_ae "hash";_a "io";_ag "math";);func _aa (_eed _f .Block )_f .BlockMode {return (*ecbEncrypter )(_bd (_eed ))};func (_bdacg stdHandlerR4 )alg5 (_bce []byte ,_eeg []byte )([]byte ,error ){_gfc :=_faa .New ();_gfc .Write ([]byte (_agc ));_gfc .Write ([]byte (_bdacg .ID0 ));_dd :=_gfc .Sum (nil );_cb .Log .Trace ("\u0061\u006c\u0067\u0035");_cb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bce );_cb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bdacg .ID0 );if len (_dd )!=16{return nil ,_ed .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_ge ,_baea :=_fa .NewCipher (_bce );if _baea !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ad :=make ([]byte ,16);_ge .XORKeyStream (_ad ,_dd );_cead :=make ([]byte ,len (_bce ));for _gbf :=0;_gbf < 19;_gbf ++{for _afac :=0;_afac < len (_bce );_afac ++{_cead [_afac ]=_bce [_afac ]^byte (_gbf +1);};_ge ,_baea =_fa .NewCipher (_cead );if _baea !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ge .XORKeyStream (_ad ,_ad );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_gbf ,_cead );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_gbf ,_ad );};_bga :=make ([]byte ,32);for _gdec :=0;_gdec < 16;_gdec ++{_bga [_gdec ]=_ad [_gdec ];};_ ,_baea =_c .Read (_bga [16:32]);if _baea !=nil {return nil ,_ed .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _bga ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_aad Permissions )Allowed (p2 Permissions )bool {return _aad &p2 ==p2 };

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_edfe :=make ([]byte ,32);if _ ,_bac :=_a .ReadFull (_c .Reader ,_edfe );_bac !=nil {return nil ,_bac ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _dgb :=_cg .alg8 (d ,_edfe ,upass );_dgb !=nil {return nil ,_dgb ;};if _agcb :=_cg .alg9 (d ,_edfe ,opass );_agcb !=nil {return nil ,_agcb ;};if d .R ==5{return _edfe ,nil ;};if _cfe :=_cg .alg10 (d ,_edfe );_cfe !=nil {return nil ,_cfe ;};return _edfe ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _gffg (_dead []byte )(_f .Block ,error ){_eag ,_fdd :=_e .NewCipher (_dead );if _fdd !=nil {_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_fdd );return nil ,_fdd ;};return _eag ,nil ;};func (_dee stdHandlerR4 )alg6 (_eg *StdEncryptDict ,_fba []byte )([]byte ,error ){var (_dea []byte ;_bb error ;);_geb :=_dee .alg2 (_eg ,_fba );if _eg .R ==2{_dea ,_bb =_dee .alg4 (_geb ,_fba );}else if _eg .R >=3{_dea ,_bb =_dee .alg5 (_geb ,_fba );}else {return nil ,_ed .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bb !=nil {return nil ,_bb ;};_cb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dea ),string (_eg .U ));_edb :=_dea ;_edaa :=_eg .U ;if _eg .R >=3{if len (_edb )> 16{_edb =_edb [0:16];};if len (_edaa )> 16{_edaa =_edaa [0:16];};};if !_ee .Equal (_edb ,_edaa ){return nil ,nil ;};return _geb ,nil ;};func (_dbff stdHandlerR6 )alg9 (_ceab *StdEncryptDict ,_fdcd []byte ,_bfd []byte )error {if _eba :=_bda ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_fdcd );_eba !=nil {return _eba ;};if _gba :=_bda ("\u0061\u006c\u0067\u0039","\u0055",48,_ceab .U );_gba !=nil {return _gba ;};var _fdcdg [16]byte ;if _ ,_fdb :=_a .ReadFull (_c .Reader ,_fdcdg [:]);_fdb !=nil {return _fdb ;};_fab :=_fdcdg [0:8];_ccd :=_fdcdg [8:16];_edf :=_ceab .U [:48];_bbfd :=make ([]byte ,len (_bfd )+len (_fab )+len (_edf ));_ggfb :=copy (_bbfd ,_bfd );_ggfb +=copy (_bbfd [_ggfb :],_fab );_ggfb +=copy (_bbfd [_ggfb :],_edf );_dad ,_ecg :=_dbff .alg2b (_ceab .R ,_bbfd ,_bfd ,_edf );if _ecg !=nil {return _ecg ;};O :=make ([]byte ,len (_dad )+len (_fab )+len (_ccd ));_ggfb =copy (O ,_dad [:32]);_ggfb +=copy (O [_ggfb :],_fab );_ggfb +=copy (O [_ggfb :],_ccd );_ceab .O =O ;_ggfb =len (_bfd );_ggfb +=copy (_bbfd [_ggfb :],_ccd );_dad ,_ecg =_dbff .alg2b (_ceab .R ,_bbfd ,_bfd ,_edf );if _ecg !=nil {return _ecg ;};_fdce ,_ecg :=_gffg (_dad [:32]);if _ecg !=nil {return _ecg ;};_dfb :=make ([]byte ,_e .BlockSize );_cfgb :=_f .NewCBCEncrypter (_fdce ,_dfb );OE :=make ([]byte ,32);_cfgb .CryptBlocks (OE ,_fdcd [:32]);_ceab .OE =OE ;return nil ;};const (PermOwner =Permissions (_ag .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_gaf stdHandlerR6 )alg2a (_aeg *StdEncryptDict ,_gfce []byte )([]byte ,Permissions ,error ){if _dbe :=_bda ("\u0061\u006c\u00672\u0061","\u004f",48,_aeg .O );_dbe !=nil {return nil ,0,_dbe ;};if _adf :=_bda ("\u0061\u006c\u00672\u0061","\u0055",48,_aeg .U );_adf !=nil {return nil ,0,_adf ;};if len (_gfce )> 127{_gfce =_gfce [:127];};_ddd ,_dcbg :=_gaf .alg12 (_aeg ,_gfce );if _dcbg !=nil {return nil ,0,_dcbg ;};var (_gec []byte ;_efa []byte ;_ffe []byte ;);var _edbg Permissions ;if len (_ddd )!=0{_edbg =PermOwner ;_agf :=make ([]byte ,len (_gfce )+8+48);_cddg :=copy (_agf ,_gfce );_cddg +=copy (_agf [_cddg :],_aeg .O [40:48]);_cddg +=copy (_agf [_cddg :],_aeg .U [0:48]);_gec =_agf ;_efa =_aeg .OE ;_ffe =_aeg .U [0:48];}else {_ddd ,_dcbg =_gaf .alg11 (_aeg ,_gfce );if _dcbg ==nil &&len (_ddd )==0{_ddd ,_dcbg =_gaf .alg11 (_aeg ,[]byte (""));};if _dcbg !=nil {return nil ,0,_dcbg ;}else if len (_ddd )==0{return nil ,0,nil ;};_edbg =_aeg .P ;_aef :=make ([]byte ,len (_gfce )+8);_baff :=copy (_aef ,_gfce );_baff +=copy (_aef [_baff :],_aeg .U [40:48]);_gec =_aef ;_efa =_aeg .UE ;_ffe =nil ;};if _ffg :=_bda ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_efa );_ffg !=nil {return nil ,0,_ffg ;};_efa =_efa [:32];_ffd ,_dcbg :=_gaf .alg2b (_aeg .R ,_gec ,_gfce ,_ffe );if _dcbg !=nil {return nil ,0,_dcbg ;};_fg ,_dcbg :=_e .NewCipher (_ffd [:32]);if _dcbg !=nil {return nil ,0,_dcbg ;};_dec :=make ([]byte ,_e .BlockSize );_dbf :=_f .NewCBCDecrypter (_fg ,_dec );_dgg :=make ([]byte ,32);_dbf .CryptBlocks (_dgg ,_efa );if _aeg .R ==5{return _dgg ,_edbg ,nil ;};_dcbg =_gaf .alg13 (_aeg ,_dgg );if _dcbg !=nil {return nil ,0,_dcbg ;};return _dgg ,_edbg ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_cd *StdEncryptDict ,_bg ,_de []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ea *StdEncryptDict ,_g []byte )([]byte ,Permissions ,error );};func (_ecc stdHandlerR6 )alg13 (_dca *StdEncryptDict ,_bddf []byte )error {if _gaga :=_bda ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bddf );_gaga !=nil {return _gaga ;};if _ffab :=_bda ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dca .Perms );_ffab !=nil {return _ffab ;};_cbc :=make ([]byte ,16);copy (_cbc ,_dca .Perms [:16]);_bgdg ,_ceaa :=_e .NewCipher (_bddf [:32]);if _ceaa !=nil {return _ceaa ;};_dbbf :=_df (_bgdg );_dbbf .CryptBlocks (_cbc ,_cbc );if !_ee .Equal (_cbc [9:12],[]byte ("\u0061\u0064\u0062")){return _ed .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ecb :=Permissions (_edg .LittleEndian .Uint32 (_cbc [0:4]));if _ecb !=_dca .P {return _ed .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_bab :=true ;if _cbc [8]=='T'{_bab =true ;}else if _cbc [8]=='F'{_bab =false ;}else {return _ed .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _bab !=_dca .EncryptMetadata {return _ed .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_ab stdHandlerR4 )alg3Key (R int ,_fdc []byte )[]byte {_ga :=_faa .New ();_ca :=_ab .paddedPass (_fdc );_ga .Write (_ca );if R >=3{for _dcb :=0;_dcb < 50;_dcb ++{_bcf :=_ga .Sum (nil );_ga =_faa .New ();_ga .Write (_bcf );};};_gb :=_ga .Sum (nil );if R ==2{_gb =_gb [0:5];}else {_gb =_gb [0:_ab .Length /8];};return _gb ;};func (_eb stdHandlerR4 )alg2 (_cf *StdEncryptDict ,_dga []byte )[]byte {_cb .Log .Trace ("\u0061\u006c\u0067\u0032");_bdac :=_eb .paddedPass (_dga );_gd :=_faa .New ();_gd .Write (_bdac );_gd .Write (_cf .O );var _gg [4]byte ;_edg .LittleEndian .PutUint32 (_gg [:],uint32 (_cf .P ));_gd .Write (_gg [:]);_cb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gg );_gd .Write ([]byte (_eb .ID0 ));_cb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cf .R ,_cf .EncryptMetadata );if (_cf .R >=4)&&!_cf .EncryptMetadata {_gd .Write ([]byte {0xff,0xff,0xff,0xff});};_gf :=_gd .Sum (nil );if _cf .R >=3{_gd =_faa .New ();for _fe :=0;_fe < 50;_fe ++{_gd .Reset ();_gd .Write (_gf [0:_eb .Length /8]);_gf =_gd .Sum (nil );};};if _cf .R >=3{return _gf [0:_eb .Length /8];};return _gf [0:5];};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};const _agc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type ecbDecrypter ecb ;func _bda (_fc ,_dg string ,_cbf int ,_cdd []byte )error {if len (_cdd )< _cbf {return errInvalidField {Func :_fc ,Field :_dg ,Exp :_cbf ,Got :len (_cdd )};};return nil ;};func (_ff *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ff ._da !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ff ._eef .Decrypt (dst ,src [:_ff ._da ]);src =src [_ff ._da :];dst =dst [_ff ._da :];};};func (stdHandlerR4 )paddedPass (_afa []byte )[]byte {_ce :=make ([]byte ,32);_cbd :=copy (_ce ,_afa );for ;_cbd < 32;_cbd ++{_ce [_cbd ]=_agc [_cbd -len (_afa )];};return _ce ;};func (_dc *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dc ._da !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_dc ._eef .Encrypt (dst ,src [:_dc ._da ]);src =src [_dc ._da :];dst =dst [_dc ._da :];};};func (_dbb stdHandlerR6 )alg12 (_efbg *StdEncryptDict ,_dcg []byte )([]byte ,error ){if _gbg :=_bda ("\u0061\u006c\u00671\u0032","\u0055",48,_efbg .U );_gbg !=nil {return nil ,_gbg ;};if _afe :=_bda ("\u0061\u006c\u00671\u0032","\u004f",48,_efbg .O );_afe !=nil {return nil ,_afe ;};_afd :=make ([]byte ,len (_dcg )+8+48);_faab :=copy (_afd ,_dcg );_faab +=copy (_afd [_faab :],_efbg .O [32:40]);_faab +=copy (_afd [_faab :],_efbg .U [0:48]);_cbdb ,_dcf :=_dbb .alg2b (_efbg .R ,_afd ,_dcg ,_efbg .U [0:48]);if _dcf !=nil {return nil ,_dcf ;};_cbdb =_cbdb [:32];if !_ee .Equal (_cbdb ,_efbg .O [:32]){return nil ,nil ;};return _cbdb ,nil ;};func _bd (_fb _f .Block )*ecb {return &ecb {_eef :_fb ,_da :_fb .BlockSize ()}};func (_cc stdHandlerR4 )alg7 (_gea *StdEncryptDict ,_be []byte )([]byte ,error ){_dfe :=_cc .alg3Key (_gea .R ,_be );_eebd :=make ([]byte ,len (_gea .O ));if _gea .R ==2{_abg ,_gage :=_fa .NewCipher (_dfe );if _gage !=nil {return nil ,_ed .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_abg .XORKeyStream (_eebd ,_gea .O );}else if _gea .R >=3{_bbf :=append ([]byte {},_gea .O ...);for _bgg :=0;_bgg < 20;_bgg ++{_ada :=append ([]byte {},_dfe ...);for _afacc :=0;_afacc < len (_dfe );_afacc ++{_ada [_afacc ]^=byte (19-_bgg );};_eeec ,_eae :=_fa .NewCipher (_ada );if _eae !=nil {return nil ,_ed .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_eeec .XORKeyStream (_eebd ,_bbf );_bbf =append ([]byte {},_eebd ...);};}else {return nil ,_ed .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_db ,_ef :=_cc .alg6 (_gea ,_eebd );if _ef !=nil {return nil ,nil ;};return _db ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_baf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_cdce :=_baf .alg3 (d .R ,upass ,opass );if _cdce !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cdce );return nil ,_cdce ;};d .O =O ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_bef :=_baf .alg2 (d ,upass );U ,_cdce :=_baf .alg5 (_bef ,upass );if _cdce !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cdce );return nil ,_cdce ;};d .U =U ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _bef ,nil ;};type ecb struct{_eef _f .Block ;_da int ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;var _ StdHandler =stdHandlerR6 {};func _aefd (_def []byte )([]byte ,error ){_bf :=_b .New ();_bf .Write (_def );return _bf .Sum (nil ),nil };

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// Authenticate implements StdHandler interface.
func (_egg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _egg .alg2a (d ,pass );};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_aefb stdHandlerR6 )alg2b (R int ,_gcdc ,_fgac ,_beb []byte )([]byte ,error ){if R ==5{return _aefd (_gcdc );};return _ffc (_gcdc ,_fgac ,_beb );};type stdHandlerR6 struct{};

// Authenticate implements StdHandler interface.
func (_fee stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_cfg ,_dfc :=_fee .alg7 (d ,pass );if _dfc !=nil {return nil ,0,_dfc ;};if _cfg !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cfg ,PermOwner ,nil ;};_cb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cfg ,_dfc =_fee .alg6 (d ,pass );if _dfc !=nil {return nil ,0,_dfc ;};if _cfg !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cfg ,d .P ,nil ;};return nil ,0,nil ;};type ecbEncrypter ecb ;func _ffc (_gac ,_deab ,_agce []byte )([]byte ,error ){var (_eca ,_ebf ,_abe _ae .Hash ;);_eca =_b .New ();_gffc :=make ([]byte ,64);_gfb :=_eca ;_gfb .Write (_gac );K :=_gfb .Sum (_gffc [:0]);_gcd :=make ([]byte ,64*(127+64+48));_fdf :=func (_aabg int )([]byte ,error ){_bbd :=len (_deab )+len (K )+len (_agce );_cbfa :=_gcd [:_bbd ];_cff :=copy (_cbfa ,_deab );_cff +=copy (_cbfa [_cff :],K [:]);_cff +=copy (_cbfa [_cff :],_agce );if _cff !=_bbd {_cb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ed .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_gcd [:_bbd *64];_aab (K1 ,_bbd );_ebg ,_ebd :=_gffg (K [0:16]);if _ebd !=nil {return nil ,_ebd ;};_efb :=_f .NewCBCEncrypter (_ebg ,K [16:32]);_efb .CryptBlocks (K1 ,K1 );E :=K1 ;_cfb :=0;for _fcd :=0;_fcd < 16;_fcd ++{_cfb +=int (E [_fcd ]%3);};var _dfea _ae .Hash ;switch _cfb %3{case 0:_dfea =_eca ;case 1:if _ebf ==nil {_ebf =_fd .New384 ();};_dfea =_ebf ;case 2:if _abe ==nil {_abe =_fd .New ();};_dfea =_abe ;};_dfea .Reset ();_dfea .Write (E );K =_dfea .Sum (_gffc [:0]);return E ,nil ;};for _fga :=0;;{E ,_ac :=_fdf (_fga );if _ac !=nil {return nil ,_ac ;};_ffa :=uint8 (E [len (E )-1]);_fga ++;if _fga >=64&&_ffa <=uint8 (_fga -32){break ;};};return K [:32],nil ;};func _aab (_bed []byte ,_cdg int ){_gagc :=_cdg ;for _gagc < len (_bed ){copy (_bed [_gagc :],_bed [:_gagc ]);_gagc *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};var _ StdHandler =stdHandlerR4 {};func (_gfca stdHandlerR6 )alg10 (_edgd *StdEncryptDict ,_bfa []byte )error {if _efea :=_bda ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bfa );_efea !=nil {return _efea ;};_gfg :=uint64 (uint32 (_edgd .P ))|(_ag .MaxUint32 <<32);Perms :=make ([]byte ,16);_edg .LittleEndian .PutUint64 (Perms [:8],_gfg );if _edgd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_ccdc :=_a .ReadFull (_c .Reader ,Perms [12:16]);_ccdc !=nil {return _ccdc ;};_baef ,_dde :=_gffg (_bfa [:32]);if _dde !=nil {return _dde ;};_gfcc :=_aa (_baef );_gfcc .CryptBlocks (Perms ,Perms );_edgd .Perms =Perms [:16];return nil ;};func (_ec errInvalidField )Error ()string {return _eeb .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ec .Func ,_ec .Field ,_ec .Exp ,_ec .Got );};func (_eff stdHandlerR6 )alg8 (_adfb *StdEncryptDict ,_ggf []byte ,_fge []byte )error {if _adg :=_bda ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ggf );_adg !=nil {return _adg ;};var _aff [16]byte ;if _ ,_bafd :=_a .ReadFull (_c .Reader ,_aff [:]);_bafd !=nil {return _bafd ;};_ebff :=_aff [0:8];_ddg :=_aff [8:16];_dddd :=make ([]byte ,len (_fge )+len (_ebff ));_cfge :=copy (_dddd ,_fge );_cfge +=copy (_dddd [_cfge :],_ebff );_fce ,_efe :=_eff .alg2b (_adfb .R ,_dddd ,_fge ,nil );if _efe !=nil {return _efe ;};U :=make ([]byte ,len (_fce )+len (_ebff )+len (_ddg ));_cfge =copy (U ,_fce [:32]);_cfge +=copy (U [_cfge :],_ebff );_cfge +=copy (U [_cfge :],_ddg );_adfb .U =U ;_cfge =len (_fge );_cfge +=copy (_dddd [_cfge :],_ddg );_fce ,_efe =_eff .alg2b (_adfb .R ,_dddd ,_fge ,nil );if _efe !=nil {return _efe ;};_eeea ,_efe :=_gffg (_fce [:32]);if _efe !=nil {return _efe ;};_cbb :=make ([]byte ,_e .BlockSize );_abc :=_f .NewCBCEncrypter (_eeea ,_cbb );UE :=make ([]byte ,32);_abc .CryptBlocks (UE ,_ggf [:32]);_adfb .UE =UE ;return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _df (_dce _f .Block )_f .BlockMode {return (*ecbDecrypter )(_bd (_dce ))};func (_bdd *ecbEncrypter )BlockSize ()int {return _bdd ._da };func (_fca stdHandlerR6 )alg11 (_feg *StdEncryptDict ,_eac []byte )([]byte ,error ){if _gfcca :=_bda ("\u0061\u006c\u00671\u0031","\u0055",48,_feg .U );_gfcca !=nil {return nil ,_gfcca ;};_agb :=make ([]byte ,len (_eac )+8);_bgd :=copy (_agb ,_eac );_bgd +=copy (_agb [_bgd :],_feg .U [32:40]);_fgb ,_gbfc :=_fca .alg2b (_feg .R ,_agb ,_eac ,nil );if _gbfc !=nil {return nil ,_gbfc ;};_fgb =_fgb [:32];if !_ee .Equal (_fgb ,_feg .U [:32]){return nil ,nil ;};return _fgb ,nil ;};func (_af *ecbDecrypter )BlockSize ()int {return _af ._da };func (_aec stdHandlerR4 )alg3 (R int ,_aed ,_aede []byte )([]byte ,error ){var _ba []byte ;if len (_aede )> 0{_ba =_aec .alg3Key (R ,_aede );}else {_ba =_aec .alg3Key (R ,_aed );};_gde ,_cea :=_fa .NewCipher (_ba );if _cea !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eda :=_aec .paddedPass (_aed );_gff :=make ([]byte ,len (_eda ));_gde .XORKeyStream (_gff ,_eda );if R >=3{_aac :=make ([]byte ,len (_ba ));for _gffb :=0;_gffb < 19;_gffb ++{for _fde :=0;_fde < len (_ba );_fde ++{_aac [_fde ]=_ba [_fde ]^byte (_gffb +1);};_fec ,_bae :=_fa .NewCipher (_aac );if _bae !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fec .XORKeyStream (_gff ,_gff );};};return _gff ,nil ;};func (_gag stdHandlerR4 )alg4 (_gc []byte ,_fcb []byte )([]byte ,error ){_gbd ,_cdc :=_fa .NewCipher (_gc );if _cdc !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fea :=[]byte (_agc );_eee :=make ([]byte ,len (_fea ));_gbd .XORKeyStream (_eee ,_fea );return _eee ,nil ;};