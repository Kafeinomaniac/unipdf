//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_bdc "bufio";_cbd "bytes";_gg "compress/lzw";_af "compress/zlib";_fg "crypto/md5";_afbb "crypto/rand";_ae "encoding/hex";_d "errors";_afb "fmt";_df "github.com/unidoc/unipdf/v3/common";_eg "github.com/unidoc/unipdf/v3/core/security";_fea "github.com/unidoc/unipdf/v3/core/security/crypt";_dd "github.com/unidoc/unipdf/v3/internal/ccittfax";_gf "github.com/unidoc/unipdf/v3/internal/imageutil";_ef "github.com/unidoc/unipdf/v3/internal/jbig2";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ac "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_cg "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bdb "github.com/unidoc/unipdf/v3/internal/strutils";_de "golang.org/x/image/tiff/lzw";_fb "golang.org/x/xerrors";_bc "image";_cb "image/color";_bd "image/jpeg";_b "io";_eb "os";_c "reflect";_a "regexp";_g "sort";_e "strconv";_gc "strings";_cd "time";);

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_eaae *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_ddeg :=MultiEncoder {};_ddeg ._fbaa =[]StreamEncoder {};return &_ddeg ;};func (_ffgc *PdfCrypt )decryptBytes (_cbbf []byte ,_ccag string ,_cfe []byte )([]byte ,error ){_df .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_fgee ,_ebd :=_ffgc ._gfgf [_ccag ];if !_ebd {return nil ,_afb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ccag );};return _fgee .DecryptBytes (_cbbf ,_cfe );};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_bcgc *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _ggd _cbd .Buffer ;for _dfb :=0;_dfb < len (data );_dfb +=4{_ddae :=data [_dfb ];_bbaff :=1;_efae :=byte (0);if _dfb +1< len (data ){_efae =data [_dfb +1];_bbaff ++;};_cbca :=byte (0);if _dfb +2< len (data ){_cbca =data [_dfb +2];_bbaff ++;};_agecd :=byte (0);if _dfb +3< len (data ){_agecd =data [_dfb +3];_bbaff ++;};_accg :=(uint32 (_ddae )<<24)|(uint32 (_efae )<<16)|(uint32 (_cbca )<<8)|uint32 (_agecd );if _accg ==0{_ggd .WriteByte ('z');}else {_efee :=_bcgc .base256Tobase85 (_accg );for _ ,_aedd :=range _efee [:_bbaff +1]{_ggd .WriteByte (_aedd +'!');};};};_ggd .WriteString ("\u007e\u003e");return _ggd .Bytes (),nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_gdgc *PdfParser )GetTrailer ()*PdfObjectDictionary {return _gdgc ._abab };

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};func (_cac *PdfCrypt )encryptBytes (_dcd []byte ,_dcfeg string ,_fgd []byte )([]byte ,error ){_df .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cff ,_edeg :=_cac ._gfgf [_dcfeg ];if !_edeg {return nil ,_afb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dcfeg );};return _cff .EncryptBytes (_dcd ,_fgd );};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_fbbg *JBIG2Encoder )DecodeImages (encoded []byte )([]_bc .Image ,error ){const _gdbd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_bbcf ,_ecef :=_ac .Decode (encoded ,_ac .Parameters {},_fbbg .Globals .ToDocumentGlobals ());if _ecef !=nil {return nil ,_ff .Wrap (_ecef ,_gdbd ,"");};_acag ,_ecef :=_bbcf .PageNumber ();if _ecef !=nil {return nil ,_ff .Wrap (_ecef ,_gdbd ,"");};_efga :=[]_bc .Image {};var _edaa _bc .Image ;for _ddaf :=1;_ddaf <=_acag ;_ddaf ++{_edaa ,_ecef =_bbcf .DecodePageImage (_ddaf );if _ecef !=nil {return nil ,_ff .Wrapf (_ecef ,_gdbd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ddaf );};_efga =append (_efga ,_edaa );};return _efga ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_bedb *PdfParser )skipSpaces ()(int ,error ){_aace :=0;for {_ccgfd ,_gef :=_bedb ._adedf .ReadByte ();if _gef !=nil {return 0,_gef ;};if IsWhiteSpace (_ccgfd ){_aace ++;}else {_bedb ._adedf .UnreadByte ();break ;};};return _aace ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ddgc *JBIG2Encoder )EncodeImage (img _bc .Image )([]byte ,error ){return _ddgc .encodeImage (img )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_abbb *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_fag :=MakeDict ();_fag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abbb .GetFilterName ()));return _fag ;};func (_bbdae *PdfParser )parseArray ()(*PdfObjectArray ,error ){_aacb :=MakeArray ();_bbdae ._adedf .ReadByte ();for {_bbdae .skipSpaces ();_abae ,_bfebe :=_bbdae ._adedf .Peek (1);if _bfebe !=nil {return _aacb ,_bfebe ;};if _abae [0]==']'{_bbdae ._adedf .ReadByte ();break ;};_cgdg ,_bfebe :=_bbdae .parseObject ();if _bfebe !=nil {return _aacb ,_bfebe ;};_aacb .Append (_cgdg );};return _aacb ,nil ;};func (_gdedb *PdfParser )repairSeekXrefMarker ()error {_daca ,_fdabc :=_gdedb ._fcfg .Seek (0,_eb .SEEK_END );if _fdabc !=nil {return _fdabc ;};_baga :=_a .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _cdff int64 ;var _gcec int64 =1000;for _cdff < _daca {if _daca <=(_gcec +_cdff ){_gcec =_daca -_cdff ;};_ ,_gdbf :=_gdedb ._fcfg .Seek (-_cdff -_gcec ,_eb .SEEK_END );if _gdbf !=nil {return _gdbf ;};_bebf :=make ([]byte ,_gcec );_gdedb ._fcfg .Read (_bebf );_df .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_bebf ));_bdac :=_baga .FindAllStringIndex (string (_bebf ),-1);if _bdac !=nil {_gddeca :=_bdac [len (_bdac )-1];_df .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bdac );_gdedb ._fcfg .Seek (-_cdff -_gcec +int64 (_gddeca [0]),_eb .SEEK_END );_gdedb ._adedf =_bdc .NewReader (_gdedb ._fcfg );for {_addg ,_cddg :=_gdedb ._adedf .Peek (1);if _cddg !=nil {return _cddg ;};_df .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_addg [0],_addg [0]);if !IsWhiteSpace (_addg [0]){break ;};_gdedb ._adedf .Discard (1);};return nil ;};_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_cdff +=_gcec ;};_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gbfa *PdfObjectArray ,_eabg bool ){_gbfa ,_eabg =TraceToDirectObject (obj ).(*PdfObjectArray );return _gbfa ,_eabg ;};func (_dcf *PdfCrypt )securityHandler ()_eg .StdHandler {if _dcf ._fae .R >=5{return _eg .NewHandlerR6 ();};return _eg .NewHandlerR4 (_dcf ._bda ,_dcf ._fef .Length );};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_gcggc int ,_ccca bool ){_ggaa ,_ccca :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _ccca &&_ggaa !=nil {return int (*_ggaa ),true ;};return 0,false ;};

// String returns a string describing `stream`.
func (_ecfb *PdfObjectStream )String ()string {return _afb .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ecfb .ObjectNumber ,_ecfb .PdfObjectDictionary );};

// UpdateParams updates the parameter values of the encoder.
func (_cafd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_gbc *_gf .ImageBase ;};type cryptFilters map[string ]_fea .Filter ;

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_efgb :=&ASCIIHexEncoder {};return _efgb };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_fgedb *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dfba *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_cccg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ef .DecodeBytes (encoded ,_ac .Parameters {},_cccg .Globals );};func _efa (_dfc PdfObject )(int64 ,int64 ,error ){if _edb ,_acc :=_dfc .(*PdfIndirectObject );_acc {return _edb .ObjectNumber ,_edb .GenerationNumber ,nil ;};if _geb ,_aeb :=_dfc .(*PdfObjectStream );_aeb {return _geb .ObjectNumber ,_geb .GenerationNumber ,nil ;};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// UpdateParams updates the parameter values of the encoder.
func (_bef *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_gbfe ,_bgaf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bgaf ==nil {_bef .Predictor =int (_gbfe );};_bccb ,_bgaf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bgaf ==nil {_bef .BitsPerComponent =int (_bccb );};_aac ,_bgaf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bgaf ==nil {_bef .Columns =int (_aac );};_gac ,_bgaf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bgaf ==nil {_bef .Colors =int (_gac );};};var _dgd =_a .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_gafc *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_gafc ._fcfg .Seek (0,_eb .SEEK_SET );_gafc ._adedf =_bdc .NewReader (_gafc ._fcfg );_eafe :=20;_fagg :=make ([]byte ,_eafe );for {_bebbf ,_ddfa :=_gafc ._adedf .ReadByte ();if _ddfa !=nil {if _ddfa ==_b .EOF {break ;}else {return 0,0,_ddfa ;};};if IsDecimalDigit (_bebbf )&&_fagg [_eafe -1]=='.'&&IsDecimalDigit (_fagg [_eafe -2])&&_fagg [_eafe -3]=='-'&&_fagg [_eafe -4]=='F'&&_fagg [_eafe -5]=='D'&&_fagg [_eafe -6]=='P'{_fafc :=int (_fagg [_eafe -2]-'0');_fdge :=int (_bebbf -'0');return _fafc ,_fdge ,nil ;};_fagg =append (_fagg [1:_eafe ],_bebbf );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};type offsetReader struct{_ebbd _b .ReadSeeker ;_gdbdf int64 ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_acd *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_deaf :=MakeDict ();_deaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acd .GetFilterName ()));_agdc :=_acd .MakeDecodeParams ();if _agdc !=nil {_deaf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agdc );};_deaf .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_acd .EarlyChange )));return _deaf ;};

// GetFilterName returns the name of the encoding filter.
func (_gccde *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// UpdateParams updates the parameter values of the encoder.
func (_cbbd *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_abcg *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_cdca :=n ;_ggcb :=0;_baebc :=0;for _cdca > 0{_afbea ,_eecg :=_abcg ._adedf .Read (p [_ggcb :]);if _eecg !=nil {_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_afbea ,_baebc ,_eecg .Error ());return _ggcb ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_baebc ++;_ggcb +=_afbea ;_cdca -=_afbea ;};return _ggcb ,nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_bgdb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_bgdb .PdfObjectDictionary =encoder .MakeStreamDict ();_bfad ,_acecc :=encoder .EncodeBytes (contents );if _acecc !=nil {return nil ,_acecc ;};_bgdb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bfad ))));_bgdb .Stream =_bfad ;return _bgdb ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};var _eeee =_a .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_fb .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _agcbe ,_adfg :=obj .(*PdfObjectReference );_adfg {obj =_agcbe .Resolve ();};_ddefb ,_bcbc :=obj .(*PdfIndirectObject );_eagg :=0;for _bcbc {obj =_ddefb .PdfObject ;_ddefb ,_bcbc =GetIndirect (obj );_eagg ++;if _eagg > _bccga {_df .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_bccga );return nil ;};};return obj ;};var _bfdg =_a .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// WriteString outputs the object as it is to be written to file.
func (_dcfag *PdfObjectArray )WriteString ()string {var _fceed _gc .Builder ;_fceed .WriteString ("\u005b");for _eegc ,_bce :=range _dcfag .Elements (){_fceed .WriteString (_bce .WriteString ());if _eegc < (_dcfag .Len ()-1){_fceed .WriteString ("\u0020");};};_fceed .WriteString ("\u005d");return _fceed .String ();};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ddcde *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aedc *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aedgd *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddda :=MakeDict ();_ddda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aedgd .GetFilterName ()));_ebdg :=_aedgd .MakeDecodeParams ();if _ebdg !=nil {_ddda .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ebdg );};return _ddda ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_ceac *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_afd *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aecf :=_cbd .NewReader (encoded );var _aded []byte ;for {_ffad ,_gbee :=_aecf .ReadByte ();if _gbee !=nil {return nil ,_gbee ;};if _ffad > 128{_ecbd ,_gdbc :=_aecf .ReadByte ();if _gdbc !=nil {return nil ,_gdbc ;};for _eggf :=0;_eggf < 257-int (_ffad );_eggf ++{_aded =append (_aded ,_ecbd );};}else if _ffad < 128{for _dcca :=0;_dcca < int (_ffad )+1;_dcca ++{_adgb ,_bfddg :=_aecf .ReadByte ();if _bfddg !=nil {return nil ,_bfddg ;};_aded =append (_aded ,_adgb );};}else {break ;};};return _aded ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_bebbc :=PdfObjectString {_ggbb :s };return &_bebbc };

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_ddac *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ddac .GetFilterName ());return data ,ErrNoJPXDecode ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _b .ReadSeeker )(*PdfParser ,error ){_ebec :=&PdfParser {_fcfg :rs ,ObjCache :make (objectCache ),_bafg :map[int64 ]bool {}};_cbfd ,_bcbd ,_dfde :=_ebec .parsePdfVersion ();if _dfde !=nil {_df .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dfde );return nil ,_dfde ;};_ebec ._gaad .Major =_cbfd ;_ebec ._gaad .Minor =_bcbd ;if _ebec ._abab ,_dfde =_ebec .loadXrefs ();_dfde !=nil {_df .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dfde );return nil ,_dfde ;};_df .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ebec ._abab );if len (_ebec ._ebbc .ObjectMap )==0{return nil ,_afb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ebec ,nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_bac :=PdfObjectName (s );return &_bac };

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_beagg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_acfg :=_beagg ._ccfc [key ];if !_acfg {_beagg ._fdaf =append (_beagg ._fdaf ,key );};_beagg ._ccfc [key ]=val ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func _aeda (_egdf *PdfObjectStream ,_bfbd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_aafa :=NewCCITTFaxEncoder ();_cfaf :=_egdf .PdfObjectDictionary ;if _cfaf ==nil {return _aafa ,nil ;};if _bfbd ==nil {_edbfa :=TraceToDirectObject (_cfaf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _edbfa !=nil {switch _fgga :=_edbfa .(type ){case *PdfObjectDictionary :_bfbd =_fgga ;break ;case *PdfObjectArray :if _fgga .Len ()==1{if _edfd ,_aadg :=GetDict (_fgga .Get (0));_aadg {_bfbd =_edfd ;};};default:_df .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_edbfa );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bfbd ==nil {_df .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_edbfa );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fbfb ,_fdag :=GetNumberAsInt64 (_bfbd .Get ("\u004b"));_fdag ==nil {_aafa .K =int (_fbfb );};if _acae ,_fbg :=GetNumberAsInt64 (_bfbd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_fbg ==nil {_aafa .Columns =int (_acae );}else {_aafa .Columns =1728;};if _cbdg ,_dabg :=GetNumberAsInt64 (_bfbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dabg ==nil {_aafa .BlackIs1 =_cbdg > 0;}else {if _faag ,_abce :=GetBoolVal (_bfbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_abce {_aafa .BlackIs1 =_faag ;}else {if _bdfb ,_fbcf :=GetArray (_bfbd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fbcf {_cdgd ,_faefa :=_bdfb .ToIntegerArray ();if _faefa ==nil {_aafa .BlackIs1 =_cdgd [0]==1&&_cdgd [1]==0;};};};};if _egaf ,_ecf :=GetNumberAsInt64 (_bfbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ecf ==nil {_aafa .EncodedByteAlign =_egaf > 0;}else {if _edbe ,_fbde :=GetBoolVal (_bfbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fbde {_aafa .EncodedByteAlign =_edbe ;};};if _fggd ,_eefg :=GetNumberAsInt64 (_bfbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_eefg ==nil {_aafa .EndOfLine =_fggd > 0;}else {if _gede ,_deae :=GetBoolVal (_bfbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_deae {_aafa .EndOfLine =_gede ;};};if _cdf ,_eff :=GetNumberAsInt64 (_bfbd .Get ("\u0052\u006f\u0077\u0073"));_eff ==nil {_aafa .Rows =int (_cdf );};_aafa .EndOfBlock =true ;if _egc ,_dba :=GetNumberAsInt64 (_bfbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dba ==nil {_aafa .EndOfBlock =_egc > 0;}else {if _bcccc ,_cbbdc :=GetBoolVal (_bfbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cbbdc {_aafa .EndOfBlock =_bcccc ;};};if _affb ,_fdage :=GetNumberAsInt64 (_bfbd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fdage !=nil {_aafa .DamagedRowsBeforeError =int (_affb );};_df .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bfbd .String ());return _aafa ,nil ;};func _dadbe (_egde *PdfObjectStream ,_cdcb *MultiEncoder )(*DCTEncoder ,error ){_feeb :=NewDCTEncoder ();_bgee :=_egde .PdfObjectDictionary ;if _bgee ==nil {return _feeb ,nil ;};_dcge :=_egde .Stream ;if _cdcb !=nil {_ffgd ,_dded :=_cdcb .DecodeBytes (_dcge );if _dded !=nil {return nil ,_dded ;};_dcge =_ffgd ;};_aeee :=_cbd .NewReader (_dcge );_agbg ,_daab :=_bd .DecodeConfig (_aeee );if _daab !=nil {_df .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_daab );return nil ,_daab ;};switch _agbg .ColorModel {case _cb .RGBAModel :_feeb .BitsPerComponent =8;_feeb .ColorComponents =3;case _cb .RGBA64Model :_feeb .BitsPerComponent =16;_feeb .ColorComponents =3;case _cb .GrayModel :_feeb .BitsPerComponent =8;_feeb .ColorComponents =1;case _cb .Gray16Model :_feeb .BitsPerComponent =16;_feeb .ColorComponents =1;case _cb .CMYKModel :_feeb .BitsPerComponent =8;_feeb .ColorComponents =4;case _cb .YCbCrModel :_feeb .BitsPerComponent =8;_feeb .ColorComponents =3;default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_feeb .Width =_agbg .Width ;_feeb .Height =_agbg .Height ;_df .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_feeb );_feeb .Quality =DefaultJPEGQuality ;return _feeb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gcdfd *PdfObjectFloat )WriteString ()string {return _e .FormatFloat (float64 (*_gcdfd ),'f',-1,64);};

// GetFilterName returns the name of the encoding filter.
func (_cfa *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func (_ecd *PdfCrypt )saveCryptFilters (_efab *PdfObjectDictionary )error {if _ecd ._fef .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_cdbc :=MakeDict ();_efab .Set ("\u0043\u0046",_cdbc );for _bgc ,_baef :=range _ecd ._gfgf {if _bgc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ebcg :=_fab (_baef ,"");_cdbc .Set (PdfObjectName (_bgc ),_ebcg );};_efab .Set ("\u0053\u0074\u0072\u0046",MakeName (_ecd ._gdg ));_efab .Set ("\u0053\u0074\u006d\u0046",MakeName (_ecd ._abc ));return nil ;};func (_acfdg *PdfParser )traceStreamLength (_gadd PdfObject )(PdfObject ,error ){_ddgab ,_eaffb :=_gadd .(*PdfObjectReference );if _eaffb {_baebd ,_edcb :=_acfdg ._bafg [_ddgab .ObjectNumber ];if _edcb &&_baebd {_df .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_acfdg ._bafg [_ddgab .ObjectNumber ]=true ;};_deaed ,_degb :=_acfdg .Resolve (_gadd );if _degb !=nil {return nil ,_degb ;};_df .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_deaed );if _eaffb {_acfdg ._bafg [_ddgab .ObjectNumber ]=false ;};return _deaed ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_bfgda *PdfObjectArray )Elements ()[]PdfObject {if _bfgda ==nil {return nil ;};return _bfgda ._ddcb ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gefb :=PdfObjectInteger (val );return &_gefb };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_abdg *PdfParser )IsAuthenticated ()bool {return _abdg ._bfdde ._eae };

// UpdateParams updates the parameter values of the encoder.
func (_fgae *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_feba :=_cbd .NewReader ([]byte (txt ));_dfdc :=&PdfParser {ObjCache :objectCache {},_fcfg :_feba ,_adedf :_bdc .NewReader (_feba ),_egbc :int64 (len (txt )),_bafg :map[int64 ]bool {}};_dfdc ._ebbc .ObjectMap =make (map[int ]XrefObject );return _dfdc ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_ecgb :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _ecgb ==nil {return NewRawEncoder (),nil ;};if _ ,_abeb :=_ecgb .(*PdfObjectNull );_abeb {return NewRawEncoder (),nil ;};_ccaee ,_begd :=_ecgb .(*PdfObjectName );if !_begd {_eafea ,_face :=_ecgb .(*PdfObjectArray );if !_face {return nil ,_afb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _eafea .Len ()==0{return NewRawEncoder (),nil ;};if _eafea .Len ()!=1{_faab ,_acgd :=_gda (streamObj );if _acgd !=nil {_df .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_acgd );return nil ,_acgd ;};_df .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_faab );return _faab ,nil ;};_ecgb =_eafea .Get (0);_ccaee ,_face =_ecgb .(*PdfObjectName );if !_face {return nil ,_afb .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_ccaee {case StreamEncodingFilterNameFlate :return _bfeg (streamObj ,nil );case StreamEncodingFilterNameLZW :return _ecg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _dadbe (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _bfge (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _aeda (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _acabf (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_afb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_ccaee );};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_fbdf *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _efgf _cbd .Buffer ;_ecce :=_cbd .NewReader (encoded );var _fdg _b .ReadCloser ;if _fbdf .EarlyChange ==1{_fdg =_de .NewReader (_ecce ,_de .MSB ,8);}else {_fdg =_gg .NewReader (_ecce ,_gg .MSB ,8);};defer _fdg .Close ();_ ,_bfg :=_efgf .ReadFrom (_fdg );if _bfg !=nil {return nil ,_bfg ;};return _efgf .Bytes (),nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_eeba *PdfObjectString )Decoded ()string {if _eeba ==nil {return "";};_ddaea :=[]byte (_eeba ._ggbb );if len (_ddaea )>=2&&_ddaea [0]==0xFE&&_ddaea [1]==0xFF{return _bdb .UTF16ToString (_ddaea [2:]);};return _bdb .PDFDocEncodingToString (_ddaea );};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dfd *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _afdd ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _gebg :=_dfd .AddPageImage (img ,&_dfd .DefaultPageSettings );_gebg !=nil {return nil ,_ff .Wrap (_gebg ,_afdd ,"");};return _dfd .Encode ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egfb *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func (_caf *PdfParser )lookupByNumberWrapper (_cfc int ,_fa bool )(PdfObject ,bool ,error ){_baa ,_ge ,_aca :=_caf .lookupByNumber (_cfc ,_fa );if _aca !=nil {return nil ,_ge ,_aca ;};if !_ge &&_caf ._bfdde !=nil &&!_caf ._bfdde .isDecrypted (_baa ){_efd :=_caf ._bfdde .Decrypt (_baa ,0,0);if _efd !=nil {return nil ,_ge ,_efd ;};};return _baa ,_ge ,nil ;};func (_bccc *PdfCrypt )generateParams (_fde ,_fbd []byte )error {_bedd :=_bccc .securityHandler ();_gaf ,_abag :=_bedd .GenerateParams (&_bccc ._fae ,_fbd ,_fde );if _abag !=nil {return _abag ;};_bccc ._acf =_gaf ;return nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_ceee *PdfParser )GetCrypter ()*PdfCrypt {return _ceee ._bfdde };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ccbb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_gacf :=MakeDict ();_gacf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_ccbb .GetFilterArray ());for _ ,_bdaf :=range _ccbb ._fbaa {_cgdd :=_bdaf .MakeStreamDict ();for _ ,_gegc :=range _cgdd .Keys (){_dggg :=_cgdd .Get (_gegc );if _gegc !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_gegc !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_gacf .Set (_gegc ,_dggg );};};};_ddggc :=_ccbb .MakeDecodeParams ();if _ddggc !=nil {_gacf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ddggc );};return _gacf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_fbdc *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_eace :=MakeDict ();_eace .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbdc .GetFilterName ()));return _eace ;};func (_gbe *FlateEncoder )postDecodePredict (_dgfc []byte )([]byte ,error ){if _gbe .Predictor > 1{if _gbe .Predictor ==2{_df .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_df .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_gbe .Colors );_dadgd :=int (_gbe .Columns )*_gbe .Colors ;if _dadgd < 1{return []byte {},nil ;};_bde :=len (_dgfc )/_dadgd ;if len (_dgfc )%_dadgd !=0{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgfc ),_dadgd );};if _dadgd %_gbe .Colors !=0{return nil ,_afb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_dadgd ,_gbe .Colors );};if _dadgd > len (_dgfc ){_df .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dadgd ,len (_dgfc ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_df .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dgfc ),_dgfc );_abb :=_cbd .NewBuffer (nil );for _gcbb :=0;_gcbb < _bde ;_gcbb ++{_eaec :=_dgfc [_dadgd *_gcbb :_dadgd *(_gcbb +1)];for _gecbc :=_gbe .Colors ;_gecbc < _dadgd ;_gecbc ++{_eaec [_gecbc ]+=_eaec [_gecbc -_gbe .Colors ];};_abb .Write (_eaec );};_gbde :=_abb .Bytes ();_df .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gbde ),_gbde );return _gbde ,nil ;}else if _gbe .Predictor >=10&&_gbe .Predictor <=15{_df .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aee :=int (_gbe .Columns *_gbe .Colors +1);_gbcb :=len (_dgfc )/_aee ;if len (_dgfc )%_aee !=0{return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgfc ),_aee );};if _aee > len (_dgfc ){_df .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aee ,len (_dgfc ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cbf :=_cbd .NewBuffer (nil );_df .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gbe .Columns );_df .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dgfc ),_aee ,_gbcb );_fcgc :=make ([]byte ,_aee );for _ade :=0;_ade < _aee ;_ade ++{_fcgc [_ade ]=0;};_bff :=_gbe .Colors ;for _dcc :=0;_dcc < _gbcb ;_dcc ++{_aedg :=_dgfc [_aee *_dcc :_aee *(_dcc +1)];_ddf :=_aedg [0];switch _ddf {case _gccd :case _aab :for _efed :=1+_bff ;_efed < _aee ;_efed ++{_aedg [_efed ]+=_aedg [_efed -_bff ];};case _eaeb :for _feaf :=1;_feaf < _aee ;_feaf ++{_aedg [_feaf ]+=_fcgc [_feaf ];};case _dffe :for _bad :=1;_bad < _bff +1;_bad ++{_aedg [_bad ]+=_fcgc [_bad ]/2;};for _acfd :=_bff +1;_acfd < _aee ;_acfd ++{_aedg [_acfd ]+=byte ((int (_aedg [_acfd -_bff ])+int (_fcgc [_acfd ]))/2);};case _ggec :for _ddcf :=1;_ddcf < _aee ;_ddcf ++{var _bge ,_ecc ,_fdab byte ;_ecc =_fcgc [_ddcf ];if _ddcf >=_bff +1{_bge =_aedg [_ddcf -_bff ];_fdab =_fcgc [_ddcf -_bff ];};_aedg [_ddcf ]+=_cbcf (_bge ,_ecc ,_fdab );};default:_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_ddf ,_dcc );return nil ,_afb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ddf );};copy (_fcgc ,_aedg );_cbf .Write (_aedg [1:]);};_efabb :=_cbf .Bytes ();return _efabb ,nil ;}else {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gbe .Predictor );return nil ,_afb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gbe .Predictor );};};return _dgfc ,nil ;};func (_fefe *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_dadb :=MakeDict ();_dadb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_dadb .Set ("\u0056",MakeInteger (int64 (_fefe ._fef .V )));_dadb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_fefe ._fef .Length )));return _dadb ;};func (_gaff *PdfParser )seekToEOFMarker (_bafe int64 )error {var _debc int64 ;var _eegeg int64 =2048;for _debc < _bafe -4{if _bafe <=(_eegeg +_debc ){_eegeg =_bafe -_debc ;};_ ,_ggdf :=_gaff ._fcfg .Seek (-_debc -_eegeg ,_b .SeekEnd );if _ggdf !=nil {return _ggdf ;};_dddc :=make ([]byte ,_eegeg );_gaff ._fcfg .Read (_dddc );_df .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_dddc ));_ecefa :=_bbed .FindAllStringIndex (string (_dddc ),-1);if _ecefa !=nil {_fbcce :=_ecefa [len (_ecefa )-1];_df .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ecefa );_gaff ._fcfg .Seek (-_debc -_eegeg +int64 (_fbcce [0]),_b .SeekEnd );return nil ;};_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_debc +=_eegeg -4;};_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bgad *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_bgad ._fcfg .Seek (offset ,_b .SeekStart );_bgad ._adedf =_bdc .NewReader (_bgad ._fcfg );};func (_adc *PdfParser )readComment ()(string ,error ){var _gdbdd _cbd .Buffer ;_ ,_afcf :=_adc .skipSpaces ();if _afcf !=nil {return _gdbdd .String (),_afcf ;};_fcae :=true ;for {_bcfab ,_aabc :=_adc ._adedf .Peek (1);if _aabc !=nil {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_aabc .Error ());return _gdbdd .String (),_aabc ;};if _fcae &&_bcfab [0]!='%'{return _gdbdd .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fcae =false ;if (_bcfab [0]!='\r')&&(_bcfab [0]!='\n'){_eabd ,_ :=_adc ._adedf .ReadByte ();_gdbdd .WriteByte (_eabd );}else {break ;};};return _gdbdd .String (),nil ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_bdead *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_bgfc :=_bdead .GetFileOffset ();_ ,_faac :=_bdead ._fcfg .Seek (offset ,_b .SeekStart );if _faac !=nil {return nil ,_faac ;};_bbbd :=make ([]byte ,len );_ ,_faac =_b .ReadAtLeast (_bdead ._fcfg ,_bbbd ,int (len ));if _faac !=nil {return nil ,_faac ;};_bdead .SetFileOffset (_bgfc );return _bbbd ,nil ;};func (_afag *PdfParser )repairLocateXref ()(int64 ,error ){_deba :=int64 (1000);_afag ._fcfg .Seek (-_deba ,_eb .SEEK_CUR );_fcbg ,_gabdg :=_afag ._fcfg .Seek (0,_eb .SEEK_CUR );if _gabdg !=nil {return 0,_gabdg ;};_debb :=make ([]byte ,_deba );_afag ._fcfg .Read (_debb );_egga :=_cbag .FindAllStringIndex (string (_debb ),-1);if len (_egga )< 1{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_feff :=int64 (_egga [len (_egga )-1][0]);_eggfb :=_fcbg +_feff ;return _eggfb ,nil ;};

// DecodeStream implements ASCII hex decoding.
func (_bbeb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bbeb .DecodeBytes (streamObj .Stream );};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_beeb :_cg .InitEncodeDocument (false )}};

// GetFilterName returns the name of the encoding filter.
func (_abgec *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_ggg :=&FlateEncoder {};_ggg .Predictor =1;_ggg .BitsPerComponent =8;_ggg .Colors =1;_ggg .Columns =1;return _ggg ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_aaba *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _bebcg []int ;for _ ,_adac :=range _aaba .Elements (){if _ebde ,_egff :=_adac .(*PdfObjectInteger );_egff {_bebcg =append (_bebcg ,int (*_ebde ));}else {return nil ,ErrTypeError ;};};return _bebcg ,nil ;};func _cbcf (_cfff ,_eacc ,_gebd uint8 )uint8 {_bag :=int (_gebd );_cggg :=int (_eacc )-_bag ;_bffc :=int (_cfff )-_bag ;_bag =_gegf (_cggg +_bffc );_cggg =_gegf (_cggg );_bffc =_gegf (_bffc );if _cggg <=_bffc &&_cggg <=_bag {return _cfff ;}else if _bffc <=_bag {return _eacc ;};return _gebd ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_bdg *PdfObjectDictionary );EncodeBytes (_ggc []byte )([]byte ,error );DecodeBytes (_aad []byte )([]byte ,error );DecodeStream (_ddb *PdfObjectStream )([]byte ,error );};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fgda *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _adgbe []float64 ;for _ ,_bacc :=range _fgda .Elements (){switch _ccbg :=_bacc .(type ){case *PdfObjectInteger :_adgbe =append (_adgbe ,float64 (*_ccbg ));case *PdfObjectFloat :_adgbe =append (_adgbe ,float64 (*_ccbg ));default:return nil ,ErrTypeError ;};};return _adgbe ,nil ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// WriteString outputs the object as it is to be written to file.
func (_edef *PdfIndirectObject )WriteString ()string {var _fece _gc .Builder ;_fece .WriteString (_e .FormatInt (_edef .ObjectNumber ,10));_fece .WriteString ("\u0020\u0030\u0020\u0052");return _fece .String ();};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_edc *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _edge _cbd .Buffer ;for _ ,_gccc :=range data {_edge .WriteString (_afb .Sprintf ("\u0025\u002e\u0032X\u0020",_gccc ));};_edge .WriteByte ('>');return _edge .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gfad *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_baaf ,_bfegg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bfegg ==nil {_gfad .BitsPerComponent =int (_baaf );};_gcgg ,_bfegg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bfegg ==nil {_gfad .Width =int (_gcgg );};_bcde ,_bfegg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _bfegg ==nil {_gfad .Height =int (_bcde );};_fcff ,_bfegg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bfegg ==nil {_gfad .ColorComponents =int (_fcff );};};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_fea .FilterDict ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_dgg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fffc :=_cbd .NewReader (encoded );_eceaf ,_dcbc :=_bd .Decode (_fffc );if _dcbc !=nil {_df .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dcbc );return nil ,_dcbc ;};_bgca :=_eceaf .Bounds ();var _fcd =make ([]byte ,_bgca .Dx ()*_bgca .Dy ()*_dgg .ColorComponents *_dgg .BitsPerComponent /8);_defa :=0;for _dddf :=_bgca .Min .Y ;_dddf < _bgca .Max .Y ;_dddf ++{for _caaa :=_bgca .Min .X ;_caaa < _bgca .Max .X ;_caaa ++{_bdgb :=_eceaf .At (_caaa ,_dddf );if _dgg .ColorComponents ==1{if _dgg .BitsPerComponent ==16{_cgg ,_ggbd :=_bdgb .(_cb .Gray16 );if !_ggbd {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcd [_defa ]=byte ((_cgg .Y >>8)&0xff);_defa ++;_fcd [_defa ]=byte (_cgg .Y &0xff);_defa ++;}else {_dcde ,_gddg :=_bdgb .(_cb .Gray );if !_gddg {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcd [_defa ]=byte (_dcde .Y &0xff);_defa ++;};}else if _dgg .ColorComponents ==3{if _dgg .BitsPerComponent ==16{_beg ,_fcgd :=_bdgb .(_cb .RGBA64 );if !_fcgd {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcd [_defa ]=byte ((_beg .R >>8)&0xff);_defa ++;_fcd [_defa ]=byte (_beg .R &0xff);_defa ++;_fcd [_defa ]=byte ((_beg .G >>8)&0xff);_defa ++;_fcd [_defa ]=byte (_beg .G &0xff);_defa ++;_fcd [_defa ]=byte ((_beg .B >>8)&0xff);_defa ++;_fcd [_defa ]=byte (_beg .B &0xff);_defa ++;}else {_bcdb ,_fcfb :=_bdgb .(_cb .RGBA );if _fcfb {_fcd [_defa ]=_bcdb .R &0xff;_defa ++;_fcd [_defa ]=_bcdb .G &0xff;_defa ++;_fcd [_defa ]=_bcdb .B &0xff;_defa ++;}else {_dcef ,_fged :=_bdgb .(_cb .YCbCr );if !_fged {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_afbbc ,_caga ,_bfb ,_ :=_dcef .RGBA ();_fcd [_defa ]=byte (_afbbc >>8);_defa ++;_fcd [_defa ]=byte (_caga >>8);_defa ++;_fcd [_defa ]=byte (_bfb >>8);_defa ++;};};}else if _dgg .ColorComponents ==4{_cga ,_bdge :=_bdgb .(_cb .CMYK );if !_bdge {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcd [_defa ]=255-_cga .C &0xff;_defa ++;_fcd [_defa ]=255-_cga .M &0xff;_defa ++;_fcd [_defa ]=255-_cga .Y &0xff;_defa ++;_fcd [_defa ]=255-_cga .K &0xff;_defa ++;};};};return _fcd ,nil ;};func (_babe *JBIG2Image )toBitmap ()(_deff *_fe .Bitmap ,_fgfd error ){const _edde ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _babe .Data ==nil {return nil ,_ff .Error (_edde ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _babe .Width ==0||_babe .Height ==0{return nil ,_ff .Error (_edde ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _babe .HasPadding {_deff ,_fgfd =_fe .NewWithData (_babe .Width ,_babe .Height ,_babe .Data );}else {_deff ,_fgfd =_fe .NewWithUnpaddedData (_babe .Width ,_babe .Height ,_babe .Data );};if _fgfd !=nil {return nil ,_ff .Wrap (_fgfd ,_edde ,"");};return _deff ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_agfc *PdfParser )GetFileOffset ()int64 {_daae ,_ :=_agfc ._fcfg .Seek (0,_b .SeekCurrent );_daae -=int64 (_agfc ._adedf .Buffered ());return _daae ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_feae *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// Append appends PdfObject(s) to the array.
func (_dcdg *PdfObjectArray )Append (objects ...PdfObject ){if _dcdg ==nil {_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _dcdg ._ddcb ==nil {_dcdg ._ddcb =[]PdfObject {};};for _ ,_dggd :=range objects {_dcdg ._ddcb =append (_dcdg ._ddcb ,_dggd );};};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_bgce *PdfObjectStreams ,_ebadb bool ){_bgce ,_ebadb =obj .(*PdfObjectStreams );return _bgce ,_ebadb ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_fdc *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _aeg [][]byte ;for _eecf :=0;_eecf < len (data );_eecf +=_fdc .Columns {_acdg :=make ([]byte ,_fdc .Columns );_ggda :=0;for _feaa :=0;_feaa < _fdc .Columns ;_feaa ++{if data [_eecf +_feaa ]==255{_acdg [_ggda ]=1;}else {_acdg [_ggda ]=0;};_ggda ++;};_aeg =append (_aeg ,_acdg );};_fedef :=&_dd .Encoder {K :_fdc .K ,Columns :_fdc .Columns ,EndOfLine :_fdc .EndOfLine ,EndOfBlock :_fdc .EndOfBlock ,BlackIs1 :_fdc .BlackIs1 ,DamagedRowsBeforeError :_fdc .DamagedRowsBeforeError ,Rows :_fdc .Rows ,EncodedByteAlign :_fdc .EncodedByteAlign };return _fedef .Encode (_aeg ),nil ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func _bfeg (_beddg *PdfObjectStream ,_dgeb *PdfObjectDictionary )(*FlateEncoder ,error ){_gdge :=NewFlateEncoder ();_bgfg :=_beddg .PdfObjectDictionary ;if _bgfg ==nil {return _gdge ,nil ;};_gdge ._gbc =_dggc (_bgfg );if _dgeb ==nil {_ebda :=TraceToDirectObject (_bgfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _agec :=_ebda .(type ){case *PdfObjectArray :_edeb :=_agec ;if _edeb .Len ()!=1{_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_edeb .Len ());return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ebda =TraceToDirectObject (_edeb .Get (0));case *PdfObjectDictionary :_dgeb =_agec ;case *PdfObjectNull ,nil :default:_df .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_ebda );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dgeb ==nil {return _gdge ,nil ;};_df .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dgeb .String ());_dgab :=_dgeb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dgab ==nil {_df .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_ecdb ,_bfce :=_dgab .(*PdfObjectInteger );if !_bfce {_df .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dgab );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gdge .Predictor =int (*_ecdb );};_dgab =_dgeb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dgab !=nil {_dca ,_bgff :=_dgab .(*PdfObjectInteger );if !_bgff {_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_afb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gdge .BitsPerComponent =int (*_dca );};if _gdge .Predictor > 1{_gdge .Columns =1;_dgab =_dgeb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dgab !=nil {_egeb ,_acg :=_dgab .(*PdfObjectInteger );if !_acg {return nil ,_afb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gdge .Columns =int (*_egeb );};_gdge .Colors =1;_dgab =_dgeb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dgab !=nil {_eec ,_eafg :=_dgab .(*PdfObjectInteger );if !_eafg {return nil ,_afb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_gdge .Colors =int (*_eec );};};return _gdge ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gacc *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gcaf :=MakeDict ();_gcaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gacc .GetFilterName ()));return _gcaf ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);const (_gccd =0;_aab =1;_eaeb =2;_dffe =3;_ggec =4;);func _becb (_fcef ,_cbbbe ,_abac int )error {if _cbbbe < 0||_cbbbe > _fcef {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _abac < _cbbbe {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _abac > _fcef {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dgaa *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_ecgf :=range _dgaa ._fbaa {_ecgf .UpdateParams (params );};};

// String returns the state of the bool as "true" or "false".
func (_eedf *PdfObjectBool )String ()string {if *_eedf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gade *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gade .GetFilterName ());return encoded ,ErrNoJPXDecode ;};func (_faef *PdfCrypt )makeKey (_bcbg string ,_fca ,_afbe uint32 ,_feda []byte )([]byte ,error ){_bcfa ,_bea :=_faef ._gfgf [_bcbg ];if !_bea {return nil ,_afb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bcbg );};return _bcfa .MakeKey (_fca ,_afbe ,_feda );};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_cacg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_afafb :=range another .Keys (){_gaaf :=another .Get (_afafb );_cacg .Set (_afafb ,_gaaf );};};return _cacg ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_bcbb *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_df .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_acba :=_cbd .NewReader (encoded );_ebdd ,_fgdg :=_af .NewReader (_acba );if _fgdg !=nil {_df .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fgdg );_df .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_fgdg ;};defer _ebdd .Close ();var _cdgb _cbd .Buffer ;_cdgb .ReadFrom (_ebdd );return _cdgb .Bytes (),nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fffd *PdfParser )GetXrefType ()*xrefType {return _fffd ._eccf };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};var _fdea =_a .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_beeb *_cg .Document ;

// Globals are the JBIG2 global segments.
Globals _ef .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_fbbc :=&PdfCrypt {_eae :false ,_agd :make (map[PdfObject ]bool ),_be :make (map[PdfObject ]bool ),_beb :make (map[int ]struct{}),_acb :parser };_dadg ,_ggbf :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_ggbf {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _fbbc ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_dadg !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_df .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_dadg );return _fbbc ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_fbbc ._fef .Filter =string (*_dadg );if _gcd ,_gbd :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_gbd {_fbbc ._fef .SubFilter =_gcd .Str ();_df .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gcd );};if L ,_fcg :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fcg {if (*L %8)!=0{_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _fbbc ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_fbbc ._fef .Length =int (*L );}else {_fbbc ._fef .Length =40;};_fbbc ._fef .V =0;if _def ,_cbbb :=ed .Get ("\u0056").(*PdfObjectInteger );_cbbb {V :=int (*_def );_fbbc ._fef .V =V ;if V >=1&&V <=2{_fbbc ._gfgf =_ebed (_fbbc ._fef .Length );}else if V >=4&&V <=5{if _gceg :=_fbbc .loadCryptFilters (ed );_gceg !=nil {return _fbbc ,_gceg ;};}else {_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _fbbc ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _gec :=_dde (&_fbbc ._fae ,ed );_gec !=nil {return _fbbc ,_gec ;};_fgfg :="";if _bfc ,_cbe :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_cbe &&_bfc .Len ()>=1{_fccd ,_ccb :=GetString (_bfc .Get (0));if !_ccb {return _fbbc ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_fgfg =_fccd .Str ();}else {_df .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_fbbc ._bda =_fgfg ;return _fbbc ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bcbdf *PdfObjectDictionary )WriteString ()string {var _aabcg _gc .Builder ;_aabcg .WriteString ("\u003c\u003c");for _ ,_ceda :=range _bcbdf ._fdaf {_dgadd :=_bcbdf ._ccfc [_ceda ];_aabcg .WriteString (_ceda .WriteString ());_aabcg .WriteString ("\u0020");_aabcg .WriteString (_dgadd .WriteString ());};_aabcg .WriteString ("\u003e\u003e");return _aabcg .String ();};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bgafa *PdfObjectString ,_gdca bool ){_bgafa ,_gdca =TraceToDirectObject (obj ).(*PdfObjectString );return _bgafa ,_gdca ;};func (_gbcgb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_b .SeekStart {offset +=_gbcgb ._gdbdf ;};_defe ,_bdd :=_gbcgb ._ebbd .Seek (offset ,whence );if _bdd !=nil {return _defe ,_bdd ;};if whence ==_b .SeekCurrent {_defe -=_gbcgb ._gdbdf ;};if _defe < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _defe ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_bbbc *PdfObjectStreams )Elements ()[]PdfObject {if _bbbc ==nil {return nil ;};return _bbbc ._fafd ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_fbaa []StreamEncoder };func (_bed *PdfCrypt )authenticate (_add []byte )(bool ,error ){_bed ._eae =false ;_ece :=_bed .securityHandler ();_eed ,_ggf ,_gcb :=_ece .Authenticate (&_bed ._fae ,_add );if _gcb !=nil {return false ,_gcb ;}else if _ggf ==0||len (_eed )==0{return false ,nil ;};_bed ._eae =true ;_bed ._acf =_eed ;return true ,nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_gdcb string ,_cafg bool ){_efeba ,_cafg :=TraceToDirectObject (obj ).(*PdfObjectName );if _cafg {return string (*_efeba ),true ;};return ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_efb *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_df .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_df .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_efb .Predictor );_febe ,_dcba :=_efb .DecodeBytes (streamObj .Stream );if _dcba !=nil {return nil ,_dcba ;};_df .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_df .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_febe ),_febe );if _efb .Predictor > 1{if _efb .Predictor ==2{_df .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cgd :=int (_efb .Columns )*_efb .Colors ;if _cgd < 1{return []byte {},nil ;};_ccgf :=len (_febe )/_cgd ;if len (_febe )%_cgd !=0{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_febe ),_cgd );};if _cgd %_efb .Colors !=0{return nil ,_afb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cgd ,_efb .Colors );};if _cgd > len (_febe ){_df .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cgd ,len (_febe ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_df .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_febe ),_febe );_fee :=_cbd .NewBuffer (nil );for _dac :=0;_dac < _ccgf ;_dac ++{_ffd :=_febe [_cgd *_dac :_cgd *(_dac +1)];for _fggc :=_efb .Colors ;_fggc < _cgd ;_fggc ++{_ffd [_fggc ]=byte (int (_ffd [_fggc ]+_ffd [_fggc -_efb .Colors ])%256);};_fee .Write (_ffd );};_abge :=_fee .Bytes ();_df .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_abge ),_abge );return _abge ,nil ;}else if _efb .Predictor >=10&&_efb .Predictor <=15{_df .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eggb :=int (_efb .Columns *_efb .Colors +1);if _eggb < 1{return []byte {},nil ;};_agac :=len (_febe )/_eggb ;if len (_febe )%_eggb !=0{return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_febe ),_eggb );};if _eggb > len (_febe ){_df .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eggb ,len (_febe ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ccee :=_cbd .NewBuffer (nil );_df .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_efb .Columns );_df .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_febe ),_eggb ,_agac );_cee :=make ([]byte ,_eggb );for _gfcd :=0;_gfcd < _eggb ;_gfcd ++{_cee [_gfcd ]=0;};for _baeb :=0;_baeb < _agac ;_baeb ++{_geg :=_febe [_eggb *_baeb :_eggb *(_baeb +1)];_cbed :=_geg [0];switch _cbed {case 0:case 1:for _bcdc :=2;_bcdc < _eggb ;_bcdc ++{_geg [_bcdc ]=byte (int (_geg [_bcdc ]+_geg [_bcdc -1])%256);};case 2:for _afcg :=1;_afcg < _eggb ;_afcg ++{_geg [_afcg ]=byte (int (_geg [_afcg ]+_cee [_afcg ])%256);};default:_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cbed );return nil ,_afb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cbed );};for _dbgc :=0;_dbgc < _eggb ;_dbgc ++{_cee [_dbgc ]=_geg [_dbgc ];};_ccee .Write (_geg [1:]);};_badf :=_ccee .Bytes ();return _badf ,nil ;}else {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_efb .Predictor );return nil ,_afb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_efb .Predictor );};};return _febe ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_fbbgg *PdfObjectName ,_gddbd bool ){_fbbgg ,_gddbd =TraceToDirectObject (obj ).(*PdfObjectName );return _fbbgg ,_gddbd ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_badg *PdfIndirectObject ,_beda bool ){obj =ResolveReference (obj );_badg ,_beda =obj .(*PdfIndirectObject );return _badg ,_beda ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_acab *JBIG2Encoder )Encode ()(_dfe []byte ,_ccfdce error ){const _agfd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _acab ._beeb ==nil {return nil ,_ff .Errorf (_agfd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_acab ._beeb .FullHeaders =_acab .DefaultPageSettings .FileMode ;_dfe ,_ccfdce =_acab ._beeb .Encode ();if _ccfdce !=nil {return nil ,_ff .Wrap (_ccfdce ,_agfd ,"");};return _dfe ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_gfb *MultiEncoder )GetFilterName ()string {_ggea :="";for _bedf ,_ccaf :=range _gfb ._fbaa {_ggea +=_ccaf .GetFilterName ();if _bedf < len (_gfb ._fbaa )-1{_ggea +="\u0020";};};return _ggea ;};func (_fgg *PdfCrypt )loadCryptFilters (_fbc *PdfObjectDictionary )error {_fgg ._gfgf =cryptFilters {};_gga :=_fbc .Get ("\u0043\u0046");_gga =TraceToDirectObject (_gga );if _fgf ,_gdb :=_gga .(*PdfObjectReference );_gdb {_bbe ,_fefc :=_fgg ._acb .LookupByReference (*_fgf );if _fefc !=nil {_df .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _fefc ;};_gga =TraceToDirectObject (_bbe );};_cfdga ,_bgf :=_gga .(*PdfObjectDictionary );if !_bgf {_df .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_gga );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_gbf :=range _cfdga .Keys (){_deeg :=_cfdga .Get (_gbf );if _ceg ,_ebee :=_deeg .(*PdfObjectReference );_ebee {_ebc ,_daa :=_fgg ._acb .LookupByReference (*_ceg );if _daa !=nil {_df .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _daa ;};_deeg =TraceToDirectObject (_ebc );};_ddde ,_eca :=_deeg .(*PdfObjectDictionary );if !_eca {return _afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_gbf ,_deeg );};if _gbf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _ccf _fea .FilterDict ;if _deb :=_bcb (&_ccf ,_ddde );_deb !=nil {return _deb ;};_decg ,_fbb :=_fea .NewFilter (_ccf );if _fbb !=nil {return _fbb ;};_fgg ._gfgf [string (_gbf )]=_decg ;};_fgg ._gfgf ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_fea .NewIdentity ();_fgg ._gdg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fba ,_ddc :=_fbc .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ddc {if _ ,_ged :=_fgg ._gfgf [string (*_fba )];!_ged {return _afb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fba );};_fgg ._gdg =string (*_fba );};_fgg ._abc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _faeg ,_dbb :=_fbc .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_dbb {if _ ,_acbc :=_fgg ._gfgf [string (*_faeg )];!_acbc {return _afb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_faeg );};_fgg ._abc =string (*_faeg );};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bcdg *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func _ddaa (_dfgc PdfObject )(*float64 ,error ){switch _gdedc :=_dfgc .(type ){case *PdfObjectFloat :_beae :=float64 (*_gdedc );return &_beae ,nil ;case *PdfObjectInteger :_ffgde :=float64 (*_gdedc );return &_ffgde ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _bc .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _feab ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ff .Error (_feab ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_acde uint8 ;_agea _gf .Image ;_ebad error ;);if bwThreshold ==JB2ImageAutoThreshold {_agea ,_ebad =_gf .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ff .Error (_feab ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_acde =uint8 (255*bwThreshold );_agea ,_ebad =_gf .MonochromeThresholdConverter (_acde ).Convert (i );};if _ebad !=nil {return nil ,_ebad ;};return _beee (_agea ),nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_bdbbe *PdfObjectInteger ,_fgbe bool ){_bdbbe ,_fgbe =TraceToDirectObject (obj ).(*PdfObjectInteger );return _bdbbe ,_fgbe ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_dcgbf *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcgbf .DecodeBytes (streamObj .Stream );};func (_fbagf *PdfParser )parseName ()(PdfObjectName ,error ){var _deeaf _cbd .Buffer ;_fcga :=false ;for {_cgfb ,_dfad :=_fbagf ._adedf .Peek (1);if _dfad ==_b .EOF {break ;};if _dfad !=nil {return PdfObjectName (_deeaf .String ()),_dfad ;};if !_fcga {if _cgfb [0]=='/'{_fcga =true ;_fbagf ._adedf .ReadByte ();}else if _cgfb [0]=='%'{_fbagf .readComment ();_fbagf .skipSpaces ();}else {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cgfb ,_cgfb );return PdfObjectName (_deeaf .String ()),_afb .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cgfb [0]);};}else {if IsWhiteSpace (_cgfb [0]){break ;}else if (_cgfb [0]=='/')||(_cgfb [0]=='[')||(_cgfb [0]=='(')||(_cgfb [0]==']')||(_cgfb [0]=='<')||(_cgfb [0]=='>'){break ;}else if _cgfb [0]=='#'{_dccd ,_efbc :=_fbagf ._adedf .Peek (3);if _efbc !=nil {return PdfObjectName (_deeaf .String ()),_efbc ;};_aaa ,_efbc :=_ae .DecodeString (string (_dccd [1:3]));if _efbc !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_deeaf .WriteByte ('#');_fbagf ._adedf .Discard (1);continue ;};_fbagf ._adedf .Discard (3);_deeaf .Write (_aaa );}else {_cfbg ,_ :=_fbagf ._adedf .ReadByte ();_deeaf .WriteByte (_cfbg );};};};return PdfObjectName (_deeaf .String ()),nil ;};

// String returns a descriptive information string about the encryption method used.
func (_cce *PdfCrypt )String ()string {if _cce ==nil {return "";};_fead :=_cce ._fef .Filter +"\u0020\u002d\u0020";if _cce ._fef .V ==0{_fead +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _cce ._fef .V ==1{_fead +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _cce ._fef .V ==2{_fead +=_afb .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_cce ._fef .Length );}else if _cce ._fef .V ==3{_fead +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _cce ._fef .V >=4{_fead +=_afb .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_cce ._abc ,_cce ._gdg );_fead +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _bbg ,_fdd :=range _cce ._gfgf {_fead +=_afb .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_bbg ,_fdd .Name (),_fdd .KeyLength ());};};_cca :=_cce .GetAccessPermissions ();_fead +=_afb .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cca );return _fead ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cbeg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_df .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_df .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cbeg .Predictor );if _cbeg .BitsPerComponent !=8{return nil ,_afb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cbeg .BitsPerComponent );};_bbaf ,_bfdf :=_cbeg .DecodeBytes (streamObj .Stream );if _bfdf !=nil {return nil ,_bfdf ;};_bbaf ,_bfdf =_cbeg .postDecodePredict (_bbaf );if _bfdf !=nil {return nil ,_bfdf ;};return _cbeg .cleanImageData (_bbaf );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_eafd :=&DCTEncoder {};_eafd .ColorComponents =3;_eafd .BitsPerComponent =8;_eafd .Quality =DefaultJPEGQuality ;return _eafd ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgadg *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _gbgd []int64 ;for _ ,_fbgc :=range _bgadg .Elements (){if _agcb ,_cdec :=_fbgc .(*PdfObjectInteger );_cdec {_gbgd =append (_gbgd ,int64 (*_agcb ));}else {return nil ,ErrTypeError ;};};return _gbgd ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_dgga *PdfObjectString )String ()string {return _dgga ._ggbb };func (_eedgd *JBIG2Encoder )encodeImage (_cecc _bc .Image )([]byte ,error ){const _fcgg ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_fad ,_geed :=GoImageToJBIG2 (_cecc ,JB2ImageAutoThreshold );if _geed !=nil {return nil ,_ff .Wrap (_geed ,_fcgg ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _geed =_eedgd .AddPageImage (_fad ,&_eedgd .DefaultPageSettings );_geed !=nil {return nil ,_ff .Wrap (_geed ,_fcgg ,"");};return _eedgd .Encode ();};var _cegb =_a .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// Clear resets the dictionary to an empty state.
func (_aaced *PdfObjectDictionary )Clear (){_aaced ._fdaf =[]PdfObjectName {};_aaced ._ccfc =map[PdfObjectName ]PdfObject {};};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _ffge (obj1 ,obj2 ,0)};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_cddc *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ebfc :=data ;var _bgd error ;for _fbcd :=len (_cddc ._fbaa )-1;_fbcd >=0;_fbcd --{_aggd :=_cddc ._fbaa [_fbcd ];_ebfc ,_bgd =_aggd .EncodeBytes (_ebfc );if _bgd !=nil {return nil ,_bgd ;};};return _ebfc ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_afde *PdfObjectStream ,_cbea bool ){obj =ResolveReference (obj );_afde ,_cbea =obj .(*PdfObjectStream );return _afde ,_cbea ;};func (_dcbf *offsetReader )Read (p []byte )(_afec int ,_bgbg error ){return _dcbf ._ebbd .Read (p )};func (_gfbg *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_gfbg ._ebbc .ObjectMap =make (map[int ]XrefObject );_gfbg ._bddd =make (objectStreams );_cddd ,_cgcg :=_gfbg ._fcfg .Seek (0,_b .SeekEnd );if _cgcg !=nil {return nil ,_cgcg ;};_df .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_cddd );_gfbg ._egbc =_cddd ;_cgcg =_gfbg .seekToEOFMarker (_cddd );if _cgcg !=nil {_df .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_cgcg );return nil ,_cgcg ;};_fggcd ,_cgcg :=_gfbg ._fcfg .Seek (0,_b .SeekCurrent );if _cgcg !=nil {return nil ,_cgcg ;};var _cbg int64 =64;_bgfb :=_fggcd -_cbg ;if _bgfb < 0{_bgfb =0;};_ ,_cgcg =_gfbg ._fcfg .Seek (_bgfb ,_b .SeekStart );if _cgcg !=nil {return nil ,_cgcg ;};_debd :=make ([]byte ,_cbg );_ ,_cgcg =_gfbg ._fcfg .Read (_debd );if _cgcg !=nil {_df .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_cgcg );return nil ,_cgcg ;};_bccg :=_adf .FindStringSubmatch (string (_debd ));if len (_bccg )< 2{_df .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_bccg )> 2{_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_debd );return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_fgcg ,_ :=_e .ParseInt (_bccg [1],10,64);_df .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_fgcg );if _fgcg > _cddd {_df .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_df .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_fgcg ,_cgcg =_gfbg .repairLocateXref ();if _cgcg !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_cgcg ;};};_gfbg ._fcfg .Seek (int64 (_fgcg ),_b .SeekStart );_gfbg ._adedf =_bdc .NewReader (_gfbg ._fcfg );_geec ,_cgcg :=_gfbg .parseXref ();if _cgcg !=nil {return nil ,_cgcg ;};_bdagg :=_geec .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _bdagg !=nil {_gacg ,_aeafe :=_bdagg .(*PdfObjectInteger );if !_aeafe {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_cgcg =_gfbg .parseXrefStream (_gacg );if _cgcg !=nil {return nil ,_cgcg ;};};var _bfac []int64 ;_bddb :=func (_bedfd int64 ,_afgf []int64 )bool {for _ ,_ecfd :=range _afgf {if _ecfd ==_bedfd {return true ;};};return false ;};_bdagg =_geec .Get ("\u0050\u0072\u0065\u0076");for _bdagg !=nil {_eeebd ,_geeb :=_bdagg .(*PdfObjectInteger );if !_geeb {_df .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_bdagg );return _geec ,nil ;};_bbaca :=*_eeebd ;_df .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bbaca );_gfbg ._fcfg .Seek (int64 (_bbaca ),_eb .SEEK_SET );_gfbg ._adedf =_bdc .NewReader (_gfbg ._fcfg );_ddadg ,_dbcf :=_gfbg .parseXref ();if _dbcf !=nil {_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_df .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_bdagg =_ddadg .Get ("\u0050\u0072\u0065\u0076");if _bdagg !=nil {_aacgf :=*(_bdagg .(*PdfObjectInteger ));if _bddb (int64 (_aacgf ),_bfac ){_df .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_bfac =append (_bfac ,int64 (_aacgf ));};};return _geec ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bdea *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_gfda :=MakeDict ();_gfda .Set ("\u004b",MakeInteger (int64 (_bdea .K )));_gfda .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bdea .Columns )));if _bdea .BlackIs1 {_gfda .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bdea .BlackIs1 ));};if _bdea .EncodedByteAlign {_gfda .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bdea .EncodedByteAlign ));};if _bdea .EndOfLine &&_bdea .K >=0{_gfda .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bdea .EndOfLine ));};if _bdea .Rows !=0&&!_bdea .EndOfBlock {_gfda .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bdea .Rows )));};if !_bdea .EndOfBlock {_gfda .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bdea .EndOfBlock ));};if _bdea .DamagedRowsBeforeError !=0{_gfda .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bdea .DamagedRowsBeforeError )));};return _gfda ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fdagd *MultiEncoder )GetFilterArray ()*PdfObjectArray {_egfc :=make ([]PdfObject ,len (_fdagd ._fbaa ));for _faegee ,_ecbg :=range _fdagd ._fbaa {_egfc [_faegee ]=MakeName (_ecbg .GetFilterName ());};return MakeArray (_egfc ...);};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_daag *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_agag :=_cbd .NewReader (data );var _bdag []byte ;var _cbdc []byte ;_bdgf ,_gba :=_agag .ReadByte ();if _gba ==_b .EOF {return []byte {},nil ;}else if _gba !=nil {return nil ,_gba ;};_badfg :=1;for {_ebeg ,_deca :=_agag .ReadByte ();if _deca ==_b .EOF {break ;}else if _deca !=nil {return nil ,_deca ;};if _ebeg ==_bdgf {if len (_cbdc )> 0{_cbdc =_cbdc [:len (_cbdc )-1];if len (_cbdc )> 0{_bdag =append (_bdag ,byte (len (_cbdc )-1));_bdag =append (_bdag ,_cbdc ...);};_badfg =1;_cbdc =[]byte {};};_badfg ++;if _badfg >=127{_bdag =append (_bdag ,byte (257-_badfg ),_bdgf );_badfg =0;};}else {if _badfg > 0{if _badfg ==1{_cbdc =[]byte {_bdgf };}else {_bdag =append (_bdag ,byte (257-_badfg ),_bdgf );};_badfg =0;};_cbdc =append (_cbdc ,_ebeg );if len (_cbdc )>=127{_bdag =append (_bdag ,byte (len (_cbdc )-1));_bdag =append (_bdag ,_cbdc ...);_cbdc =[]byte {};};};_bdgf =_ebeg ;};if len (_cbdc )> 0{_bdag =append (_bdag ,byte (len (_cbdc )-1));_bdag =append (_bdag ,_cbdc ...);}else if _badfg > 0{_bdag =append (_bdag ,byte (257-_badfg ),_bdgf );};_bdag =append (_bdag ,128);return _bdag ,nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_edea *PdfParser )Inspect ()(map[string ]int ,error ){return _edea .inspect ()};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cfb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };var _fgdgf =_a .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// Len returns the number of elements in the streams.
func (_cfgb *PdfObjectStreams )Len ()int {if _cfgb ==nil {return 0;};return len (_cfgb ._fafd );};const _dec ="\u0053\u0074\u0064C\u0046";

// String returns a string describing `ind`.
func (_dgfg *PdfIndirectObject )String ()string {return _afb .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_dgfg ).ObjectNumber );};func _fab (_ffg _fea .Filter ,_bdfd _eg .AuthEvent )*PdfObjectDictionary {if _bdfd ==""{_bdfd =_eg .EventDocOpen ;};_dffd :=MakeDict ();_dffd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_dffd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_bdfd )));_dffd .Set ("\u0043\u0046\u004d",MakeName (_ffg .Name ()));_dffd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ffg .KeyLength ())));return _dffd ;};

// WriteString outputs the object as it is to be written to file.
func (_afeg *PdfObjectString )WriteString ()string {var _dgfa _cbd .Buffer ;if _afeg ._gaab {_afa :=_ae .EncodeToString (_afeg .Bytes ());_dgfa .WriteString ("\u003c");_dgfa .WriteString (_afa );_dgfa .WriteString ("\u003e");return _dgfa .String ();};_acdgd :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dgfa .WriteString ("\u0028");for _aada :=0;_aada < len (_afeg ._ggbb );_aada ++{_feaac :=_afeg ._ggbb [_aada ];if _gcaff ,_cggd :=_acdgd [_feaac ];_cggd {_dgfa .WriteString (_gcaff );}else {_dgfa .WriteByte (_feaac );};};_dgfa .WriteString ("\u0029");return _dgfa .String ();};

// WriteString outputs the object as it is to be written to file.
func (_egca *PdfObjectName )WriteString ()string {var _bgggg _cbd .Buffer ;if len (*_egca )> 127{_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_egca );};_bgggg .WriteString ("\u002f");for _bcfg :=0;_bcfg < len (*_egca );_bcfg ++{_gfgbg :=(*_egca )[_bcfg ];if !IsPrintable (_gfgbg )||_gfgbg =='#'||IsDelimiter (_gfgbg ){_bgggg .WriteString (_afb .Sprintf ("\u0023\u0025\u002e2\u0078",_gfgbg ));}else {_bgggg .WriteByte (_gfgbg );};};return _bgggg .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_caa *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_aadc ,_geef :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _geef ==nil {_caa .Predictor =int (_aadc );};_beddge ,_geef :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _geef ==nil {_caa .BitsPerComponent =int (_beddge );};_fcaf ,_geef :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _geef ==nil {_caa .Columns =int (_fcaf );};_befg ,_geef :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _geef ==nil {_caa .Colors =int (_befg );};_edbf ,_geef :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _geef ==nil {_caa .EarlyChange =int (_edbf );};};func _dggc (_aggf *PdfObjectDictionary )(_gfeee *_gf .ImageBase ){var (_bgdc *PdfObjectInteger ;_eefd bool ;);if _bgdc ,_eefd =_aggf .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_eefd {_gfeee =&_gf .ImageBase {Width :int (*_bgdc )};}else {return nil ;};if _bgdc ,_eefd =_aggf .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_eefd {_gfeee .Height =int (*_bgdc );};if _bgdc ,_eefd =_aggf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_eefd {_gfeee .BitsPerComponent =int (*_bgdc );};if _bgdc ,_eefd =_aggf .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_eefd {_gfeee .ColorComponents =int (*_bgdc );};return _gfeee ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_ccad string ,_ddadc bool ){_aagab ,_ddadc :=TraceToDirectObject (obj ).(*PdfObjectString );if _ddadc {return _aagab .Str (),true ;};return ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_dega :=MakeArray ();for _ ,_gcbbg :=range vals {_dega .Append (MakeInteger (int64 (_gcbbg )));};return _dega ;};func (_dece *PdfParser )parseString ()(*PdfObjectString ,error ){_dece ._adedf .ReadByte ();var _ccffb _cbd .Buffer ;_dadcf :=1;for {_cgfg ,_cedbd :=_dece ._adedf .Peek (1);if _cedbd !=nil {return MakeString (_ccffb .String ()),_cedbd ;};if _cgfg [0]=='\\'{_dece ._adedf .ReadByte ();_aadcf ,_ffcd :=_dece ._adedf .ReadByte ();if _ffcd !=nil {return MakeString (_ccffb .String ()),_ffcd ;};if IsOctalDigit (_aadcf ){_dabga ,_ddef :=_dece ._adedf .Peek (2);if _ddef !=nil {return MakeString (_ccffb .String ()),_ddef ;};var _badd []byte ;_badd =append (_badd ,_aadcf );for _ ,_adbf :=range _dabga {if IsOctalDigit (_adbf ){_badd =append (_badd ,_adbf );}else {break ;};};_dece ._adedf .Discard (len (_badd )-1);_df .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_badd );_fade ,_ddef :=_e .ParseUint (string (_badd ),8,32);if _ddef !=nil {return MakeString (_ccffb .String ()),_ddef ;};_ccffb .WriteByte (byte (_fade ));continue ;};switch _aadcf {case 'n':_ccffb .WriteRune ('\n');case 'r':_ccffb .WriteRune ('\r');case 't':_ccffb .WriteRune ('\t');case 'b':_ccffb .WriteRune ('\b');case 'f':_ccffb .WriteRune ('\f');case '(':_ccffb .WriteRune ('(');case ')':_ccffb .WriteRune (')');case '\\':_ccffb .WriteRune ('\\');};continue ;}else if _cgfg [0]=='('{_dadcf ++;}else if _cgfg [0]==')'{_dadcf --;if _dadcf ==0{_dece ._adedf .ReadByte ();break ;};};_gedf ,_ :=_dece ._adedf .ReadByte ();_ccffb .WriteByte (_gedf );};return MakeString (_ccffb .String ()),nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_ddaad *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _ddaad ._aged {return nil ,_afb .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_ddaad ._aged =true ;_ddaad ._fcfg .Seek (0,_eb .SEEK_SET );_ddaad ._adedf =_bdc .NewReader (_ddaad ._fcfg );_bfadf :=20;_cffcd :=make ([]byte ,_bfadf );_aabce :=XrefTable {};_aabce .ObjectMap =make (map[int ]XrefObject );for {_fcgcf ,_abbd :=_ddaad ._adedf .ReadByte ();if _abbd !=nil {if _abbd ==_b .EOF {break ;}else {return nil ,_abbd ;};};if _fcgcf =='j'&&_cffcd [_bfadf -1]=='b'&&_cffcd [_bfadf -2]=='o'&&IsWhiteSpace (_cffcd [_bfadf -3]){_bcecb :=_bfadf -4;for IsWhiteSpace (_cffcd [_bcecb ])&&_bcecb > 0{_bcecb --;};if _bcecb ==0||!IsDecimalDigit (_cffcd [_bcecb ]){continue ;};for IsDecimalDigit (_cffcd [_bcecb ])&&_bcecb > 0{_bcecb --;};if _bcecb ==0||!IsWhiteSpace (_cffcd [_bcecb ]){continue ;};for IsWhiteSpace (_cffcd [_bcecb ])&&_bcecb > 0{_bcecb --;};if _bcecb ==0||!IsDecimalDigit (_cffcd [_bcecb ]){continue ;};for IsDecimalDigit (_cffcd [_bcecb ])&&_bcecb > 0{_bcecb --;};if _bcecb ==0{continue ;};_efbb :=_ddaad .GetFileOffset ()-int64 (_bfadf -_bcecb );_cgfbd :=append (_cffcd [_bcecb +1:],_fcgcf );_gage ,_aegb ,_bgfbd :=_eaceb (string (_cgfbd ));if _bgfbd !=nil {_df .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_bgfbd );return nil ,_bgfbd ;};if _fcfa ,_bbef :=_aabce .ObjectMap [_gage ];!_bbef ||_fcfa .Generation < _aegb {_cfcc :=XrefObject {};_cfcc .XType =XrefTypeTableEntry ;_cfcc .ObjectNumber =int (_gage );_cfcc .Generation =int (_aegb );_cfcc .Offset =_efbb ;_aabce .ObjectMap [_gage ]=_cfcc ;};};_cffcd =append (_cffcd [1:_bfadf ],_fcgcf );};return &_aabce ,nil ;};func (_dede *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dede ._adedf .ReadByte ();var _aaca _cbd .Buffer ;for {_bded ,_cgb :=_dede ._adedf .Peek (1);if _cgb !=nil {return MakeString (""),_cgb ;};if _bded [0]=='>'{_dede ._adedf .ReadByte ();break ;};_gcea ,_ :=_dede ._adedf .ReadByte ();if !IsWhiteSpace (_gcea ){_aaca .WriteByte (_gcea );};};if _aaca .Len ()%2==1{_aaca .WriteRune ('0');};_cgbd ,_ :=_ae .DecodeString (_aaca .String ());return MakeHexString (string (_cgbd )),nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_ccc *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ddgg :=_cbd .NewReader (encoded );var _dadc []byte ;for {_acaa ,_ebfg :=_ddgg .ReadByte ();if _ebfg !=nil {return nil ,_ebfg ;};if _acaa =='>'{break ;};if IsWhiteSpace (_acaa ){continue ;};if (_acaa >='a'&&_acaa <='f')||(_acaa >='A'&&_acaa <='F')||(_acaa >='0'&&_acaa <='9'){_dadc =append (_dadc ,_acaa );}else {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_acaa );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_acaa );};};if len (_dadc )%2==1{_dadc =append (_dadc ,'0');};_df .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dadc );_cbc :=make ([]byte ,_ae .DecodedLen (len (_dadc )));_ ,_dcfg :=_ae .Decode (_cbc ,_dadc );if _dcfg !=nil {return nil ,_dcfg ;};return _cbc ,nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_df .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_eega ,_ffde :=NewEncoderFromStream (streamObj );if _ffde !=nil {_df .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ffde );return _ffde ;};if _dfga ,_gegfe :=_eega .(*LZWEncoder );_gegfe {_dfga .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_df .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_eega );_cdeca ,_ffde :=_eega .EncodeBytes (streamObj .Stream );if _ffde !=nil {_df .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ffde );return _ffde ;};streamObj .Stream =_cdeca ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cdeca ))));return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_caaf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ffgb *PdfCrypt )GetAccessPermissions ()_eg .Permissions {return _ffgb ._fae .P };func (_dccc *PdfParser )xrefNextObjectOffset (_ddga int64 )int64 {_dada :=int64 (0);if len (_dccc ._ebbc .ObjectMap )==0{return 0;};if len (_dccc ._ebbc ._dea )==0{_cfdf :=0;for _ ,_cffc :=range _dccc ._ebbc .ObjectMap {if _cffc .Offset > 0{_cfdf ++;};};if _cfdf ==0{return 0;};_dccc ._ebbc ._dea =make ([]XrefObject ,_cfdf );_cfab :=0;for _ ,_efaf :=range _dccc ._ebbc .ObjectMap {if _efaf .Offset > 0{_dccc ._ebbc ._dea [_cfab ]=_efaf ;_cfab ++;};};_g .Slice (_dccc ._ebbc ._dea ,func (_acff ,_fgedc int )bool {return _dccc ._ebbc ._dea [_acff ].Offset < _dccc ._ebbc ._dea [_fgedc ].Offset });};_afdda :=_g .Search (len (_dccc ._ebbc ._dea ),func (_adbb int )bool {return _dccc ._ebbc ._dea [_adbb ].Offset >=_ddga });if _afdda < len (_dccc ._ebbc ._dea ){_dada =_dccc ._ebbc ._dea [_afdda ].Offset ;};return _dada ;};func _bcb (_eaac *_fea .FilterDict ,_gce *PdfObjectDictionary )error {if _fede ,_dga :=_gce .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dga {if _bbd :=string (*_fede );_bbd !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_df .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bbd );};};_eab ,_eaf :=_gce .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_eaf {return _afb .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_eaac .CFM =string (*_eab );if _cfdg ,_ee :=_gce .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ee {_eaac .AuthEvent =_eg .AuthEvent (*_cfdg );}else {_eaac .AuthEvent =_eg .EventDocOpen ;};if _bdf ,_afbc :=_gce .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_afbc {_eaac .Length =int (*_bdf );};return nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gaade *PdfParser )GetObjectNums ()[]int {var _egccg []int ;for _ ,_dfbf :=range _gaade ._ebbc .ObjectMap {_egccg =append (_egccg ,_dfbf .ObjectNumber );};_g .Ints (_egccg );return _egccg ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _adbdc :=obj .(type ){case *PdfObjectFloat :return float64 (*_adbdc ),nil ;case *PdfObjectInteger :return float64 (*_adbdc ),nil ;};return 0,ErrNotANumber ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_agg *FlateEncoder )SetPredictor (columns int ){_agg .Predictor =11;_agg .Columns =columns };

// WriteString outputs the object as it is to be written to file.
func (_baca *PdfObjectInteger )WriteString ()string {return _e .FormatInt (int64 (*_baca ),10)};

// GetXrefTable returns the PDFs xref table.
func (_dgge *PdfParser )GetXrefTable ()XrefTable {return _dgge ._ebbc };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_aadf *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_acea ,_eaee :=_gf .NewImage (_aadf .Width ,_aadf .Height ,_aadf .BitsPerComponent ,_aadf .ColorComponents ,data ,nil ,nil );if _eaee !=nil {return nil ,_eaee ;};_gdga :=_bd .Options {};_gdga .Quality =_aadf .Quality ;var _fcb _cbd .Buffer ;if _eaee =_bd .Encode (&_fcb ,_acea ,&_gdga );_eaee !=nil {return nil ,_eaee ;};return _fcb .Bytes (),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_gdaa JBIG2EncoderSettings )Validate ()error {const _fbgaa ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _gdaa .Threshold < 0||_gdaa .Threshold > 1.0{return _ff .Errorf (_fbgaa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_gdaa .Threshold );};if _gdaa .ResolutionX < 0{return _ff .Errorf (_fbgaa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gdaa .ResolutionX );};if _gdaa .ResolutionY < 0{return _ff .Errorf (_fbgaa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gdaa .ResolutionY );};if _gdaa .DefaultPixelValue !=0&&_gdaa .DefaultPixelValue !=1{return _ff .Errorf (_fbgaa ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_gdaa .DefaultPixelValue );};if _gdaa .Compression !=JB2Generic {return _ff .Errorf (_fbgaa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_dgee :=MakeArray ();for _ ,_cgagc :=range vals {_dgee .Append (MakeFloat (_cgagc ));};return _dgee ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agga *FlateEncoder )MakeDecodeParams ()PdfObject {if _agga .Predictor > 1{_fgc :=MakeDict ();_fgc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_agga .Predictor )));if _agga .BitsPerComponent !=8{_fgc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_agga .BitsPerComponent )));};if _agga .Columns !=1{_fgc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_agga .Columns )));};if _agga .Colors !=1{_fgc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_agga .Colors )));};return _fgc ;};return nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gebge :=PdfObjectFloat (val );return &_gebge };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_df .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bbcg ,_bcfabb :=NewEncoderFromStream (streamObj );if _bcfabb !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bcfabb );return nil ,_bcfabb ;};_df .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_bbcg );_dfgd ,_bcfabb :=_bbcg .DecodeStream (streamObj );if _bcfabb !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bcfabb );return nil ,_bcfabb ;};return _dfgd ,nil ;};func _bfge (_agc *PdfObjectStream ,_bggf *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func (_bdfgb *PdfCrypt )isEncrypted (_bebb PdfObject )bool {_ ,_dgad :=_bdfgb ._be [_bebb ];if _dgad {_df .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_df .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// WriteString outputs the object as it is to be written to file.
func (_ebdgc *PdfObjectBool )WriteString ()string {if *_ebdgc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_cadb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_abff :=_cadb ._adedf .Discard (4);return PdfObjectNull {},_abff ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgcd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// UpdateParams updates the parameter values of the encoder.
func (_fdgb *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_feac ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecbb ==nil {_fdgb .ColorComponents =int (_feac );};_aef ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecbb ==nil {_fdgb .BitsPerComponent =int (_aef );};_bdga ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecbb ==nil {_fdgb .Width =int (_bdga );};_eedg ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ecbb ==nil {_fdgb .Height =int (_eedg );};_faefb ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _ecbb ==nil {_fdgb .Quality =int (_faefb );};};

// GetFilterName returns the name of the encoding filter.
func (_eggc *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_efg :=&LZWEncoder {};_efg .Predictor =1;_efg .BitsPerComponent =8;_efg .Colors =1;_efg .Columns =1;_efg .EarlyChange =1;return _efg ;};

// GetFilterName returns the name of the encoding filter.
func (_gcc *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetFilterName returns the name of the encoding filter.
func (_bead *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_aba *PdfCrypt )checkAccessRights (_abf []byte )(bool ,_eg .Permissions ,error ){_bfd :=_aba .securityHandler ();_bcf ,_gecb ,_ccg :=_bfd .Authenticate (&_aba ._fae ,_abf );if _ccg !=nil {return false ,0,_ccg ;}else if _gecb ==0||len (_bcf )==0{return false ,0,nil ;};return true ,_gecb ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_dggb *PdfObjectFloat ,_ecgc bool ){_dggb ,_ecgc =TraceToDirectObject (obj ).(*PdfObjectFloat );return _dggb ,_ecgc ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ccga *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bcg :=MakeDict ();_bcg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ccga .GetFilterName ()));_cdgc :=_ccga .MakeDecodeParams ();if _cdgc !=nil {_bcg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cdgc );};return _bcg ;};func (_efge *PdfParser )parsePdfVersion ()(int ,int ,error ){var _dbce int64 =20;_cfad :=make ([]byte ,_dbce );_efge ._fcfg .Seek (0,_eb .SEEK_SET );_efge ._fcfg .Read (_cfad );var _fgeb error ;var _dfca ,_ceca int ;if _cfaa :=_bfdg .FindStringSubmatch (string (_cfad ));len (_cfaa )< 3{if _dfca ,_ceca ,_fgeb =_efge .seekPdfVersionTopDown ();_fgeb !=nil {_df .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_fgeb ;};_efge ._fcfg ,_fgeb =_fabgg (_efge ._fcfg ,_efge .GetFileOffset ()-8);if _fgeb !=nil {return 0,0,_fgeb ;};}else {if _dfca ,_fgeb =_e .Atoi (_cfaa [1]);_fgeb !=nil {return 0,0,_fgeb ;};if _ceca ,_fgeb =_e .Atoi (_cfaa [2]);_fgeb !=nil {return 0,0,_fgeb ;};_efge .SetFileOffset (0);};_efge ._adedf =_bdc .NewReader (_efge ._fcfg );_df .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_dfca ,_ceca );return _dfca ,_ceca ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_da *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_bgb ,_ ,_feb :=_da .lookupByNumberWrapper (objNumber ,true );return _bgb ,_feb ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_afbbd *PdfObjectBool ,_ccce bool ){_afbbd ,_ccce =TraceToDirectObject (obj ).(*PdfObjectBool );return _afbbd ,_ccce ;};const _fbdb =32<<(^uint (0)>>63);func (_eceb *PdfParser )inspect ()(map[string ]int ,error ){_df .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_df .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_aedf :=map[string ]int {};_fgefb :=0;_dgabc :=0;var _faagd []int ;for _febab :=range _eceb ._ebbc .ObjectMap {_faagd =append (_faagd ,_febab );};_g .Ints (_faagd );_bdeg :=0;for _ ,_cdcc :=range _faagd {_fdee :=_eceb ._ebbc .ObjectMap [_cdcc ];if _fdee .ObjectNumber ==0{continue ;};_fgefb ++;_df .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_df .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_fdee .ObjectNumber );_cffcc ,_cdeg :=_eceb .LookupByNumber (_fdee .ObjectNumber );if _cdeg !=nil {_df .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_fdee .ObjectNumber ,_cdeg );_dgabc ++;continue ;};_df .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cffcc );_ggdaf ,_daeb :=_cffcc .(*PdfIndirectObject );if _daeb {_df .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_fdee .ObjectNumber ,_ggdaf );_ggdb ,_fgdf :=_ggdaf .PdfObject .(*PdfObjectDictionary );if _fgdf {if _ccbbb ,_afbad :=_ggdb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_afbad {_dgac :=string (*_ccbbb );_df .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_dgac );_ ,_gcgab :=_aedf [_dgac ];if _gcgab {_aedf [_dgac ]++;}else {_aedf [_dgac ]=1;};}else if _gacac ,_eaaa :=_ggdb .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_eaaa {_bggge :=string (*_gacac );_df .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_bggge );_ ,_bafdc :=_aedf [_bggge ];if _bafdc {_aedf [_bggge ]++;}else {_aedf [_bggge ]=1;};};if _gcge ,_cdbb :=_ggdb .Get ("\u0053").(*PdfObjectName );_cdbb &&*_gcge =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gfca :=_aedf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _gfca {_aedf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_aedf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _feeg ,_ddbd :=_cffcc .(*PdfObjectStream );_ddbd {if _bfbf ,_aefg :=_feeg .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aefg {_df .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_bfbf );_gebe :=string (*_bfbf );if _ ,_ceebd :=_aedf [_gebe ];_ceebd {_aedf [_gebe ]++;}else {_aedf [_gebe ]=1;};};}else {_cgac ,_fcfed :=_cffcc .(*PdfObjectDictionary );if _fcfed {_baag ,_fbdg :=_cgac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fbdg {_fbeb :=string (*_baag );_df .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fbeb );_aedf [_fbeb ]++;};};_df .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_fdee .ObjectNumber ,_cffcc );};_bdeg ++;};_df .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_df .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_df .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_fgefb );_df .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_dgabc );for _ggfg ,_ecdg :=range _aedf {_df .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_ggfg ,_ecdg );};_df .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_eceb ._ebbc .ObjectMap )< 1{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_afb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_ddaab ,_cggca :=_aedf ["\u0046\u006f\u006e\u0074"];if !_cggca ||_ddaab < 2{_df .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_df .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _aedf ,nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bacf :=MakeArray ();for _ ,_gbab :=range vals {_bacf .Append (MakeInteger (_gbab ));};return _bacf ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_bgef *PdfObjectDictionary ,_cecca bool ){_bgef ,_cecca =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _bgef ,_cecca ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddff *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func _fecf ()string {return _df .Version };

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};var _cbag =_a .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gfga :=&PdfObjectDictionary {};_gfga ._ccfc =map[PdfObjectName ]PdfObject {};_gfga ._fdaf =[]PdfObjectName {};return _gfga ;};func (_acfa *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_acfa ._adedf )};func _gegf (_ded int )int {_ffc :=_ded >>(_fbdb -1);return (_ded ^_ffc )-_ffc };func _gda (_fbga *PdfObjectStream )(*MultiEncoder ,error ){_fgead :=NewMultiEncoder ();_bbfc :=_fbga .PdfObjectDictionary ;if _bbfc ==nil {return _fgead ,nil ;};var _aaga *PdfObjectDictionary ;var _ecbf []PdfObject ;_faf :=_bbfc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _faf !=nil {_bbda ,_gecf :=_faf .(*PdfObjectDictionary );if _gecf {_aaga =_bbda ;};_ccfd ,_bfff :=_faf .(*PdfObjectArray );if _bfff {for _ ,_befe :=range _ccfd .Elements (){_befe =TraceToDirectObject (_befe );if _gddb ,_fbce :=_befe .(*PdfObjectDictionary );_fbce {_ecbf =append (_ecbf ,_gddb );}else {_ecbf =append (_ecbf ,MakeDict ());};};};};_faf =_bbfc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _faf ==nil {return nil ,_afb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_ddbc ,_cbee :=_faf .(*PdfObjectArray );if !_cbee {return nil ,_afb .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _ddeda ,_eea :=range _ddbc .Elements (){_gbcg ,_fgfe :=_eea .(*PdfObjectName );if !_fgfe {return nil ,_afb .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _fgaa PdfObject ;if _aaga !=nil {_fgaa =_aaga ;}else {if len (_ecbf )> 0{if _ddeda >=len (_ecbf ){return nil ,_afb .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_fgaa =_ecbf [_ddeda ];};};var _gfa *PdfObjectDictionary ;if _gegg ,_dcff :=_fgaa .(*PdfObjectDictionary );_dcff {_gfa =_gegg ;};_df .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gbcg ,_fgaa ,_gfa );if *_gbcg ==StreamEncodingFilterNameFlate {_faea ,_gdbe :=_bfeg (_fbga ,_gfa );if _gdbe !=nil {return nil ,_gdbe ;};_fgead .AddEncoder (_faea );}else if *_gbcg ==StreamEncodingFilterNameLZW {_gdef ,_aea :=_ecg (_fbga ,_gfa );if _aea !=nil {return nil ,_aea ;};_fgead .AddEncoder (_gdef );}else if *_gbcg ==StreamEncodingFilterNameASCIIHex {_efc :=NewASCIIHexEncoder ();_fgead .AddEncoder (_efc );}else if *_gbcg ==StreamEncodingFilterNameASCII85 {_dcec :=NewASCII85Encoder ();_fgead .AddEncoder (_dcec );}else if *_gbcg ==StreamEncodingFilterNameDCT {_fffe ,_aeaf :=_dadbe (_fbga ,_fgead );if _aeaf !=nil {return nil ,_aeaf ;};_fgead .AddEncoder (_fffe );_df .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_df .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_fgead );}else {_df .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gbcg );return nil ,_afb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _fgead ,nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_caeb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_bcbfc ,_bcbbc :=_caeb ._ccfc [key ];if !_bcbbc {return nil ;};return _bcbfc ;};const JB2ImageAutoThreshold =-1.0;

// PdfVersion returns version of the PDF file.
func (_bage *PdfParser )PdfVersion ()Version {return _bage ._gaad };

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_degd *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _degd .Predictor !=1{return nil ,_afb .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _degd .EarlyChange ==1{return nil ,_afb .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _gdd _cbd .Buffer ;_ccac :=_gg .NewWriter (&_gdd ,_gg .MSB ,8);_ccac .Write (data );_ccac .Close ();return _gdd .Bytes (),nil ;};func (_cdcbf *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _agdd =20;_aebg ,_ :=_cdcbf ._adedf .Peek (_agdd );for _fbcfa :=0;_fbcfa < 2;_fbcfa ++{if _cdcbf ._gfgfe ==0{_cdcbf ._gfgfe =_cdcbf .GetFileOffset ();};if _fdea .Match (_aebg ){_df .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_df .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_aebg ));return _cdcbf .parseXrefStream (nil );};if _dgd .Match (_aebg ){_df .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _cdcbf .parseXrefTable ();};_ccead :=_cdcbf .GetFileOffset ();if _cdcbf ._gfgfe ==0{_cdcbf ._gfgfe =_ccead ;};_cdcbf .SetFileOffset (_ccead -_agdd );defer _cdcbf .SetFileOffset (_ccead );_bafb ,_ :=_cdcbf ._adedf .Peek (_agdd );_aebg =append (_bafb ,_aebg ...);};_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _bcgd :=_cdcbf .repairSeekXrefMarker ();_bcgd !=nil {_df .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_bcgd );return nil ,_bcgd ;};return _cdcbf .parseXrefTable ();};func (_bbegf *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _gecfb *PdfObjectDictionary ;_edbg ,_gaga :=_bbegf .readTextLine ();if _gaga !=nil {return nil ,_gaga ;};_df .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_edbg );_eeab :=-1;_acaaf :=0;_cdag :=false ;_bbcbg :="";for {_bbegf .skipSpaces ();_ ,_bdfgg :=_bbegf ._adedf .Peek (1);if _bdfgg !=nil {return nil ,_bdfgg ;};_edbg ,_bdfgg =_bbegf .readTextLine ();if _bdfgg !=nil {return nil ,_bdfgg ;};_fegc :=_eafb .FindStringSubmatch (_edbg );if len (_fegc )==0{_eeef :=len (_bbcbg )> 0;_bbcbg +=_edbg +"\u000a";if _eeef {_fegc =_eafb .FindStringSubmatch (_bbcbg );};};if len (_fegc )==3{_egbf ,_ :=_e .Atoi (_fegc [1]);_bfba ,_ :=_e .Atoi (_fegc [2]);_eeab =_egbf ;_acaaf =_bfba ;_cdag =true ;_bbcbg ="";_df .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_eeab ,_acaaf );continue ;};_bgfce :=_gfec .FindStringSubmatch (_edbg );if len (_bgfce )==4{if _cdag ==false {_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_egdfb ,_ :=_e .ParseInt (_bgfce [1],10,64);_faba ,_ :=_e .Atoi (_bgfce [2]);_aafd :=_bgfce [3];_bbcbg ="";if _gc .ToLower (_aafd )=="\u006e"&&_egdfb > 1{_fbcc ,_gfee :=_bbegf ._ebbc .ObjectMap [_eeab ];if !_gfee ||_faba > _fbcc .Generation {_gbg :=XrefObject {ObjectNumber :_eeab ,XType :XrefTypeTableEntry ,Offset :_egdfb ,Generation :_faba };_bbegf ._ebbc .ObjectMap [_eeab ]=_gbg ;};};_eeab ++;continue ;};if (len (_edbg )> 6)&&(_edbg [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_df .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_edbg );if len (_edbg )> 9{_gcace :=_bbegf .GetFileOffset ();_bbegf .SetFileOffset (_gcace -int64 (len (_edbg ))+7);};_bbegf .skipSpaces ();_bbegf .skipComments ();_df .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_df .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_edbg );_gecfb ,_bdfgg =_bbegf .ParseDict ();_df .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bdfgg !=nil {_df .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bdfgg );return nil ,_bdfgg ;};break ;};if _edbg =="\u0025\u0025\u0045O\u0046"{_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_df .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_edbg );};_df .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bbegf ._eccf ==nil {_fffec :=XrefTypeTableEntry ;_bbegf ._eccf =&_fffec ;};return _gecfb ,nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_fadc *PdfObjectReference )Resolve ()PdfObject {if _fadc ._fgedb ==nil {return MakeNull ();};_egcdb ,_ ,_ggggd :=_fadc ._fgedb .resolveReference (_fadc );if _ggggd !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_ggggd );return MakeNull ();};if _egcdb ==nil {_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _egcdb ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_dcbg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcbg .DecodeBytes (streamObj .Stream );};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _fcgb (o ,0,traversed );};func (_gedc *PdfObjectInteger )String ()string {return _afb .Sprintf ("\u0025\u0064",*_gedc )};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_egbg Version )String ()string {return _afb .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_egbg .Major ,_egbg .Minor );};func (_ab *PdfParser )lookupByNumber (_cbdb int ,_bgg bool )(PdfObject ,bool ,error ){_gfg ,_dae :=_ab .ObjCache [_cbdb ];if _dae {_df .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cbdb );return _gfg ,false ,nil ;};_gfd ,_dae :=_ab ._ebbc .ObjectMap [_cbdb ];if !_dae {_df .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _cc PdfObjectNull ;return &_cc ,false ,nil ;};_df .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cbdb );if _gfd .XType ==XrefTypeTableEntry {_df .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_gfd .ObjectNumber );_df .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_gfd .Generation );_df .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_gfd .Offset );_ab ._fcfg .Seek (_gfd .Offset ,_eb .SEEK_SET );_ab ._adedf =_bdc .NewReader (_ab ._fcfg );_afg ,_fcc :=_ab .ParseIndirectObject ();if _fcc !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fcc );if _bgg {_df .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_cdb ,_afge :=_ab .repairRebuildXrefsTopDown ();if _afge !=nil {_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_afge );return nil ,false ,_afge ;};_ab ._ebbc =*_cdb ;return _ab .lookupByNumber (_cbdb ,false );};return nil ,false ,_fcc ;};if _bgg {_ec ,_ ,_ :=_efa (_afg );if int (_ec )!=_cbdb {_df .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_gee :=_ab .rebuildXrefTable ();if _gee !=nil {return nil ,false ,_gee ;};_ab .ObjCache =objectCache {};return _ab .lookupByNumberWrapper (_cbdb ,false );};};_df .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ab .ObjCache [_cbdb ]=_afg ;return _afg ,false ,nil ;}else if _gfd .XType ==XrefTypeObjectStream {_df .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_df .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_df .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_gfd .OsObjNumber ,_gfd .OsObjIndex );if _gfd .OsObjNumber ==_cbdb {_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_fdb :=_ab ._ebbc .ObjectMap [_gfd .OsObjNumber ];_fdb {_aa ,_edd :=_ab .lookupObjectViaOS (_gfd .OsObjNumber ,_cbdb );if _edd !=nil {_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_edd );return nil ,true ,_edd ;};_df .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ab .ObjCache [_cbdb ]=_aa ;if _ab ._bfdde !=nil {_ab ._bfdde ._agd [_aa ]=true ;};return _aa ,true ,nil ;};_df .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_aefa :=PdfObjectString {_ggbb :s ,_gaab :true };return &_aefa ;};func _aabg (_bcdbg PdfObject ,_dafd int )PdfObject {if _dafd > _bccga {_df .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bccga );return MakeNull ();};switch _ceba :=_bcdbg .(type ){case *PdfIndirectObject :_bcdbg =_aabg ((*_ceba ).PdfObject ,_dafd +1);case *PdfObjectArray :for _aaef ,_cgfgg :=range (*_ceba )._ddcb {(*_ceba )._ddcb [_aaef ]=_aabg (_cgfgg ,_dafd +1);};case *PdfObjectDictionary :for _agagc ,_abdc :=range (*_ceba )._ccfc {(*_ceba )._ccfc [_agagc ]=_aabg (_abdc ,_dafd +1);};_g .Slice ((*_ceba )._fdaf ,func (_adde ,_bggff int )bool {return (*_ceba )._fdaf [_adde ]< (*_ceba )._fdaf [_bggff ]});};return _bcdbg ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bga *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_adg ,_ffe :=obj .(*PdfObjectReference );if !_ffe {return obj ,nil ;};_bae :=_bga .GetFileOffset ();defer func (){_bga .SetFileOffset (_bae )}();_ddd ,_deg :=_bga .LookupByReference (*_adg );if _deg !=nil {return nil ,_deg ;};_ebe ,_aaf :=_ddd .(*PdfIndirectObject );if !_aaf {return _ddd ,nil ;};_ddd =_ebe .PdfObject ;_ ,_ffe =_ddd .(*PdfObjectReference );if _ffe {return _ebe ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ddd ,nil ;};func _acabf (_dgb *PdfObjectStream ,_ggaf *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ebeb ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_ffgdbf :=&JBIG2Encoder {};_cdcg :=_dgb .PdfObjectDictionary ;if _cdcg ==nil {return _ffgdbf ,nil ;};if _ggaf ==nil {_gffc :=_cdcg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gffc !=nil {switch _fegg :=_gffc .(type ){case *PdfObjectDictionary :_ggaf =_fegg ;case *PdfObjectArray :if _fegg .Len ()==1{if _gccccf ,_ggdag :=GetDict (_fegg .Get (0));_ggdag {_ggaf =_gccccf ;};};default:_df .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_gffc );return nil ,_ff .Errorf (_ebeb ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fegg );};};};if _ggaf ==nil {return _ffgdbf ,nil ;};_ffgdbf .UpdateParams (_ggaf );_bgggf :=_ggaf .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _bgggf ==nil {return _ffgdbf ,nil ;};var _fcecf error ;_ceea ,_cdbg :=_bgggf .(*PdfObjectStream );if !_cdbg {_fcecf =_ff .Error (_ebeb ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcecf );return nil ,_fcecf ;};_ffgdbf .Globals ,_fcecf =_ef .DecodeGlobals (_ceea .Stream );if _fcecf !=nil {_fcecf =_ff .Wrap (_fcecf ,_ebeb ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcecf );return nil ,_fcecf ;};return _ffgdbf ,nil ;};func _ecg (_cece *PdfObjectStream ,_daee *PdfObjectDictionary )(*LZWEncoder ,error ){_adab :=NewLZWEncoder ();_dbf :=_cece .PdfObjectDictionary ;if _dbf ==nil {return _adab ,nil ;};if _daee ==nil {_cag :=TraceToDirectObject (_dbf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cag !=nil {if _daf ,_bbac :=_cag .(*PdfObjectDictionary );_bbac {_daee =_daf ;}else if _faa ,_adbd :=_cag .(*PdfObjectArray );_adbd {if _faa .Len ()==1{if _decgd ,_eedc :=GetDict (_faa .Get (0));_eedc {_daee =_decgd ;};};};if _daee ==nil {_df .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cag );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_egaa :=_dbf .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _egaa !=nil {_aagb ,_dgef :=_egaa .(*PdfObjectInteger );if !_dgef {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_egaa );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_aagb !=0&&*_aagb !=1{return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_adab .EarlyChange =int (*_aagb );}else {_adab .EarlyChange =1;};if _daee ==nil {return _adab ,nil ;};_egaa =_daee .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _egaa !=nil {_abbc ,_ccd :=_egaa .(*PdfObjectInteger );if !_ccd {_df .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_egaa );return nil ,_afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_adab .Predictor =int (*_abbc );};_egaa =_daee .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _egaa !=nil {_gdc ,_fgfa :=_egaa .(*PdfObjectInteger );if !_fgfa {_df .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_afb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_adab .BitsPerComponent =int (*_gdc );};if _adab .Predictor > 1{_adab .Columns =1;_egaa =_daee .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _egaa !=nil {_ebb ,_ffeg :=_egaa .(*PdfObjectInteger );if !_ffeg {return nil ,_afb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_adab .Columns =int (*_ebb );};_adab .Colors =1;_egaa =_daee .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _egaa !=nil {_cdgcb ,_aff :=_egaa .(*PdfObjectInteger );if !_aff {return nil ,_afb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_adab .Colors =int (*_cdgcb );};};_df .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_daee .String ());return _adab ,nil ;};func _dde (_baed *_eg .StdEncryptDict ,_dfa *PdfObjectDictionary )error {R ,_ggb :=_dfa .Get ("\u0052").(*PdfObjectInteger );if !_ggb {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _afb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_baed .R =int (*R );O ,_ggb :=_dfa .GetString ("\u004f");if !_ggb {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _baed .R ==5||_baed .R ==6{if len (O )< 48{return _afb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _afb .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_baed .O =[]byte (O );U ,_ggb :=_dfa .GetString ("\u0055");if !_ggb {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _baed .R ==5||_baed .R ==6{if len (U )< 48{return _afb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_df .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_baed .U =[]byte (U );if _baed .R >=5{OE ,_bf :=_dfa .GetString ("\u004f\u0045");if !_bf {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _afb .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_baed .OE =[]byte (OE );UE ,_bf :=_dfa .GetString ("\u0055\u0045");if !_bf {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _afb .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_baed .UE =[]byte (UE );};P ,_ggb :=_dfa .Get ("\u0050").(*PdfObjectInteger );if !_ggb {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_baed .P =_eg .Permissions (*P );if _baed .R ==6{Perms ,_egf :=_dfa .GetString ("\u0050\u0065\u0072m\u0073");if !_egf {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _afb .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_baed .Perms =[]byte (Perms );};if _fcf ,_efdf :=_dfa .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_efdf {_baed .EncryptMetadata =bool (*_fcf );}else {_baed .EncryptMetadata =true ;};return nil ;};func _fga (_dee XrefTable ){_df .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_df .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_daec :=0;for _ ,_ebaa :=range _dee .ObjectMap {_df .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_daec +1,_ebaa .ObjectNumber ,_ebaa .Generation ,_ebaa .Offset );_daec ++;};};

// Clear resets the array to an empty state.
func (_gbfda *PdfObjectArray )Clear (){_gbfda ._ddcb =[]PdfObject {}};func _eaceb (_gaec string )(int ,int ,error ){_decec :=_fdea .FindStringSubmatch (_gaec );if len (_decec )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_gbga ,_ :=_e .Atoi (_decec [1]);_ebbcf ,_ :=_e .Atoi (_decec [2]);return _gbga ,_ebbcf ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_eecd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_gcad :=&PdfIndirectObject {};_gcad .PdfObject =obj ;return _gcad ;};

// UpdateParams updates the parameter values of the encoder.
func (_gded *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_dea []XrefObject ;};

// String returns a string describing `null`.
func (_bbcc *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_gfgc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_eccd ,_eedb :=_gfgc ._ccfc [key ].(*PdfObjectString );if !_eedb {return "",false ;};return _eccd .Str (),true ;};

// String returns a string representation of `name`.
func (_dfgb *PdfObjectName )String ()string {return string (*_dfgb )};type objectStream struct{N int ;_aed []byte ;_ag map[int ]int64 ;};

// WriteString outputs the object as it is to be written to file.
func (_gdac *PdfObjectReference )WriteString ()string {var _bfag _gc .Builder ;_bfag .WriteString (_e .FormatInt (_gdac .ObjectNumber ,10));_bfag .WriteString ("\u0020");_bfag .WriteString (_e .FormatInt (_gdac .GenerationNumber ,10));_bfag .WriteString ("\u0020\u0052");return _bfag .String ();};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_aggdb float64 ,_eadg bool ){_dgfcb ,_eadg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eadg {return float64 (*_dgfcb ),true ;};return 0,false ;};

// Remove removes an element specified by key.
func (_aaab *PdfObjectDictionary )Remove (key PdfObjectName ){_geded :=-1;for _gcf ,_fcfe :=range _aaab ._fdaf {if _fcfe ==key {_geded =_gcf ;break ;};};if _geded >=0{_aaab ._fdaf =append (_aaab ._fdaf [:_geded ],_aaab ._fdaf [_geded +1:]...);delete (_aaab ._ccfc ,key );};};

// LookupByReference looks up a PdfObject by a reference.
func (_afe *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_df .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _afe .LookupByNumber (int (ref .ObjectNumber ));};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_gaad Version ;_fcfg _b .ReadSeeker ;_adedf *_bdc .Reader ;_egbc int64 ;_ebbc XrefTable ;_gfgfe int64 ;_eccf *xrefType ;_bddd objectStreams ;_abab *PdfObjectDictionary ;_bfdde *PdfCrypt ;_aged bool ;ObjCache objectCache ;_bafg map[int64 ]bool ;};func _ebed (_bbb int )cryptFilters {return cryptFilters {_dec :_fea .NewFilterV2 (_bbb )}};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_fafd []PdfObject ;};func (_ebdc *PdfParser )rebuildXrefTable ()error {_fecee :=XrefTable {};_fecee .ObjectMap =map[int ]XrefObject {};for _fgcga ,_bbee :=range _ebdc ._ebbc .ObjectMap {_dgeg ,_ ,_dcbad :=_ebdc .lookupByNumberWrapper (_fgcga ,false );if _dcbad !=nil {_df .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_dcbad );_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_cecf ,_ababe :=_ebdc .repairRebuildXrefsTopDown ();if _ababe !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_ababe );return _ababe ;};_ebdc ._ebbc =*_cecf ;_df .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bcec ,_eaca ,_dcbad :=_efa (_dgeg );if _dcbad !=nil {return _dcbad ;};_bbee .ObjectNumber =int (_bcec );_bbee .Generation =int (_eaca );_fecee .ObjectMap [int (_bcec )]=_bbee ;};_ebdc ._ebbc =_fecee ;_df .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_fga (_ebdc ._ebbc );return nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_acec *PdfParser )Decrypt (password []byte )(bool ,error ){if _acec ._bfdde ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_afda ,_adef :=_acec ._bfdde .authenticate (password );if _adef !=nil {return false ,_adef ;};if !_afda {_afda ,_adef =_acec ._bfdde .authenticate ([]byte (""));};return _afda ,_adef ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bebe *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_fccc :=MakeDict ();_fccc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bebe .GetFilterName ()));return _fccc ;};func _beee (_ebfe _gf .Image )*JBIG2Image {_bfa :=_ebfe .Base ();return &JBIG2Image {Data :_bfa .Data ,Width :_bfa .Width ,Height :_bfa .Height ,HasPadding :true };};type objectCache map[int ]PdfObject ;type objectStreams map[int ]objectStream ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebgc *LZWEncoder )MakeDecodeParams ()PdfObject {if _ebgc .Predictor > 1{_fcadd :=MakeDict ();_fcadd .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ebgc .Predictor )));if _ebgc .BitsPerComponent !=8{_fcadd .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ebgc .BitsPerComponent )));};if _ebgc .Columns !=1{_fcadd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ebgc .Columns )));};if _ebgc .Colors !=1{_fcadd .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ebgc .Colors )));};return _fcadd ;};return nil ;};var _bbed =_a .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_bfadc *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _degcd :=val .(type ){case *PdfObjectName :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectDictionary :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectStream :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectString :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectNull :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectInteger :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectArray :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectBool :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectFloat :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfObjectReference :if _degcd !=nil {_bfadc .Set (key ,val );};case *PdfIndirectObject :if _degcd !=nil {_bfadc .Set (key ,val );};default:_df .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// UpdateParams updates the parameter values of the encoder.
func (_efgc *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _feaca ,_gcde :=GetNumberAsInt64 (params .Get ("\u004b"));_gcde ==nil {_efgc .K =int (_feaca );};if _agdb ,_fgab :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_fgab ==nil {_efgc .Columns =int (_agdb );}else if _agdb ,_fgab =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_fgab ==nil {_efgc .Columns =int (_agdb );};if _dacb ,_egbb :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_egbb ==nil {_efgc .BlackIs1 =_dacb > 0;}else {if _ddfe ,_ccea :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ccea {_efgc .BlackIs1 =_ddfe ;}else {if _gggg ,_fcde :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fcde {_dbde ,_bfea :=_gggg .ToIntegerArray ();if _bfea ==nil {_efgc .BlackIs1 =_dbde [0]==1&&_dbde [1]==0;};};};};if _gae ,_cceeg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cceeg ==nil {_efgc .EncodedByteAlign =_gae > 0;}else {if _cbeb ,_gbae :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gbae {_efgc .EncodedByteAlign =_cbeb ;};};if _fcge ,_ceef :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ceef ==nil {_efgc .EndOfLine =_fcge > 0;}else {if _cdda ,_bafd :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bafd {_efgc .EndOfLine =_cdda ;};};if _agbd ,_bbbe :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_bbbe ==nil {_efgc .Rows =int (_agbd );}else if _agbd ,_bbbe =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bbbe ==nil {_efgc .Rows =int (_agbd );};if _ffb ,_eeeb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_eeeb ==nil {_efgc .EndOfBlock =_ffb > 0;}else {if _adbe ,_gfgb :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gfgb {_efgc .EndOfBlock =_adbe ;};};if _agf ,_beag :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_beag !=nil {_efgc .DamagedRowsBeforeError =int (_agf );};};

// WriteString outputs the object as it is to be written to file.
func (_aeeb *PdfObjectStreams )WriteString ()string {var _gddec _gc .Builder ;_gddec .WriteString (_e .FormatInt (_aeeb .ObjectNumber ,10));_gddec .WriteString ("\u0020\u0030\u0020\u0052");return _gddec .String ();};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gcac *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_fbeg *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fbeg .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _adee :=obj .(type ){case *PdfObjectFloat :_df .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_adee ),nil ;case *PdfObjectInteger :return int64 (*_adee ),nil ;};return 0,ErrNotANumber ;};

// WriteString outputs the object as it is to be written to file.
func (_dagae *PdfObjectStream )WriteString ()string {var _dgfaa _gc .Builder ;_dgfaa .WriteString (_e .FormatInt (_dagae .ObjectNumber ,10));_dgfaa .WriteString ("\u0020\u0030\u0020\u0052");return _dgfaa .String ();};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_efedg *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _efedg .Predictor !=1&&_efedg .Predictor !=11{_df .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _efedg .Predictor ==11{_ccae :=int (_efedg .Columns );_badb :=len (data )/_ccae ;if len (data )%_ccae !=0{_df .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cdd :=_cbd .NewBuffer (nil );_bca :=make ([]byte ,_ccae );for _bffd :=0;_bffd < _badb ;_bffd ++{_fgfb :=data [_ccae *_bffd :_ccae *(_bffd +1)];_bca [0]=_fgfb [0];for _adag :=1;_adag < _ccae ;_adag ++{_bca [_adag ]=byte (int (_fgfb [_adag ]-_fgfb [_adag -1])%256);};_cdd .WriteByte (1);_cdd .Write (_bca );};data =_cdd .Bytes ();};var _fdac _cbd .Buffer ;_ecee :=_af .NewWriter (&_fdac );_ecee .Write (data );_ecee .Close ();return _fdac .Bytes (),nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_ddad *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _bgdf ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _ddad .ColorComponents !=1||_ddad .BitsPerComponent !=1{return nil ,_ff .Errorf (_bgdf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_gfcde *_fe .Bitmap ;_bfcg error ;);_agdcf :=(_ddad .Width *_ddad .Height )==len (data );if _agdcf {_gfcde ,_bfcg =_fe .NewWithUnpaddedData (_ddad .Width ,_ddad .Height ,data );}else {_gfcde ,_bfcg =_fe .NewWithData (_ddad .Width ,_ddad .Height ,data );};if _bfcg !=nil {return nil ,_bfcg ;};_bfcea :=_ddad .DefaultPageSettings ;if _bfcg =_bfcea .Validate ();_bfcg !=nil {return nil ,_ff .Wrap (_bfcg ,_bgdf ,"");};switch _bfcea .Compression {case JB2Generic :if _bfcg =_ddad ._beeb .AddGenericPage (_gfcde ,_bfcea .DuplicatedLinesRemoval );_bfcg !=nil {return nil ,_ff .Wrap (_bfcg ,_bgdf ,"");};case JB2SymbolCorrelation :return nil ,_ff .Error (_bgdf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_ff .Error (_bgdf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_ff .Error (_bgdf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _ddad .Encode ();};

// DecodeStream implements ASCII85 stream decoding.
func (_fdf *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fdf .DecodeBytes (streamObj .Stream );};func (_aegf *PdfParser )parseObject ()(PdfObject ,error ){_df .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_aegf .skipSpaces ();for {_cgge ,_beeec :=_aegf ._adedf .Peek (2);if _beeec !=nil {if _beeec !=_b .EOF ||len (_cgge )==0{return nil ,_beeec ;};if len (_cgge )==1{_cgge =append (_cgge ,' ');};};_df .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cgge ));if _cgge [0]=='/'{_aceb ,_aeab :=_aegf .parseName ();_df .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_aceb );return &_aceb ,_aeab ;}else if _cgge [0]=='('{_df .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_dbcd ,_cfbc :=_aegf .parseString ();return _dbcd ,_cfbc ;}else if _cgge [0]=='['{_df .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_gbdf ,_bbec :=_aegf .parseArray ();return _gbdf ,_bbec ;}else if (_cgge [0]=='<')&&(_cgge [1]=='<'){_df .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_gada ,_adagf :=_aegf .ParseDict ();return _gada ,_adagf ;}else if _cgge [0]=='<'{_df .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_fccb ,_gfcf :=_aegf .parseHexString ();return _fccb ,_gfcf ;}else if _cgge [0]=='%'{_aegf .readComment ();_aegf .skipSpaces ();}else {_df .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cgge ,_ =_aegf ._adedf .Peek (15);_bdgaa :=string (_cgge );_df .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_bdgaa );if (len (_bdgaa )> 3)&&(_bdgaa [:4]=="\u006e\u0075\u006c\u006c"){_fcca ,_adgc :=_aegf .parseNull ();return &_fcca ,_adgc ;}else if (len (_bdgaa )> 4)&&(_bdgaa [:5]=="\u0066\u0061\u006cs\u0065"){_addf ,_ffaa :=_aegf .parseBool ();return &_addf ,_ffaa ;}else if (len (_bdgaa )> 3)&&(_bdgaa [:4]=="\u0074\u0072\u0075\u0065"){_agfg ,_cede :=_aegf .parseBool ();return &_agfg ,_cede ;};_agfge :=_fgdgf .FindStringSubmatch (string (_bdgaa ));if len (_agfge )> 1{_cgge ,_ =_aegf ._adedf .ReadBytes ('R');_df .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cgge [:]));_acbf ,_gcbca :=_ggfe (string (_cgge ));_acbf ._fgedb =_aegf ;return &_acbf ,_gcbca ;};_bbdf :=_cegb .FindStringSubmatch (string (_bdgaa ));if len (_bbdf )> 1{_df .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_fcbd ,_faga :=_aegf .parseNumber ();return _fcbd ,_faga ;};_bbdf =_eeee .FindStringSubmatch (string (_bdgaa ));if len (_bbdf )> 1{_df .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_df .Log .Trace ("\u0025\u0020\u0073",_bbdf );_ecefe ,_dgfb :=_aegf .parseNumber ();return _ecefe ,_dgfb ;};_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_bdgaa );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_cb .Model ;Bounds ()_bc .Rectangle ;At (_ebf ,_feec int )_cb .Color ;Set (_baac ,_bbgf int ,_ffgdb _cb .Color );};

// String returns a string describing `streams`.
func (_cebf *PdfObjectStreams )String ()string {return _afb .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_cebf .ObjectNumber );};func _cfd (_fff *_eg .StdEncryptDict ,_bec *PdfObjectDictionary ){_bec .Set ("\u0052",MakeInteger (int64 (_fff .R )));_bec .Set ("\u0050",MakeInteger (int64 (_fff .P )));_bec .Set ("\u004f",MakeStringFromBytes (_fff .O ));_bec .Set ("\u0055",MakeStringFromBytes (_fff .U ));if _fff .R >=5{_bec .Set ("\u004f\u0045",MakeStringFromBytes (_fff .OE ));_bec .Set ("\u0055\u0045",MakeStringFromBytes (_fff .UE ));_bec .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_fff .EncryptMetadata ));if _fff .R > 5{_bec .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_fff .Perms ));};};};func _ffge (_cgab ,_bgcaf PdfObject ,_cfed int )bool {if _cfed > _bccga {_df .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bccga );return false ;};if _cgab ==nil &&_bgcaf ==nil {return true ;}else if _cgab ==nil ||_bgcaf ==nil {return false ;};if _c .TypeOf (_cgab )!=_c .TypeOf (_bgcaf ){return false ;};switch _abea :=_cgab .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_abea ==*(_bgcaf .(*PdfObjectName ));case *PdfObjectString :return *_abea ==*(_bgcaf .(*PdfObjectString ));case *PdfObjectInteger :return *_abea ==*(_bgcaf .(*PdfObjectInteger ));case *PdfObjectBool :return *_abea ==*(_bgcaf .(*PdfObjectBool ));case *PdfObjectFloat :return *_abea ==*(_bgcaf .(*PdfObjectFloat ));case *PdfIndirectObject :return _ffge (TraceToDirectObject (_cgab ),TraceToDirectObject (_bgcaf ),_cfed +1);case *PdfObjectArray :_cbgc :=_bgcaf .(*PdfObjectArray );if len ((*_abea )._ddcb )!=len ((*_cbgc )._ddcb ){return false ;};for _ebea ,_ffab :=range (*_abea )._ddcb {if !_ffge (_ffab ,(*_cbgc )._ddcb [_ebea ],_cfed +1){return false ;};};return true ;case *PdfObjectDictionary :_bgafb :=_bgcaf .(*PdfObjectDictionary );_cfdd ,_ebag :=(*_abea )._ccfc ,(*_bgafb )._ccfc ;if len (_cfdd )!=len (_ebag ){return false ;};for _baec ,_cafcf :=range _cfdd {_baba ,_cdcac :=_ebag [_baec ];if !_cdcac ||!_ffge (_cafcf ,_baba ,_cfed +1){return false ;};};return true ;case *PdfObjectStream :_aae :=_bgcaf .(*PdfObjectStream );return _ffge ((*_abea ).PdfObjectDictionary ,(*_aae ).PdfObjectDictionary ,_cfed +1);default:_df .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_cgab );};return false ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_beebc :=&PdfObjectArray {};_beebc ._ddcb =[]PdfObject {};for _ ,_gbda :=range objects {_beebc ._ddcb =append (_beebc ._ddcb ,_gbda );};return _beebc ;};func _fcgb (_cdgg PdfObject ,_baggb int ,_eebae map[PdfObject ]struct{})error {_df .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_baggb );if _ ,_bbbcg :=_eebae [_cdgg ];_bbbcg {_df .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_eebae [_cdgg ]=struct{}{};switch _fbae :=_cdgg .(type ){case *PdfIndirectObject :_dbbd :=_fbae ;_df .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_dbbd );_df .Log .Trace ("\u002d\u0020\u0025\u0073",_dbbd .PdfObject );return _fcgb (_dbbd .PdfObject ,_baggb +1,_eebae );case *PdfObjectStream :_gabae :=_fbae ;return _fcgb (_gabae .PdfObjectDictionary ,_baggb +1,_eebae );case *PdfObjectDictionary :_edec :=_fbae ;_df .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_edec );for _ ,_cbff :=range _edec .Keys (){_geee :=_edec .Get (_cbff );if _efcdg ,_ddegf :=_geee .(*PdfObjectReference );_ddegf {_aefac :=_efcdg .Resolve ();_edec .Set (_cbff ,_aefac );_agece :=_fcgb (_aefac ,_baggb +1,_eebae );if _agece !=nil {return _agece ;};}else {_abgf :=_fcgb (_geee ,_baggb +1,_eebae );if _abgf !=nil {return _abgf ;};};};return nil ;case *PdfObjectArray :_aegd :=_fbae ;_df .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_aegd );for _ggeb ,_ecac :=range _aegd .Elements (){if _dfef ,_efca :=_ecac .(*PdfObjectReference );_efca {_cceg :=_dfef .Resolve ();_aegd .Set (_ggeb ,_cceg );_dffeb :=_fcgb (_cceg ,_baggb +1,_eebae );if _dffeb !=nil {return _dffeb ;};}else {_agda :=_fcgb (_ecac ,_baggb +1,_eebae );if _agda !=nil {return _agda ;};};};return nil ;case *PdfObjectReference :_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_bbfd *MultiEncoder )AddEncoder (encoder StreamEncoder ){_bbfd ._fbaa =append (_bbfd ._fbaa ,encoder );};

// String returns a string describing `ref`.
func (_eceag *PdfObjectReference )String ()string {return _afb .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_eceag .ObjectNumber ,_eceag .GenerationNumber );};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_ceb *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _ceb .isDecrypted (obj ){return nil ;};switch _efe :=obj .(type ){case *PdfIndirectObject :_ceb ._agd [_efe ]=true ;_df .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_efe .ObjectNumber ,_efe .GenerationNumber );_caec :=_efe .ObjectNumber ;_ecb :=_efe .GenerationNumber ;_faege :=_ceb .Decrypt (_efe .PdfObject ,_caec ,_ecb );if _faege !=nil {return _faege ;};return nil ;case *PdfObjectStream :_ceb ._agd [_efe ]=true ;_bba :=_efe .PdfObjectDictionary ;if _ceb ._fae .R !=5{if _cdc ,_dcg :=_bba .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dcg &&*_cdc =="\u0058\u0052\u0065\u0066"{return nil ;};};_gaba :=_efe .ObjectNumber ;_bdfg :=_efe .GenerationNumber ;_df .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gaba ,_bdfg );_beab :=_dec ;if _ceb ._fef .V >=4{_beab =_ceb ._abc ;_df .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_ceb ._abc );if _bcd ,_bbf :=_bba .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bbf {if _ffa ,_ddcd :=GetName (_bcd .Get (0));_ddcd {if *_ffa =="\u0043\u0072\u0079p\u0074"{_beab ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bbc ,_fbag :=_bba .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fbag {if _ega ,_edf :=_bbc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_edf {if _ ,_abg :=_ceb ._gfgf [string (*_ega )];_abg {_df .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ega );_beab =string (*_ega );};};};};};};_df .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_beab );if _beab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bab :=_ceb .Decrypt (_bba ,_gaba ,_bdfg );if _bab !=nil {return _bab ;};_eeb ,_bab :=_ceb .makeKey (_beab ,uint32 (_gaba ),uint32 (_bdfg ),_ceb ._acf );if _bab !=nil {return _bab ;};_efe .Stream ,_bab =_ceb .decryptBytes (_efe .Stream ,_beab ,_eeb );if _bab !=nil {return _bab ;};_bba .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_efe .Stream ))));return nil ;case *PdfObjectString :_df .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_adb :=_dec ;if _ceb ._fef .V >=4{_df .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ceb ._gdg );if _ceb ._gdg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_adb =_ceb ._gdg ;};_eedd ,_baf :=_ceb .makeKey (_adb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_ceb ._acf );if _baf !=nil {return _baf ;};_fcad :=_efe .Str ();_ecea :=make ([]byte ,len (_fcad ));for _cdg :=0;_cdg < len (_fcad );_cdg ++{_ecea [_cdg ]=_fcad [_cdg ];};_df .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ecea ,_ecea );_ecea ,_baf =_ceb .decryptBytes (_ecea ,_adb ,_eedd );if _baf !=nil {return _baf ;};_efe ._ggbb =string (_ecea );return nil ;case *PdfObjectArray :for _ ,_bgae :=range _efe .Elements (){_dbd :=_ceb .Decrypt (_bgae ,parentObjNum ,parentGenNum );if _dbd !=nil {return _dbd ;};};return nil ;case *PdfObjectDictionary :_bcc :=false ;if _ggbc :=_efe .Get ("\u0054\u0079\u0070\u0065");_ggbc !=nil {_eged ,_bbaa :=_ggbc .(*PdfObjectName );if _bbaa &&*_eged =="\u0053\u0069\u0067"{_bcc =true ;};};for _ ,_ebg :=range _efe .Keys (){_egb :=_efe .Get (_ebg );if _bcc &&string (_ebg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_ebg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ebg )!="\u0050\u0072\u0065\u0076"&&string (_ebg )!="\u004c\u0061\u0073\u0074"{_fec :=_ceb .Decrypt (_egb ,parentObjNum ,parentGenNum );if _fec !=nil {return _fec ;};};};return nil ;};return nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_gaae *PdfObjectDictionary )Keys ()[]PdfObjectName {if _gaae ==nil {return nil ;};return _gaae ._fdaf ;};var _egd =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_dadcd *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_gcacc error ){const _gggd ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _dadcd ==nil {return _ff .Error (_gggd ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_dadcd .DefaultPageSettings ;};if _dadcd ._beeb ==nil {_dadcd ._beeb =_cg .InitEncodeDocument (settings .FileMode );};if _gcacc =settings .Validate ();_gcacc !=nil {return _ff .Wrap (_gcacc ,_gggd ,"");};_efcb ,_gcacc :=img .toBitmap ();if _gcacc !=nil {return _ff .Wrap (_gcacc ,_gggd ,"");};switch settings .Compression {case JB2Generic :if _gcacc =_dadcd ._beeb .AddGenericPage (_efcb ,settings .DuplicatedLinesRemoval );_gcacc !=nil {return _ff .Wrap (_gcacc ,_gggd ,"");};case JB2SymbolCorrelation :return _ff .Error (_gggd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _ff .Error (_gggd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _ff .Error (_gggd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_aag *PdfCrypt )isDecrypted (_fbe PdfObject )bool {_ ,_eeg :=_aag ._agd [_fbe ];if _eeg {_df .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cedg :=_fbe .(type ){case *PdfObjectStream :if _aag ._fae .R !=5{if _egg ,_dcfe :=_cedg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dcfe &&*_egg =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_eeg =_aag ._beb [int (_cedg .ObjectNumber )];_eeg {return true ;};switch _baae :=_cedg .PdfObject .(type ){case *PdfObjectDictionary :_gdba :=true ;for _ ,_agb :=range _egd {if _baae .Get (_agb )==nil {_gdba =false ;break ;};};if _gdba {return true ;};};};_df .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// String returns a string describing `array`.
func (_ebcgf *PdfObjectArray )String ()string {_gcgf :="\u005b";for _dffg ,_efgd :=range _ebcgf .Elements (){_gcgf +=_efgd .String ();if _dffg < (_ebcgf .Len ()-1){_gcgf +="\u002c\u0020";};};_gcgf +="\u005d";return _gcgf ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_dbgaa *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dbgaa ._ddcb ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dbgaa ._ddcb [i ]=obj ;return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_caecb *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };func (_ageac *PdfParser )parseBool ()(PdfObjectBool ,error ){_cbfc ,_gced :=_ageac ._adedf .Peek (4);if _gced !=nil {return PdfObjectBool (false ),_gced ;};if (len (_cbfc )>=4)&&(string (_cbfc [:4])=="\u0074\u0072\u0075\u0065"){_ageac ._adedf .Discard (4);return PdfObjectBool (true ),nil ;};_cbfc ,_gced =_ageac ._adedf .Peek (5);if _gced !=nil {return PdfObjectBool (false ),_gced ;};if (len (_cbfc )>=5)&&(string (_cbfc [:5])=="\u0066\u0061\u006cs\u0065"){_ageac ._adedf .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_daga *PdfParser )readTextLine ()(string ,error ){var _ffgba _cbd .Buffer ;for {_efeg ,_gag :=_daga ._adedf .Peek (1);if _gag !=nil {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gag .Error ());return _ffgba .String (),_gag ;};if (_efeg [0]!='\r')&&(_efeg [0]!='\n'){_bebc ,_ :=_daga ._adedf .ReadByte ();_ffgba .WriteByte (_bebc );}else {break ;};};return _ffgba .String (),nil ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gddd *PdfParser )CheckAccessRights (password []byte )(bool ,_eg .Permissions ,error ){if _gddd ._bfdde ==nil {return true ,_eg .PermOwner ,nil ;};return _gddd ._bfdde .checkAccessRights (password );};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_gedab *PdfObjectString )Str ()string {return _gedab ._ggbb };func _ggfe (_fgec string )(PdfObjectReference ,error ){_fac :=PdfObjectReference {};_aaaa :=_fgdgf .FindStringSubmatch (string (_fgec ));if len (_aaaa )< 3{_df .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _fac ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_egcc ,_ :=_e .Atoi (_aaaa [1]);_cfga ,_ :=_e .Atoi (_aaaa [2]);_fac .ObjectNumber =int64 (_egcc );_fac .GenerationNumber =int64 (_cfga );return _fac ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_bdc .Reader )(PdfObject ,error ){_geebe :=false ;_agcg :=true ;var _fggde _cbd .Buffer ;for {if _df .Log .IsLogLevel (_df .LogLevelTrace ){_df .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fggde .String ());};_gfeeg ,_ecacb :=buf .Peek (1);if _ecacb ==_b .EOF {break ;};if _ecacb !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ecacb );return nil ,_ecacb ;};if _agcg &&(_gfeeg [0]=='-'||_gfeeg [0]=='+'){_aacd ,_ :=buf .ReadByte ();_fggde .WriteByte (_aacd );_agcg =false ;}else if IsDecimalDigit (_gfeeg [0]){_eceg ,_ :=buf .ReadByte ();_fggde .WriteByte (_eceg );}else if _gfeeg [0]=='.'{_eeec ,_ :=buf .ReadByte ();_fggde .WriteByte (_eeec );_geebe =true ;}else if _gfeeg [0]=='e'||_gfeeg [0]=='E'{_ccdb ,_ :=buf .ReadByte ();_fggde .WriteByte (_ccdb );_geebe =true ;_agcg =true ;}else {break ;};};var _ggfec PdfObject ;if _geebe {_cffd ,_agfgg :=_e .ParseFloat (_fggde .String (),64);if _agfgg !=nil {_df .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fggde .String (),_agfgg );_cffd =0.0;_agfgg =nil ;};_eebg :=PdfObjectFloat (_cffd );_ggfec =&_eebg ;}else {_cdaf ,_fafb :=_e .ParseInt (_fggde .String (),10,64);if _fafb !=nil {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fggde .String (),_fafb );_cdaf =0;_fafb =nil ;};_bedfc :=PdfObjectInteger (_cdaf );_ggfec =&_bedfc ;};return _ggfec ,nil ;};func (_dcga *PdfParser )parseXrefStream (_gcacf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _gcacf !=nil {_df .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_gcacf );_dcga ._fcfg .Seek (int64 (*_gcacf ),_b .SeekStart );_dcga ._adedf =_bdc .NewReader (_dcga ._fcfg );};_cgcd :=_dcga .GetFileOffset ();_bbfa ,_gbaf :=_dcga .ParseIndirectObject ();if _gbaf !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_df .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bbfa );_fcbb ,_cbaae :=_bbfa .(*PdfObjectStream );if !_cbaae {_df .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bgfa :=_fcbb .PdfObjectDictionary ;_acee ,_cbaae :=_fcbb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_cbaae {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_acee )> 8388607{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_acee );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ead :=_fcbb .PdfObjectDictionary .Get ("\u0057");_afba ,_cbaae :=_ead .(*PdfObjectArray );if !_cbaae {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_aafcf :=_afba .Len ();if _aafcf !=3{_df .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_aafcf );return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _gbfeg []int64 ;for _faeaf :=0;_faeaf < 3;_faeaf ++{_daed ,_bcdd :=GetInt (_afba .Get (_faeaf ));if !_bcdd {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_gbfeg =append (_gbfeg ,int64 (*_daed ));};_egebb ,_gbaf :=DecodeStream (_fcbb );if _gbaf !=nil {_df .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gbaf );return nil ,_gbaf ;};_abba :=int (_gbfeg [0]);_bagg :=int (_gbfeg [0]+_gbfeg [1]);_dagd :=int (_gbfeg [0]+_gbfeg [1]+_gbfeg [2]);_cggc :=int (_gbfeg [0]+_gbfeg [1]+_gbfeg [2]);if _abba < 0||_bagg < 0||_dagd < 0{_df .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_abba ,_bagg ,_dagd );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cggc ==0{_df .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _bgfa ,nil ;};_aeae :=len (_egebb )/_cggc ;_ebbg :=0;_beef :=_fcbb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _eeca []int ;if _beef !=nil {_df .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_beef );_acgf ,_cfgae :=_beef .(*PdfObjectArray );if !_cfgae {_df .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _acgf .Len ()%2!=0{_df .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ebbg =0;_febd ,_bdfge :=_acgf .ToIntegerArray ();if _bdfge !=nil {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_bdfge );return nil ,_bdfge ;};for _egcd :=0;_egcd < len (_febd );_egcd +=2{_eecfg :=_febd [_egcd ];_bfbg :=_febd [_egcd +1];for _bdede :=0;_bdede < _bfbg ;_bdede ++{_eeca =append (_eeca ,_eecfg +_bdede );};_ebbg +=_bfbg ;};}else {for _fceg :=0;_fceg < int (*_acee );_fceg ++{_eeca =append (_eeca ,_fceg );};_ebbg =int (*_acee );};if _aeae ==_ebbg +1{_df .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_gagae :=_ebbg -1;for _ ,_ggfd :=range _eeca {if _ggfd > _gagae {_gagae =_ggfd ;};};_eeca =append (_eeca ,_gagae +1);_ebbg ++;};if _aeae !=len (_eeca ){_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_aeae ,len (_eeca ));return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_df .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ebbg );_df .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_eeca );_ffadf :=func (_fgac []byte )int64 {var _bcbf int64 ;for _ebgg :=0;_ebgg < len (_fgac );_ebgg ++{_bcbf +=int64 (_fgac [_ebgg ])*(1<<uint (8*(len (_fgac )-_ebgg -1)));};return _bcbf ;};_df .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_egebb ));_gaee :=0;for _acfe :=0;_acfe < len (_egebb );_acfe +=_cggc {_agfb :=_becb (len (_egebb ),_acfe ,_acfe +_abba );if _agfb !=nil {_df .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_agfb );return nil ,_agfb ;};_efgbd :=_egebb [_acfe :_acfe +_abba ];_agfb =_becb (len (_egebb ),_acfe +_abba ,_acfe +_bagg );if _agfb !=nil {_df .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_agfb );return nil ,_agfb ;};_bbfb :=_egebb [_acfe +_abba :_acfe +_bagg ];_agfb =_becb (len (_egebb ),_acfe +_bagg ,_acfe +_dagd );if _agfb !=nil {_df .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_agfb );return nil ,_agfb ;};_acdb :=_egebb [_acfe +_bagg :_acfe +_dagd ];_bgcae :=_ffadf (_efgbd );_efeb :=_ffadf (_bbfb );_gfce :=_ffadf (_acdb );if _gbfeg [0]==0{_bgcae =1;};if _gaee >=len (_eeca ){_df .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_ecga :=_eeca [_gaee ];_gaee ++;_df .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_ecga ,_efgbd );_df .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_ecga ,_bbfb );_df .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_ecga ,_acdb );_df .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_ecga ,_bgcae ,_efeb ,_gfce );if _bgcae ==0{_df .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _bgcae ==1{_df .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_bbfb );if _efeb ==_cgcd {_df .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_ecga ,_fcbb .ObjectNumber );_ecga =int (_fcbb .ObjectNumber );};if _cdcba ,_efgcd :=_dcga ._ebbc .ObjectMap [_ecga ];!_efgcd ||int (_gfce )> _cdcba .Generation {_gggde :=XrefObject {ObjectNumber :_ecga ,XType :XrefTypeTableEntry ,Offset :_efeb ,Generation :int (_gfce )};_dcga ._ebbc .ObjectMap [_ecga ]=_gggde ;};}else if _bgcae ==2{_df .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_ceeb :=_dcga ._ebbc .ObjectMap [_ecga ];!_ceeb {_eefgd :=XrefObject {ObjectNumber :_ecga ,XType :XrefTypeObjectStream ,OsObjNumber :int (_efeb ),OsObjIndex :int (_gfce )};_dcga ._ebbc .ObjectMap [_ecga ]=_eefgd ;_df .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_eefgd );};}else {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _dcga ._eccf ==nil {_dcbfg :=XrefTypeObjectStream ;_dcga ._eccf =&_dcbfg ;};return _bgfa ,nil ;};

// String returns a string describing `d`.
func (_cgged *PdfObjectDictionary )String ()string {var _dcfef _gc .Builder ;_dcfef .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_gfff :=range _cgged ._fdaf {_ecbdf :=_cgged ._ccfc [_gfff ];_dcfef .WriteString ("\u0022"+_gfff .String ()+"\u0022\u003a\u0020");_dcfef .WriteString (_ecbdf .String ());_dcfef .WriteString ("\u002c\u0020");};_dcfef .WriteString ("\u0029");return _dcfef .String ();};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_dcfa *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_df .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gfbf :=MakeDict ();_gfbf ._bfdda =_dcfa ;_dcfc ,_ :=_dcfa ._adedf .ReadByte ();if _dcfc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dcfc ,_ =_dcfa ._adedf .ReadByte ();if _dcfc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_dcfa .skipSpaces ();_dcfa .skipComments ();_gefd ,_cafc :=_dcfa ._adedf .Peek (2);if _cafc !=nil {return nil ,_cafc ;};_df .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gefd ),string (_gefd ));if (_gefd [0]=='>')&&(_gefd [1]=='>'){_df .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_dcfa ._adedf .ReadByte ();_dcfa ._adedf .ReadByte ();break ;};_df .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_geda ,_cafc :=_dcfa .parseName ();_df .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_geda );if _cafc !=nil {_df .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_cafc );return nil ,_cafc ;};if len (_geda )> 4&&_geda [len (_geda )-4:]=="\u006e\u0075\u006c\u006c"{_gaac :=_geda [0:len (_geda )-4];_df .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_geda );_df .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_gaac );_dcfa .skipSpaces ();_ecfa ,_ :=_dcfa ._adedf .Peek (1);if _ecfa [0]=='/'{_gfbf .Set (_gaac ,MakeNull ());continue ;};};_dcfa .skipSpaces ();_cgfc ,_cafc :=_dcfa .parseObject ();if _cafc !=nil {return nil ,_cafc ;};_gfbf .Set (_geda ,_cgfc );if _df .Log .IsLogLevel (_df .LogLevelTrace ){_df .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_geda ,_cgfc .String ());};};_df .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gfbf ,nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_geae *PdfParser )IsEncrypted ()(bool ,error ){if _geae ._bfdde !=nil {return true ,nil ;}else if _geae ._abab ==nil {return false ,nil ;};_df .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_dfcg :=_geae ._abab .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _dfcg ==nil {return false ,nil ;};_df .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_decd *PdfObjectDictionary ;);switch _ceff :=_dfcg .(type ){case *PdfObjectDictionary :_decd =_ceff ;case *PdfObjectReference :_df .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_ceff );_gbff ,_bfgd :=_geae .LookupByReference (*_ceff );_df .Log .Trace ("\u0031\u003a\u0020%\u0071",_gbff );if _bfgd !=nil {return false ,_bfgd ;};_afbed ,_dcee :=_gbff .(*PdfIndirectObject );if !_dcee {_df .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_gbede ,_dcee :=_afbed .PdfObject .(*PdfObjectDictionary );_df .Log .Trace ("\u0032\u003a\u0020%\u0071",_gbede );if !_dcee {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_decd =_gbede ;case *PdfObjectNull :_df .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_afb .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_ceff );};_ggfeg ,_eeac :=PdfCryptNewDecrypt (_geae ,_decd ,_geae ._abab );if _eeac !=nil {return false ,_eeac ;};for _ ,_bfdb :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_dffb :=_geae ._abab .Get (PdfObjectName (_bfdb ));if _dffb ==nil {continue ;};switch _feee :=_dffb .(type ){case *PdfObjectReference :_ggfeg ._beb [int (_feee .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_ggfeg ._agd [_feee ]=true ;_ggfeg ._beb [int (_feee .ObjectNumber )]=struct{}{};};};_geae ._bfdde =_ggfeg ;_df .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_ggfeg );return true ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};func (_cade *PdfObjectFloat )String ()string {return _afb .Sprintf ("\u0025\u0066",*_cade )};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_ccfc map[PdfObjectName ]PdfObject ;_fdaf []PdfObjectName ;_bfdda *PdfParser ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_efcd *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cgcgb []float64 ;for _ ,_adeff :=range _efcd .Elements (){_ecefec ,_afaf :=GetNumberAsFloat (TraceToDirectObject (_adeff ));if _afaf !=nil {return nil ,_afb .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_cgcgb =append (_cgcgb ,_ecefec );};return _cgcgb ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _dfee _cbd .Buffer ;_dfee .Write ([]byte {0xFE,0xFF});_dfee .WriteString (_bdb .StringToUTF16 (s ));return &PdfObjectString {_ggbb :_dfee .String (),_gaab :true };};return &PdfObjectString {_ggbb :string (_bdb .StringToPDFDocEncoding (s )),_gaab :false };};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bebbd ,_efgaf :=obj .(*PdfObjectReference );_efgaf {return _bebbd .Resolve ();};return obj ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_abcae *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_abcae ._fafd ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_abcae ._fafd [i ]=obj ;return nil ;};func (_gdaf *PdfParser )resolveReference (_gabd *PdfObjectReference )(PdfObject ,bool ,error ){_cccf ,_agdcd :=_gdaf .ObjCache [int (_gabd .ObjectNumber )];if _agdcd {return _cccf ,true ,nil ;};_faafg ,_fgb :=_gdaf .LookupByReference (*_gabd );if _fgb !=nil {return nil ,false ,_fgb ;};_gdaf .ObjCache [int (_gabd .ObjectNumber )]=_faafg ;return _faafg ,false ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dcgb *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_bggg *ASCII85Encoder )base256Tobase85 (_ddcg uint32 )[5]byte {_ccff :=[5]byte {0,0,0,0,0};_eef :=_ddcg ;for _bccf :=0;_bccf < 5;_bccf ++{_aced :=uint32 (1);for _acef :=0;_acef < 4-_bccf ;_acef ++{_aced *=85;};_ebege :=_eef /_aced ;_eef =_eef %_aced ;_ccff [_bccf ]=byte (_ebege );};return _ccff ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ccfdc *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ef .Globals ,error ){return _ef .DecodeGlobals (encoded );};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bfe *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bfe .isEncrypted (obj ){return nil ;};switch _gff :=obj .(type ){case *PdfIndirectObject :_bfe ._be [_gff ]=true ;_df .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_gff .ObjectNumber ,_gff .GenerationNumber );_edg :=_gff .ObjectNumber ;_gbfd :=_gff .GenerationNumber ;_eaff :=_bfe .Encrypt (_gff .PdfObject ,_edg ,_gbfd );if _eaff !=nil {return _eaff ;};return nil ;case *PdfObjectStream :_bfe ._be [_gff ]=true ;_bbcb :=_gff .PdfObjectDictionary ;if _bfdd ,_dege :=_bbcb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dege &&*_bfdd =="\u0058\u0052\u0065\u0066"{return nil ;};_fda :=_gff .ObjectNumber ;_dda :=_gff .GenerationNumber ;_df .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fda ,_dda );_gaa :=_dec ;if _bfe ._fef .V >=4{_gaa =_bfe ._abc ;_df .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bfe ._abc );if _gabf ,_cad :=_bbcb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_cad {if _ddgb ,_aga :=GetName (_gabf .Get (0));_aga {if *_ddgb =="\u0043\u0072\u0079p\u0074"{_gaa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _egba ,_fcec :=_bbcb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fcec {if _dcb ,_cfg :=_egba .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cfg {if _ ,_ggac :=_bfe ._gfgf [string (*_dcb )];_ggac {_df .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dcb );_gaa =string (*_dcb );};};};};};};_df .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gaa );if _gaa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_afc :=_bfe .Encrypt (_gff .PdfObjectDictionary ,_fda ,_dda );if _afc !=nil {return _afc ;};_cdcf ,_afc :=_bfe .makeKey (_gaa ,uint32 (_fda ),uint32 (_dda ),_bfe ._acf );if _afc !=nil {return _afc ;};_gff .Stream ,_afc =_bfe .encryptBytes (_gff .Stream ,_gaa ,_cdcf );if _afc !=nil {return _afc ;};_bbcb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gff .Stream ))));return nil ;case *PdfObjectString :_df .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_abd :=_dec ;if _bfe ._fef .V >=4{_df .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bfe ._gdg );if _bfe ._gdg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_abd =_bfe ._gdg ;};_eee ,_addb :=_bfe .makeKey (_abd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bfe ._acf );if _addb !=nil {return _addb ;};_cec :=_gff .Str ();_aagf :=make ([]byte ,len (_cec ));for _fcadc :=0;_fcadc < len (_cec );_fcadc ++{_aagf [_fcadc ]=_cec [_fcadc ];};_df .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_aagf ,_aagf );_aagf ,_addb =_bfe .encryptBytes (_aagf ,_abd ,_eee );if _addb !=nil {return _addb ;};_gff ._ggbb =string (_aagf );return nil ;case *PdfObjectArray :for _ ,_edba :=range _gff .Elements (){_adad :=_bfe .Encrypt (_edba ,parentObjNum ,parentGenNum );if _adad !=nil {return _adad ;};};return nil ;case *PdfObjectDictionary :_gge :=false ;if _eda :=_gff .Get ("\u0054\u0079\u0070\u0065");_eda !=nil {_fgef ,_bee :=_eda .(*PdfObjectName );if _bee &&*_fgef =="\u0053\u0069\u0067"{_gge =true ;};};for _ ,_degef :=range _gff .Keys (){_addc :=_gff .Get (_degef );if _gge &&string (_degef )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_degef )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_degef )!="\u0050\u0072\u0065\u0076"&&string (_degef )!="\u004c\u0061\u0073\u0074"{_bdbb :=_bfe .Encrypt (_addc ,parentObjNum ,parentGenNum );if _bdbb !=nil {return _bdbb ;};};};return nil ;};return nil ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_aacc *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _fgea []byte ;_df .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fdba :=0;_deea :=false ;for _fdba < len (encoded )&&!_deea {_efdc :=[5]byte {0,0,0,0,0};_fabg :=0;_cacd :=0;_gccb :=4;for _cacd < 5+_fabg {if _fdba +_cacd ==len (encoded ){break ;};_egedf :=encoded [_fdba +_cacd ];if IsWhiteSpace (_egedf ){_fabg ++;_cacd ++;continue ;}else if _egedf =='~'&&_fdba +_cacd +1< len (encoded )&&encoded [_fdba +_cacd +1]=='>'{_gccb =(_cacd -_fabg )-1;if _gccb < 0{_gccb =0;};_deea =true ;break ;}else if _egedf >='!'&&_egedf <='u'{_egedf -='!';}else if _egedf =='z'&&_cacd -_fabg ==0{_gccb =4;_cacd ++;break ;}else {_df .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_efdc [_cacd -_fabg ]=_egedf ;_cacd ++;};_fdba +=_cacd ;for _bbeg :=_gccb +1;_bbeg < 5;_bbeg ++{_efdc [_bbeg ]=84;};_aafc :=uint32 (_efdc [0])*85*85*85*85+uint32 (_efdc [1])*85*85*85+uint32 (_efdc [2])*85*85+uint32 (_efdc [3])*85+uint32 (_efdc [4]);_egfa :=[]byte {byte ((_aafc >>24)&0xff),byte ((_aafc >>16)&0xff),byte ((_aafc >>8)&0xff),byte (_aafc &0xff)};_fgea =append (_fgea ,_egfa [:_gccb ]...);};_df .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_df .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_fgea );return _fgea ,nil ;};

// Len returns the number of elements in the array.
func (_ddbg *PdfObjectArray )Len ()int {if _ddbg ==nil {return 0;};return len (_ddbg ._ddcb );};

// SetImage sets the image base for given flate encoder.
func (_cfcb *FlateEncoder )SetImage (img *_gf .ImageBase ){_cfcb ._gbc =img };const _bccga =10;

// Bytes returns the PdfObjectString content as a []byte array.
func (_ggge *PdfObjectString )Bytes ()[]byte {return []byte (_ggge ._ggbb )};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_egbeg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cafe :=MakeDict ();_cafe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egbeg .GetFilterName ()));return _cafe ;};func (_agef *FlateEncoder )cleanImageData (_gffe []byte )([]byte ,error ){if _agef ._gbc ==nil {return _gffe ,nil ;};if _agef ._gbc .BitsPerComponent >=8{return _gffe ,nil ;};_eac :=_agef ._gbc .BitsPerComponent *_agef ._gbc .Width *_agef ._gbc .ColorComponents *_agef ._gbc .Height /8;_gffe =_gffe [:_eac ];var _dag error ;_gffe ,_dag =_gf .AddDataPadding (_agef ._gbc .Width ,_agef ._gbc .Height ,_agef ._gbc .BitsPerComponent ,_agef ._gbc .ColorComponents ,_gffe );if _dag !=nil {return nil ,_dag ;};return _gffe ,nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _fea .Filter ,userPass ,ownerPass []byte ,perm _eg .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_edbc :=&PdfCrypt {_be :make (map[PdfObject ]bool ),_gfgf :make (cryptFilters ),_fae :_eg .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _bb Version ;if cf !=nil {_gde :=cf .PDFVersion ();_bb .Major ,_bb .Minor =_gde [0],_gde [1];V ,R :=cf .HandlerVersion ();_edbc ._fef .V =V ;_edbc ._fae .R =R ;_edbc ._fef .Length =cf .KeyLength ()*8;};const (_gb =_dec ;);_edbc ._gfgf [_gb ]=cf ;if _edbc ._fef .V >=4{_edbc ._abc =_gb ;_edbc ._gdg =_gb ;};_dgec :=_edbc .newEncryptDict ();_dad :=_fg .Sum ([]byte (_cd .Now ().Format (_cd .RFC850 )));_ea :=string (_dad [:]);_ced :=make ([]byte ,100);_afbb .Read (_ced );_dad =_fg .Sum (_ced );_dgf :=string (_dad [:]);_df .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ced );_df .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ea );_edbc ._bda =string (_ea );_cba :=_edbc .generateParams (userPass ,ownerPass );if _cba !=nil {return nil ,nil ,_cba ;};_cfd (&_edbc ._fae ,_dgec );if _edbc ._fef .V >=4{if _eaa :=_edbc .saveCryptFilters (_dgec );_eaa !=nil {return nil ,nil ,_eaa ;};};return _edbc ,&EncryptInfo {Version :_bb ,Encrypt :_dgec ,ID0 :_ea ,ID1 :_dgf },nil ;};func _fabgg (_abdd _b .ReadSeeker ,_adebf int64 )(*offsetReader ,error ){_cacb :=&offsetReader {_ebbd :_abdd ,_gdbdf :_adebf };_ ,_aadgg :=_cacb .Seek (0,_b .SeekStart );return _cacb ,_aadgg ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_cgbc []float64 ,_adcf error ){for _ ,_eeeeg :=range objects {_daagg ,_dabc :=GetNumberAsFloat (_eeeeg );if _dabc !=nil {return nil ,_dabc ;};_cgbc =append (_cgbc ,_daagg );};return _cgbc ,nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_ebaaf *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ebaaf .DecodeBytes (streamObj .Stream );};func (_eafgd *PdfParser )skipComments ()error {if _ ,_bfbc :=_eafgd .skipSpaces ();_bfbc !=nil {return _bfbc ;};_bgbga :=true ;for {_cbaa ,_eege :=_eafgd ._adedf .Peek (1);if _eege !=nil {_df .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_eege .Error ());return _eege ;};if _bgbga &&_cbaa [0]!='%'{return nil ;};_bgbga =false ;if (_cbaa [0]!='\r')&&(_cbaa [0]!='\n'){_eafgd ._adedf .ReadByte ();}else {break ;};};return _eafgd .skipComments ();};func (_ga *PdfParser )lookupObjectViaOS (_ca int ,_fc int )(PdfObject ,error ){var _gab *_cbd .Reader ;var _gd objectStream ;var _fbf bool ;_gd ,_fbf =_ga ._bddd [_ca ];if !_fbf {_bg ,_ace :=_ga .LookupByNumber (_ca );if _ace !=nil {_df .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ca );return nil ,_ace ;};_ege ,_fd :=_bg .(*PdfObjectStream );if !_fd {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _ga ._bfdde !=nil &&!_ga ._bfdde .isDecrypted (_ege ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ddg :=_ege .PdfObjectDictionary ;_df .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ddg .String ());_ad ,_fd :=_ddg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_fd {_df .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gc .ToLower (string (*_ad ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_fd :=_ddg .Get ("\u004e").(*PdfObjectInteger );if !_fd {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_dg ,_fd :=_ddg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_fd {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_df .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ad ,*N );_cae ,_ace :=DecodeStream (_ege );if _ace !=nil {return nil ,_ace ;};_df .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_cae );_ed :=_ga .GetFileOffset ();defer func (){_ga .SetFileOffset (_ed )}();_gab =_cbd .NewReader (_cae );_ga ._adedf =_bdc .NewReader (_gab );_df .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_fge :=map[int ]int64 {};for _cbb :=0;_cbb < int (*N );_cbb ++{_ga .skipSpaces ();_ce ,_deac :=_ga .parseNumber ();if _deac !=nil {return nil ,_deac ;};_eba ,_db :=_ce .(*PdfObjectInteger );if !_db {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ga .skipSpaces ();_ce ,_deac =_ga .parseNumber ();if _deac !=nil {return nil ,_deac ;};_gad ,_db :=_ce .(*PdfObjectInteger );if !_db {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_df .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eba ,*_gad );_fge [int (*_eba )]=int64 (*_dg +*_gad );};_gd =objectStream {N :int (*N ),_aed :_cae ,_ag :_fge };_ga ._bddd [_ca ]=_gd ;}else {_ba :=_ga .GetFileOffset ();defer func (){_ga .SetFileOffset (_ba )}();_gab =_cbd .NewReader (_gd ._aed );_ga ._adedf =_bdc .NewReader (_gab );};_age :=_gd ._ag [_fc ];_df .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_fc ,_age );_gab .Seek (_age ,_eb .SEEK_SET );_ga ._adedf =_bdc .NewReader (_gab );_cf ,_ :=_ga ._adedf .Peek (100);_df .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cf ));_dff ,_fed :=_ga .parseObject ();if _fed !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fed );return nil ,_fed ;};if _dff ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_cge :=PdfIndirectObject {};_cge .ObjectNumber =int64 (_fc );_cge .PdfObject =_dff ;return &_cge ,nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_cda *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aacg :=&_dd .Encoder {K :_cda .K ,Columns :_cda .Columns ,EndOfLine :_cda .EndOfLine ,EndOfBlock :_cda .EndOfBlock ,BlackIs1 :_cda .BlackIs1 ,DamagedRowsBeforeError :_cda .DamagedRowsBeforeError ,Rows :_cda .Rows ,EncodedByteAlign :_cda .EncodedByteAlign };_bcfe ,_bcba :=_aacg .Decode (encoded );if _bcba !=nil {return nil ,_bcba ;};var _efdg []byte ;_gcccc :=0;var _cgc byte ;var _bdfgf byte ;for _faaf :=range _bcfe {if _cgc !=0{_efdg =append (_efdg ,_bdfgf );_bdfgf =0;_gcccc ++;_cgc =0;};for _cea :=range _bcfe [_faaf ]{_bdfgf |=_bcfe [_faaf ][_cea ]<<(7-_cgc );_cgc ++;if _cgc ==8{_efdg =append (_efdg ,_bdfgf );_bdfgf =0;_gcccc ++;_cgc =0;};};};if _cgc > 0{_efdg =append (_efdg ,_bdfgf );};return _efdg ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// GetParser returns the parser for lazy-loading or compare references.
func (_fbcef *PdfObjectReference )GetParser ()*PdfParser {return _fbcef ._fgedb };

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_cef *JBIG2Image )ToGoImage ()(_bc .Image ,error ){const _cgf ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _cef .Data ==nil {return nil ,_ff .Error (_cgf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cef .Width ==0||_cef .Height ==0{return nil ,_ff .Error (_cgf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_edee ,_bcdbb :=_gf .NewImage (_cef .Width ,_cef .Height ,1,1,_cef .Data ,nil ,nil );if _bcdbb !=nil {return nil ,_bcdbb ;};return _edee ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};type xrefType int ;

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_dedc *PdfObjectArray )Get (i int )PdfObject {if _dedc ==nil ||i >=len (_dedc ._ddcb )||i < 0{return nil ;};return _dedc ._ddcb [i ];};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_bfec *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bfec .DecodeBytes (streamObj .Stream );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_dceg :=&ASCII85Encoder {};return _dceg };var _eafb =_a .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// Append appends PdfObject(s) to the streams.
func (_eafga *PdfObjectStreams )Append (objects ...PdfObject ){if _eafga ==nil {_df .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _eafga ._fafd ==nil {_eafga ._fafd =[]PdfObject {};};for _ ,_dbdc :=range objects {_eafga ._fafd =append (_eafga ._fafd ,_dbdc );};};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_cgec :=&PdfObjectStreams {};_cgec ._fafd =[]PdfObject {};for _ ,_cdbgg :=range objects {_cgec ._fafd =append (_cgec ._fafd ,_cdbgg );};return _cgec ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fbed :=PdfObjectBool (val );return &_fbed };func _befb (_degce int )int {if _degce < 0{return -_degce ;};return _degce ;};var _gfec =_a .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cdfc *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _aabg (obj ,0)};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_abad bool ,_eaacd bool ){_ebgf ,_eaacd :=TraceToDirectObject (obj ).(*PdfObjectBool );if _eaacd {return bool (*_ebgf ),true ;};return false ,false ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_fef encryptDict ;_fae _eg .StdEncryptDict ;_bda string ;_acf []byte ;_agd map[PdfObject ]bool ;_be map[PdfObject ]bool ;_eae bool ;_gfgf cryptFilters ;_abc string ;_gdg string ;_acb *PdfParser ;_beb map[int ]struct{};};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ebfd *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ccfg :=PdfIndirectObject {};_ccfg ._fgedb =_ebfd ;_df .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_baggd ,_adbdb :=_ebfd ._adedf .Peek (20);if _adbdb !=nil {if _adbdb !=_b .EOF {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ccfg ,_adbdb ;};};_df .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_baggd ));_gfcee :=_fdea .FindStringSubmatchIndex (string (_baggd ));if len (_gfcee )< 6{if _adbdb ==_b .EOF {return nil ,_adbdb ;};_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_baggd ));return &_ccfg ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ebfd ._adedf .Discard (_gfcee [0]);_df .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_gfcee );_gfadd :=_gfcee [1]-_gfcee [0];_bgdfg :=make ([]byte ,_gfadd );_ ,_adbdb =_ebfd .ReadAtLeast (_bgdfg ,_gfadd );if _adbdb !=nil {_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_adbdb );return nil ,_adbdb ;};_df .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_bgdfg );_fdfg :=_fdea .FindStringSubmatch (string (_bgdfg ));if len (_fdfg )< 3{_df .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_bgdfg ));return &_ccfg ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_debf ,_ :=_e .Atoi (_fdfg [1]);_eaea ,_ :=_e .Atoi (_fdfg [2]);_ccfg .ObjectNumber =int64 (_debf );_ccfg .GenerationNumber =int64 (_eaea );for {_cfec ,_acffg :=_ebfd ._adedf .Peek (2);if _acffg !=nil {return &_ccfg ,_acffg ;};_df .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cfec ),string (_cfec ));if IsWhiteSpace (_cfec [0]){_ebfd .skipSpaces ();}else if _cfec [0]=='%'{_ebfd .skipComments ();}else if (_cfec [0]=='<')&&(_cfec [1]=='<'){_df .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ccfg .PdfObject ,_acffg =_ebfd .ParseDict ();_df .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_acffg );if _acffg !=nil {return &_ccfg ,_acffg ;};_df .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_cfec [0]=='/')||(_cfec [0]=='(')||(_cfec [0]=='[')||(_cfec [0]=='<'){_ccfg .PdfObject ,_acffg =_ebfd .parseObject ();if _acffg !=nil {return &_ccfg ,_acffg ;};_df .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _cfec [0]==']'{_df .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_ebfd ._adedf .Discard (1);}else {if _cfec [0]=='e'{_fcecc ,_ggeca :=_ebfd .readTextLine ();if _ggeca !=nil {return nil ,_ggeca ;};if len (_fcecc )>=6&&_fcecc [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _cfec [0]=='s'{_cfec ,_ =_ebfd ._adedf .Peek (10);if string (_cfec [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_fgabf :=6;if len (_cfec )> 6{if IsWhiteSpace (_cfec [_fgabf ])&&_cfec [_fgabf ]!='\r'&&_cfec [_fgabf ]!='\n'{_df .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_fgabf ++;};if _cfec [_fgabf ]=='\r'{_fgabf ++;if _cfec [_fgabf ]=='\n'{_fgabf ++;};}else if _cfec [_fgabf ]=='\n'{_fgabf ++;};};_ebfd ._adedf .Discard (_fgabf );_adedc ,_gege :=_ccfg .PdfObject .(*PdfObjectDictionary );if !_gege {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_df .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_adedc );_facb ,_gdgg :=_ebfd .traceStreamLength (_adedc .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gdgg !=nil {_df .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gdgg );return nil ,_gdgg ;};_df .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_facb );_edbcc ,_cgdb :=_facb .(*PdfObjectInteger );if !_cgdb {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_cab :=*_edbcc ;if _cab < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_dgag :=_ebfd .GetFileOffset ();_gdde :=_ebfd .xrefNextObjectOffset (_dgag );if _dgag +int64 (_cab )> _gdde &&_gdde > _dgag {_df .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_dgag +int64 (_cab ));_df .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gdde );_egbee :=_gdde -_dgag -17;if _egbee < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_df .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_egbee );_cab =PdfObjectInteger (_egbee );_adedc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_egbee ));};if int64 (_cab )> _ebfd ._egbc {_df .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dbcg :=make ([]byte ,_cab );_ ,_gdgg =_ebfd .ReadAtLeast (_dbcg ,int (_cab ));if _gdgg !=nil {_df .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dbcg ),_dbcg );_df .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdgg );return nil ,_gdgg ;};_gcce :=PdfObjectStream {};_gcce .Stream =_dbcg ;_gcce .PdfObjectDictionary =_ccfg .PdfObject .(*PdfObjectDictionary );_gcce .ObjectNumber =_ccfg .ObjectNumber ;_gcce .GenerationNumber =_ccfg .GenerationNumber ;_gcce .PdfObjectReference ._fgedb =_ebfd ;_ebfd .skipSpaces ();_ebfd ._adedf .Discard (9);_ebfd .skipSpaces ();return &_gcce ,nil ;};};_ccfg .PdfObject ,_acffg =_ebfd .parseObject ();if _ccfg .PdfObject ==nil {_df .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ccfg .PdfObject =MakeNull ();};return &_ccfg ,_acffg ;};};if _ccfg .PdfObject ==nil {_df .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ccfg .PdfObject =MakeNull ();};_df .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ccfg ,nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_ggbb string ;_gaab bool ;};

// GetXrefOffset returns the offset of the xref table.
func (_gbfg *PdfParser )GetXrefOffset ()int64 {return _gbfg ._gfgfe };

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_bceb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _bceb ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcbc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_gcbc ._fbaa )==0{return nil ;};if len (_gcbc ._fbaa )==1{return _gcbc ._fbaa [0].MakeDecodeParams ();};_bfeb :=MakeArray ();for _ ,_dfce :=range _gcbc ._fbaa {_gaca :=_dfce .MakeDecodeParams ();if _gaca ==nil {_bfeb .Append (MakeNull ());}else {_bfeb .Append (_gaca );};};return _bfeb ;};const (DefaultJPEGQuality =75;);var _adf =_a .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_gfe *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gfe .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ggab *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bdgbb :=encoded ;var _aefc error ;for _ ,_eecb :=range _ggab ._fbaa {_df .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_eecb ,_eecb );_bdgbb ,_aefc =_eecb .DecodeBytes (_bdgbb );if _aefc !=nil {return nil ,_aefc ;};};return _bdgbb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ebdb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_gcca :=PdfObjectNull {};return &_gcca };

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_ddcb []PdfObject };

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cfecb []byte ,_gdcg bool ){_abcgg ,_gdcg :=TraceToDirectObject (obj ).(*PdfObjectString );if _gdcg {return _abcgg .Bytes (),true ;};return ;};