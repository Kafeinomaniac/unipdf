//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_d "bytes";_ec "crypto";_gg "crypto/rand";_c "crypto/rsa";_ab "crypto/x509";_b "crypto/x509/pkix";_ef "encoding/asn1";_de "errors";_ad "fmt";_gdg "github.com/unidoc/pkcs7";_cd "github.com/unidoc/timestamp";_dc "github.com/unidoc/unipdf/v3/core";_bd "github.com/unidoc/unipdf/v3/model";_gd "hash";_g "io";_e "io/ioutil";_fg "net/http";_a "time";);

// InitSignature initialises the PdfSignature.
func (_ecb *adobePKCS7Detached )InitSignature (sig *_bd .PdfSignature )error {if !_ecb ._ca {if _ecb ._ed ==nil {return _de .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ecb ._cf ==nil {return _de .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_efc :=*_ecb ;sig .Handler =&_efc ;sig .Filter =_dc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dc .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ge ,_bdf :=_efc .NewDigest (sig );if _bdf !=nil {return _bdf ;};_ge .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _efc .Sign (sig ,_ge );};

// Validate validates PdfSignature.
func (_fd *adobePKCS7Detached )Validate (sig *_bd .PdfSignature ,digest _bd .Hasher )(_bd .SignatureValidationResult ,error ){_eg :=sig .Contents .Bytes ();_eda ,_gdf :=_gdg .Parse (_eg );if _gdf !=nil {return _bd .SignatureValidationResult {},_gdf ;};_fb :=digest .(*_d .Buffer );_eda .Content =_fb .Bytes ();if _gdf =_eda .Verify ();_gdf !=nil {return _bd .SignatureValidationResult {},_gdf ;};return _bd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_fbe *adobeX509RSASHA1 )getCertificate (_bef *_bd .PdfSignature )(*_ab .Certificate ,error ){if _fbe ._ecc !=nil {return _fbe ._ecc ,nil ;};_fa ,_ae :=_bef .GetCerts ();if _ae !=nil {return nil ,_ae ;};return _fa [0],nil ;};type docTimeStamp struct{_dfb string ;_aee _ec .Hash ;_gbc int ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_gfa *_bd .PdfSignature ,_bb _bd .Hasher )([]byte ,error );type timestampInfo struct{Version int ;Policy _ef .RawValue ;MessageImprint struct{HashAlgorithm _b .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _ef .RawValue ;GeneralizedTime _a .Time ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_ab .Certificate ,signFunc SignFunc )(_bd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ecc :certificate ,_efg :signFunc },nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _ec .Hash ,opts *DocTimeStampOpts )(_bd .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_dfb :timestampServerURL ,_aee :hashAlgorithm ,_gbc :opts .SignatureSize },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gc *docTimeStamp )IsApplicable (sig *_bd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// InitSignature initialises the PdfSignature.
func (_deg *docTimeStamp )InitSignature (sig *_bd .PdfSignature )error {_dg :=*_deg ;sig .Handler =&_dg ;sig .Filter =_dc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dc .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _deg ._gbc > 0{sig .Contents =_dc .MakeHexString (string (make ([]byte ,_deg ._gbc )));}else {_fgc ,_def :=_deg .NewDigest (sig );if _def !=nil {return _def ;};_fgc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _def =_dg .Sign (sig ,_fgc );_def !=nil {return _def ;};_deg ._gbc =_dg ._gbc ;};return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dcde *adobeX509RSASHA1 )Sign (sig *_bd .PdfSignature ,digest _bd .Hasher )error {var _eca []byte ;var _fga error ;if _dcde ._efg !=nil {_eca ,_fga =_dcde ._efg (sig ,digest );if _fga !=nil {return _fga ;};}else {_bf ,_fcg :=digest .(_gd .Hash );if !_fcg {return _de .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gab ,_ :=_df (_dcde ._ecc .SignatureAlgorithm );_eca ,_fga =_c .SignPKCS1v15 (_gg .Reader ,_dcde ._dd ,_gab ,_bf .Sum (nil ));if _fga !=nil {return _fga ;};};_eca ,_fga =_ef .Marshal (_eca );if _fga !=nil {return _fga ;};sig .Contents =_dc .MakeHexString (string (_eca ));return nil ;};

// Validate validates PdfSignature.
func (_fc *adobeX509RSASHA1 )Validate (sig *_bd .PdfSignature ,digest _bd .Hasher )(_bd .SignatureValidationResult ,error ){_ggd ,_fdb :=_fc .getCertificate (sig );if _fdb !=nil {return _bd .SignatureValidationResult {},_fdb ;};_cbe :=sig .Contents .Bytes ();var _egg []byte ;if _ ,_bca :=_ef .Unmarshal (_cbe ,&_egg );_bca !=nil {return _bd .SignatureValidationResult {},_bca ;};_acd ,_bac :=digest .(_gd .Hash );if !_bac {return _bd .SignatureValidationResult {},_de .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dcd ,_ :=_df (_ggd .SignatureAlgorithm );if _fab :=_c .VerifyPKCS1v15 (_ggd .PublicKey .(*_c .PublicKey ),_dcd ,_acd .Sum (nil ),_egg );_fab !=nil {return _bd .SignatureValidationResult {},_fab ;};return _bd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_beb *docTimeStamp )getCertificate (_gbb *_bd .PdfSignature )(*_ab .Certificate ,error ){_cfc ,_db :=_gbb .GetCerts ();if _db !=nil {return nil ,_db ;};return _cfc [0],nil ;};

// Sign sets the Contents fields.
func (_ba *adobePKCS7Detached )Sign (sig *_bd .PdfSignature ,digest _bd .Hasher )error {if _ba ._ca {_bc :=_ba ._gf ;if _bc <=0{_bc =8192;};sig .Contents =_dc .MakeHexString (string (make ([]byte ,_bc )));return nil ;};_ggf :=digest .(*_d .Buffer );_gde ,_cb :=_gdg .NewSignedData (_ggf .Bytes ());if _cb !=nil {return _cb ;};if _ac :=_gde .AddSigner (_ba ._ed ,_ba ._cf ,_gdg .SignerInfoConfig {});_ac !=nil {return _ac ;};_gde .Detach ();_be ,_cb :=_gde .Finish ();if _cb !=nil {return _cb ;};_aa :=make ([]byte ,8192);copy (_aa ,_be );sig .Contents =_dc .MakeHexString (string (_aa ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bda *docTimeStamp )Sign (sig *_bd .PdfSignature ,digest _bd .Hasher )error {_eb :=digest .(*_d .Buffer );_ggc :=_bda ._aee .New ();if _ ,_bcd :=_g .Copy (_ggc ,_eb );_bcd !=nil {return _bcd ;};_cafb :=_cd .Request {HashAlgorithm :_bda ._aee ,HashedMessage :_ggc .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_edf ,_bbb :=_cafb .Marshal ();if _bbb !=nil {return _bbb ;};_cgg ,_bbb :=_fg .Post (_bda ._dfb ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_d .NewBuffer (_edf ));if _bbb !=nil {return _bbb ;};defer _cgg .Body .Close ();_ede ,_bbb :=_e .ReadAll (_cgg .Body );if _bbb !=nil {return _bbb ;};if _cgg .StatusCode !=_fg .StatusOK {return _ad .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_cgg .StatusCode );};var _ged struct{Version _ef .RawValue ;Content _ef .RawValue ;};if _ ,_bbb =_ef .Unmarshal (_ede ,&_ged );_bbb !=nil {return _bbb ;};_dfc :=len (_ged .Content .FullBytes );if _bda ._gbc > 0&&_dfc > _bda ._gbc {return _bd .ErrSignNotEnoughSpace ;};if _dfc > 0{_bda ._gbc =_dfc +128;};sig .Contents =_dc .MakeHexString (string (_ged .Content .FullBytes ));return nil ;};

// NewDigest creates a new digest.
func (_abf *adobeX509RSASHA1 )NewDigest (sig *_bd .PdfSignature )(_bd .Hasher ,error ){_cdg ,_dfg :=_abf .getCertificate (sig );if _dfg !=nil {return nil ,_dfg ;};_bcb ,_ :=_df (_cdg .SignatureAlgorithm );return _bcb .New (),nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_bd .SignatureHandler ,error ){return &adobePKCS7Detached {_ca :true ,_gf :signatureLen },nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// InitSignature initialises the PdfSignature.
func (_dcg *adobeX509RSASHA1 )InitSignature (sig *_bd .PdfSignature )error {if _dcg ._ecc ==nil {return _de .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _dcg ._dd ==nil &&_dcg ._efg ==nil {return _de .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_caf :=*_dcg ;sig .Handler =&_caf ;sig .Filter =_dc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dc .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_dc .MakeString (string (_caf ._ecc .Raw ));sig .Reference =nil ;_eff ,_cdc :=_caf .NewDigest (sig );if _cdc !=nil {return _cdc ;};_eff .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _caf .Sign (sig ,_eff );};type adobePKCS7Detached struct{_cf *_c .PrivateKey ;_ed *_ab .Certificate ;_ca bool ;_gf int ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_c .PrivateKey ,certificate *_ab .Certificate )(_bd .SignatureHandler ,error ){return &adobePKCS7Detached {_ed :certificate ,_cf :privateKey },nil ;};func (_ee *adobePKCS7Detached )getCertificate (_ga *_bd .PdfSignature )(*_ab .Certificate ,error ){if _ee ._ed !=nil {return _ee ._ed ,nil ;};_ce ,_cg :=_ga .GetCerts ();if _cg !=nil {return nil ,_cg ;};return _ce [0],nil ;};

// Validate validates PdfSignature.
func (_ecd *docTimeStamp )Validate (sig *_bd .PdfSignature ,digest _bd .Hasher )(_bd .SignatureValidationResult ,error ){_bge :=sig .Contents .Bytes ();_cbf ,_adg :=_gdg .Parse (_bge );if _adg !=nil {return _bd .SignatureValidationResult {},_adg ;};if _adg =_cbf .Verify ();_adg !=nil {return _bd .SignatureValidationResult {},_adg ;};var _gfc timestampInfo ;_ ,_adg =_ef .Unmarshal (_cbf .Content ,&_gfc );if _adg !=nil {return _bd .SignatureValidationResult {},_adg ;};_eef ,_adg :=_faa (_gfc .MessageImprint .HashAlgorithm .Algorithm );if _adg !=nil {return _bd .SignatureValidationResult {},_adg ;};_degf :=_eef .New ();_bdc :=digest .(*_d .Buffer );_degf .Write (_bdc .Bytes ());_ced :=_degf .Sum (nil );_cgb :=_bd .SignatureValidationResult {IsSigned :true ,IsVerified :_d .Equal (_ced ,_gfc .MessageImprint .HashedMessage ),GeneralizedTime :_gfc .GeneralizedTime };return _cgb ,nil ;};

// NewDigest creates a new digest.
func (_aaf *docTimeStamp )NewDigest (sig *_bd .PdfSignature )(_bd .Hasher ,error ){return _d .NewBuffer (nil ),nil ;};

// NewDigest creates a new digest.
func (_gb *adobePKCS7Detached )NewDigest (sig *_bd .PdfSignature )(_bd .Hasher ,error ){return _d .NewBuffer (nil ),nil ;};func _df (_add _ab .SignatureAlgorithm )(_ec .Hash ,bool ){var _fbf _ec .Hash ;switch _add {case _ab .SHA1WithRSA :_fbf =_ec .SHA1 ;case _ab .SHA256WithRSA :_fbf =_ec .SHA256 ;case _ab .SHA384WithRSA :_fbf =_ec .SHA384 ;case _ab .SHA512WithRSA :_fbf =_ec .SHA512 ;default:return _ec .SHA1 ,false ;};return _fbf ,true ;};type adobeX509RSASHA1 struct{_dd *_c .PrivateKey ;_ecc *_ab .Certificate ;_efg SignFunc ;};func _faa (_dcf _ef .ObjectIdentifier )(_ec .Hash ,error ){switch {case _dcf .Equal (_gdg .OIDDigestAlgorithmSHA1 ),_dcf .Equal (_gdg .OIDDigestAlgorithmECDSASHA1 ),_dcf .Equal (_gdg .OIDDigestAlgorithmDSA ),_dcf .Equal (_gdg .OIDDigestAlgorithmDSASHA1 ),_dcf .Equal (_gdg .OIDEncryptionAlgorithmRSA ):return _ec .SHA1 ,nil ;case _dcf .Equal (_gdg .OIDDigestAlgorithmSHA256 ),_dcf .Equal (_gdg .OIDDigestAlgorithmECDSASHA256 ):return _ec .SHA256 ,nil ;case _dcf .Equal (_gdg .OIDDigestAlgorithmSHA384 ),_dcf .Equal (_gdg .OIDDigestAlgorithmECDSASHA384 ):return _ec .SHA384 ,nil ;case _dcf .Equal (_gdg .OIDDigestAlgorithmSHA512 ),_dcf .Equal (_gdg .OIDDigestAlgorithmECDSASHA512 ):return _ec .SHA512 ,nil ;};return _ec .Hash (0),_gdg .ErrUnsupportedAlgorithm ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_bg *adobePKCS7Detached )IsApplicable (sig *_bd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _ec .Hash )(_bd .SignatureHandler ,error ){return &docTimeStamp {_dfb :timestampServerURL ,_aee :hashAlgorithm },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bde *adobeX509RSASHA1 )IsApplicable (sig *_bd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_c .PrivateKey ,certificate *_ab .Certificate )(_bd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ecc :certificate ,_dd :privateKey },nil ;};