//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_d "github.com/unidoc/unipdf/v3/common";_e "math";);func (_fcg *Matrix )Clone ()Matrix {return NewMatrix (_fcg [0],_fcg [1],_fcg [3],_fcg [4],_fcg [6],_fcg [7]);};func (_bc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bc [0],_bc [1]=a ,b ;_bc [3],_bc [4]=c ,d ;_bc [6],_bc [7]=tx ,ty ;_bc .clampRange ();};func (_aac Matrix )ScalingFactorY ()float64 {return _e .Hypot (_aac [3],_aac [4])};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_dff *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bag :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dff .transformByMatrix (_bag );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_a :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_a .clampRange ();return _a ;};type Point struct{X float64 ;Y float64 ;};func (_cd Matrix )Scale (xScale ,yScale float64 )Matrix {return _cd .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_cad Matrix )Inverse ()(Matrix ,bool ){_cce ,_fa :=_cad [0],_cad [1];_af ,_dd :=_cad [3],_cad [4];_cf ,_caf :=_cad [6],_cad [7];_fgc :=_cce *_dd -_fa *_af ;if _e .Abs (_fgc )< _cgc {return Matrix {},false ;};_daf ,_abd :=_dd /_fgc ,-_fa /_fgc ;_ebe ,_ee :=-_af /_fgc ,_cce /_fgc ;_aag :=-(_daf *_cf +_ebe *_caf );_dg :=-(_abd *_cf +_ee *_caf );return NewMatrix (_daf ,_abd ,_ebe ,_ee ,_aag ,_dg ),true ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func RotationMatrix (angle float64 )Matrix {_ed :=_e .Cos (angle );_de :=_e .Sin (angle );return NewMatrix (_ed ,_de ,-_de ,_ed ,0,0);};func (_dgd Point )Distance (b Point )float64 {return _e .Hypot (_dgd .X -b .X ,_dgd .Y -b .Y )};func (_da Matrix )Mult (b Matrix )Matrix {_da .Concat (b );return _da };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fce *Matrix )clampRange (){for _afc ,_ffd :=range _fce {if _ffd > _gf {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ffd ,_gf );_fce [_afc ]=_gf ;}else if _ffd < -_gf {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ffd ,-_gf );_fce [_afc ]=-_gf ;};};};func (_cc Matrix )Singular ()bool {return _e .Abs (_cc [0]*_cc [4]-_cc [1]*_cc [3])< _gb };func (_fc Matrix )Identity ()bool {return _fc [0]==1&&_fc [1]==0&&_fc [2]==0&&_fc [3]==0&&_fc [4]==1&&_fc [5]==0&&_fc [6]==0&&_fc [7]==0&&_fc [8]==1;};func (_edb *Matrix )Concat (b Matrix ){*_edb =Matrix {b [0]*_edb [0]+b [1]*_edb [3],b [0]*_edb [1]+b [1]*_edb [4],0,b [3]*_edb [0]+b [4]*_edb [3],b [3]*_edb [1]+b [4]*_edb [4],0,b [6]*_edb [0]+b [7]*_edb [3]+_edb [6],b [6]*_edb [1]+b [7]*_edb [4]+_edb [7],1};_edb .clampRange ();};const _gf =1e9;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_gcd *Point )Set (x ,y float64 ){_gcd .X ,_gcd .Y =x ,y };func (_gac Matrix )Translation ()(float64 ,float64 ){return _gac [6],_gac [7]};func (_gc Matrix )ScalingFactorX ()float64 {return _e .Hypot (_gc [0],_gc [1])};func (_fca Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ab :=x *_fca [0]+y *_fca [3]+_fca [6];_ff :=x *_fca [1]+y *_fca [4]+_fca [7];return _ab ,_ff ;};func (_gcdd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gcdd .X +t *b .X ,Y :(1-t )*_gcdd .Y +t *b .Y };};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_eecc Point )Rotate (theta float64 )Point {_ce :=_e .Hypot (_eecc .X ,_eecc .Y );_ccc :=_e .Atan2 (_eecc .Y ,_eecc .X );_aff ,_aad :=_e .Sincos (_ccc +theta /180.0*_e .Pi );return Point {_ce *_aad ,_ce *_aff };};const _bg =1e-6;func (_dc *Matrix )Shear (x ,y float64 ){_dc .Concat (ShearMatrix (x ,y ))};const _gb =1e-10;func (_ag Point )Displace (delta Point )Point {return Point {_ag .X +delta .X ,_ag .Y +delta .Y }};func (_eb Matrix )String ()string {_fg ,_ga ,_aa ,_ca ,_ef ,_ba :=_eb [0],_eb [1],_eb [3],_eb [4],_eb [6],_eb [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_fg ,_ga ,_aa ,_ca ,_ef ,_ba );};func (_df Matrix )Angle ()float64 {_cb :=_e .Atan2 (-_df [1],_df [0]);if _cb < 0.0{_cb +=2*_e .Pi ;};return _cb /_e .Pi *180.0;};func (_fcd *Point )transformByMatrix (_cee Matrix ){_fcd .X ,_fcd .Y =_cee .Transform (_fcd .X ,_fcd .Y )};const _cgc =1.0e-6;func (_b Matrix )Round (precision float64 )Matrix {for _c :=range _b {_b [_c ]=_e .Round (_b [_c ]/precision )*precision ;};return _b ;};func (_daa Matrix )Unrealistic ()bool {_eec ,_cg ,_faf ,_cca :=_e .Abs (_daa [0]),_e .Abs (_daa [1]),_e .Abs (_daa [3]),_e .Abs (_daa [4]);_gd :=_eec > _bg &&_cca > _bg ;_ec :=_cg > _bg &&_faf > _bg ;return !(_gd ||_ec );};type Matrix [9]float64 ;func (_bee Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_bee [0],_bee [1],_bee [3],_bee [4],_bee [6]+tx ,_bee [7]+ty );};func (_eff Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_eff .X ,_eff .Y );};func (_be Matrix )Rotate (theta float64 )Matrix {_eda ,_deg :=_e .Sincos (theta /180.0*_e .Pi );return _be .Mult (NewMatrix (_deg ,-_eda ,_eda ,_deg ,0,0));};