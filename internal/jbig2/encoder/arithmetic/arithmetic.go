//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_gc "github.com/unidoc/unipdf/v3/common";_df "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_bgb *Encoder )emit (){if _bgb ._bg ==_eaf {_bgb ._ag =append (_bgb ._ag ,_bgb ._eg );_bgb ._eg =make ([]byte ,_eaf );_bgb ._bg =0;};_bgb ._eg [_bgb ._bg ]=_bgb ._gb ;_bgb ._bg ++;};func _fgc (_bee int )*codingContext {return &codingContext {_cg :make ([]byte ,_bee ),_da :make ([]byte ,_bee )};};var _fg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_ec *Encoder )Flush (){_ec ._bg =0;_ec ._ag =nil ;_ec ._e =-1};func (_gbfa *Encoder )Refine (iTemp ,iTarget *_df .Bitmap ,ox ,oy int )error {for _ffb :=0;_ffb < iTarget .Height ;_ffb ++{var _afc int ;_fa :=_ffb +oy ;var (_gbfd ,_ab ,_fdg ,_fb ,_fcb uint16 ;_bdg ,_dfc ,_fdc ,_dac ,_aee byte ;);if _fa >=1&&(_fa -1)< iTemp .Height {_bdg =iTemp .Data [(_fa -1)*iTemp .RowStride ];};if _fa >=0&&_fa < iTemp .Height {_dfc =iTemp .Data [_fa *iTemp .RowStride ];};if _fa >=-1&&_fa +1< iTemp .Height {_fdc =iTemp .Data [(_fa +1)*iTemp .RowStride ];};if _ffb >=1{_dac =iTarget .Data [(_ffb -1)*iTarget .RowStride ];};_aee =iTarget .Data [_ffb *iTarget .RowStride ];_afa :=uint (6+ox );_gbfd =uint16 (_bdg >>_afa );_ab =uint16 (_dfc >>_afa );_fdg =uint16 (_fdc >>_afa );_fb =uint16 (_dac >>6);_bc :=uint (2-ox );_bdg <<=_bc ;_dfc <<=_bc ;_fdc <<=_bc ;_dac <<=2;for _afc =0;_afc < iTarget .Width ;_afc ++{_dba :=(_gbfd <<10)|(_ab <<7)|(_fdg <<4)|(_fb <<1)|_fcb ;_bbc :=_aee >>7;_fca :=_gbfa .encodeBit (_gbfa ._gbd ,uint32 (_dba ),_bbc );if _fca !=nil {return _fca ;};_gbfd <<=1;_ab <<=1;_fdg <<=1;_fb <<=1;_gbfd |=uint16 (_bdg >>7);_ab |=uint16 (_dfc >>7);_fdg |=uint16 (_fdc >>7);_fb |=uint16 (_dac >>7);_fcb =uint16 (_bbc );_egf :=_afc %8;_ad :=_afc /8+1;if _egf ==5+ox {_bdg ,_dfc ,_fdc =0,0,0;if _ad < iTemp .RowStride &&_fa >=1&&(_fa -1)< iTemp .Height {_bdg =iTemp .Data [(_fa -1)*iTemp .RowStride +_ad ];};if _ad < iTemp .RowStride &&_fa >=0&&_fa < iTemp .Height {_dfc =iTemp .Data [_fa *iTemp .RowStride +_ad ];};if _ad < iTemp .RowStride &&_fa >=-1&&(_fa +1)< iTemp .Height {_fdc =iTemp .Data [(_fa +1)*iTemp .RowStride +_ad ];};}else {_bdg <<=1;_dfc <<=1;_fdc <<=1;};if _egf ==5&&_ffb >=1{_dac =0;if _ad < iTarget .RowStride {_dac =iTarget .Data [(_ffb -1)*iTarget .RowStride +_ad ];};}else {_dac <<=1;};if _egf ==7{_aee =0;if _ad < iTarget .RowStride {_aee =iTarget .Data [_ffb *iTarget .RowStride +_ad ];};}else {_aee <<=1;};_gbfd &=7;_ab &=7;_fdg &=7;_fb &=7;};};return nil ;};func (_aceg *Encoder )encodeBit (_gdf *codingContext ,_bed uint32 ,_aff uint8 )error {const _eab ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_aceg ._ef ++;if _bed >=uint32 (len (_gdf ._cg )){return _f .Errorf (_eab ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bed );};_gec :=_gdf ._cg [_bed ];_agf :=_gdf .mps (_bed );_fee :=_gf [_gec ]._fbe ;_gc .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aceg ._ef ,_aff ,_gec ,_agf ,_fee ,_aceg ._bb ,_aceg ._fe ,_aceg ._ae ,_aceg ._gb ,_aceg ._e );if _aff ==0{_aceg .code0 (_gdf ,_bed ,_fee ,_gec );}else {_aceg .code1 (_gdf ,_bed ,_fee ,_gec );};return nil ;};func (_bce *Encoder )codeMPS (_dce *codingContext ,_fcg uint32 ,_eca uint16 ,_gbe byte ){_bce ._bb -=_eca ;if _bce ._bb &0x8000!=0{_bce ._fe +=uint32 (_eca );return ;};if _bce ._bb < _eca {_bce ._bb =_eca ;}else {_bce ._fe +=uint32 (_eca );};_dce ._cg [_fcg ]=_gf [_gbe ]._cgf ;_bce .renormalize ();};func (_bcc *Encoder )encodeOOB (_fbd Class )error {_ebc :=_bcc ._fec [_fbd ];_bde :=_bcc .encodeBit (_ebc ,1,1);if _bde !=nil {return _bde ;};_bde =_bcc .encodeBit (_ebc ,3,0);if _bde !=nil {return _bde ;};_bde =_bcc .encodeBit (_ebc ,6,0);if _bde !=nil {return _bde ;};_bde =_bcc .encodeBit (_ebc ,12,0);if _bde !=nil {return _bde ;};return nil ;};func (_beb *Encoder )setBits (){_bda :=_beb ._fe +uint32 (_beb ._bb );_beb ._fe |=0xffff;if _beb ._fe >=_bda {_beb ._fe -=0x8000;};};func (_dfcg *Encoder )encodeInteger (_ecc Class ,_beg int )error {const _acg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _beg > 2000000000||_beg < -2000000000{return _f .Errorf (_acg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_beg );};_acb :=_dfcg ._fec [_ecc ];_fge :=uint32 (1);var _acc int ;for ;;_acc ++{if _fg [_acc ]._db <=_beg &&_fg [_acc ]._gd >=_beg {break ;};};if _beg < 0{_beg =-_beg ;};_beg -=int (_fg [_acc ]._dg );_cdb :=_fg [_acc ]._gcc ;for _dfa :=uint8 (0);_dfa < _fg [_acc ]._b ;_dfa ++{_gad :=_cdb &1;if _ggf :=_dfcg .encodeBit (_acb ,_fge ,_gad );_ggf !=nil {return _f .Wrap (_ggf ,_acg ,"");};_cdb >>=1;if _fge &0x100> 0{_fge =(((_fge <<1)|uint32 (_gad ))&0x1ff)|0x100;}else {_fge =(_fge <<1)|uint32 (_gad );};};_beg <<=32-_fg [_acc ]._be ;for _fgf :=uint8 (0);_fgf < _fg [_acc ]._be ;_fgf ++{_aeea :=uint8 ((uint32 (_beg )&0x80000000)>>31);if _afgd :=_dfcg .encodeBit (_acb ,_fge ,_aeea );_afgd !=nil {return _f .Wrap (_afgd ,_acg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_beg <<=1;if _fge &0x100!=0{_fge =(((_fge <<1)|uint32 (_aeea ))&0x1ff)|0x100;}else {_fge =(_fge <<1)|uint32 (_aeea );};};return nil ;};func (_adfc *Encoder )renormalize (){for {_adfc ._bb <<=1;_adfc ._fe <<=1;_adfc ._ae --;if _adfc ._ae ==0{_adfc .byteOut ();};if (_adfc ._bb &0x8000)!=0{break ;};};};type codingContext struct{_cg []byte ;_da []byte ;};func (_eb *Encoder )Reset (){_eb ._bb =0x8000;_eb ._fe =0;_eb ._ae =12;_eb ._e =-1;_eb ._gb =0;_eb ._bf =nil ;_eb ._gbd =_fgc (_dda );};var _ _c .WriterTo =&Encoder {};func (_efa *Encoder )code0 (_caee *codingContext ,_abb uint32 ,_fab uint16 ,_gcd byte ){if _caee .mps (_abb )==0{_efa .codeMPS (_caee ,_abb ,_fab ,_gcd );}else {_efa .codeLPS (_caee ,_abb ,_fab ,_gcd );};};func (_cae *Encoder )EncodeOOB (proc Class )(_gaa error ){_gc .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _gaa =_cae .encodeOOB (proc );_gaa !=nil {return _f .Wrap (_gaa ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bdd *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _aed ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _beeb int64 ;for _cdg ,_de :=range _bdd ._ag {_geg ,_dca :=w .Write (_de );if _dca !=nil {return 0,_f .Wrapf (_dca ,_aed ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cdg );};_beeb +=int64 (_geg );};_bdd ._eg =_bdd ._eg [:_bdd ._bg ];_ccg ,_afd :=w .Write (_bdd ._eg );if _afd !=nil {return 0,_f .Wrap (_afd ,_aed ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_beeb +=int64 (_ccg );return _beeb ,nil ;};func (_eae *Encoder )flush (){_eae .setBits ();_eae ._fe <<=_eae ._ae ;_eae .byteOut ();_eae ._fe <<=_eae ._ae ;_eae .byteOut ();_eae .emit ();if _eae ._gb !=0xff{_eae ._e ++;_eae ._gb =0xff;_eae .emit ();};_eae ._e ++;_eae ._gb =0xac;_eae ._e ++;_eae .emit ();};func (_gce *Encoder )dataSize ()int {return _eaf *len (_gce ._ag )+_gce ._bg };func (_a Class )String ()string {switch _a {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_afg *Encoder )codeLPS (_bec *codingContext ,_ebg uint32 ,_aab uint16 ,_fdgd byte ){_afg ._bb -=_aab ;if _afg ._bb < _aab {_afg ._fe +=uint32 (_aab );}else {_afg ._bb =_aab ;};if _gf [_fdgd ]._bcb ==1{_bec .flipMps (_ebg );};_bec ._cg [_ebg ]=_gf [_fdgd ]._dgc ;_afg .renormalize ();};func (_ebb *Encoder )code1 (_ada *codingContext ,_cf uint32 ,_ddb uint16 ,_cgg byte ){if _ada .mps (_cf )==1{_ebb .codeMPS (_ada ,_cf ,_ddb ,_cgg );}else {_ebb .codeLPS (_ada ,_cf ,_ddb ,_cgg );};};func (_aad *Encoder )EncodeBitmap (bm *_df .Bitmap ,duplicateLineRemoval bool )error {_gc .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_cb ,_fd uint8 ;_ga ,_gag ,_bfb uint16 ;_dc ,_ed ,_ff byte ;_aea ,_bef ,_fc int ;_bd ,_cd []byte ;);for _gbf :=0;_gbf < bm .Height ;_gbf ++{_dc ,_ed =0,0;if _gbf >=2{_dc =bm .Data [(_gbf -2)*bm .RowStride ];};if _gbf >=1{_ed =bm .Data [(_gbf -1)*bm .RowStride ];if duplicateLineRemoval {_bef =_gbf *bm .RowStride ;_bd =bm .Data [_bef :_bef +bm .RowStride ];_fc =(_gbf -1)*bm .RowStride ;_cd =bm .Data [_fc :_fc +bm .RowStride ];if _g .Equal (_bd ,_cd ){_fd =_cb ^1;_cb =1;}else {_fd =_cb ;_cb =0;};};};if duplicateLineRemoval {if _bae :=_aad .encodeBit (_aad ._gbd ,_bge ,_fd );_bae !=nil {return _bae ;};if _cb !=0{continue ;};};_ff =bm .Data [_gbf *bm .RowStride ];_ga =uint16 (_dc >>5);_gag =uint16 (_ed >>4);_dc <<=3;_ed <<=4;_bfb =0;for _aea =0;_aea < bm .Width ;_aea ++{_bfd :=uint32 (_ga <<11|_gag <<4|_bfb );_ace :=(_ff &0x80)>>7;_ge :=_aad .encodeBit (_aad ._gbd ,_bfd ,_ace );if _ge !=nil {return _ge ;};_ga <<=1;_gag <<=1;_bfb <<=1;_ga |=uint16 ((_dc &0x80)>>7);_gag |=uint16 ((_ed &0x80)>>7);_bfb |=uint16 (_ace );_ddd :=_aea %8;_ce :=_aea /8+1;if _ddd ==4&&_gbf >=2{_dc =0;if _ce < bm .RowStride {_dc =bm .Data [(_gbf -2)*bm .RowStride +_ce ];};}else {_dc <<=1;};if _ddd ==3&&_gbf >=1{_ed =0;if _ce < bm .RowStride {_ed =bm .Data [(_gbf -1)*bm .RowStride +_ce ];};}else {_ed <<=1;};if _ddd ==7{_ff =0;if _ce < bm .RowStride {_ff =bm .Data [_gbf *bm .RowStride +_ce ];};}else {_ff <<=1;};_ga &=31;_gag &=127;_bfb &=15;};};return nil ;};func (_cef *Encoder )lBlock (){if _cef ._e >=0{_cef .emit ();};_cef ._e ++;_cef ._gb =uint8 (_cef ._fe >>19);_cef ._fe &=0x7ffff;_cef ._ae =8;};func (_fdce *Encoder )encodeIAID (_gea ,_afce int )error {if _fdce ._bf ==nil {_fdce ._bf =_fgc (1<<uint (_gea ));};_bbd :=uint32 (1<<uint32 (_gea +1))-1;_afce <<=uint (32-_gea );_ceb :=uint32 (1);for _gbc :=0;_gbc < _gea ;_gbc ++{_ee :=_ceb &_bbd ;_adf :=uint8 ((uint32 (_afce )&0x80000000)>>31);if _eed :=_fdce .encodeBit (_fdce ._bf ,_ee ,_adf );_eed !=nil {return _eed ;};_ceb =(_ceb <<1)|uint32 (_adf );_afce <<=1;};return nil ;};func (_efe *Encoder )EncodeIAID (symbolCodeLength ,value int )(_edb error ){_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _edb =_efe .encodeIAID (symbolCodeLength ,value );_edb !=nil {return _f .Wrap (_edb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gg *Encoder )Final (){_gg .flush ()};func (_aa *Encoder )DataSize ()int {return _aa .dataSize ()};func (_cdf *Encoder )rBlock (){if _cdf ._e >=0{_cdf .emit ();};_cdf ._e ++;_cdf ._gb =uint8 (_cdf ._fe >>20);_cdf ._fe &=0xfffff;_cdf ._ae =7;};func New ()*Encoder {_cc :=&Encoder {};_cc .Init ();return _cc };var _gf =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_dcb *Encoder )EncodeInteger (proc Class ,value int )(_cgd error ){_gc .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _cgd =_dcb .encodeInteger (proc ,value );_cgd !=nil {return _f .Wrap (_cgd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type intEncRangeS struct{_db ,_gd int ;_gcc ,_b uint8 ;_dg uint16 ;_be uint8 ;};type Class int ;func (_dd *codingContext )mps (_ca uint32 )int {return int (_dd ._da [_ca ])};const _bge =0x9b25;func (_ac *codingContext )flipMps (_af uint32 ){_ac ._da [_af ]=1-_ac ._da [_af ]};const (_dda =65536;_eaf =20*1024;);type Encoder struct{_fe uint32 ;_bb uint16 ;_ae ,_gb uint8 ;_e int ;_ef int ;_ag [][]byte ;_eg []byte ;_bg int ;_gbd *codingContext ;_fec [13]*codingContext ;_bf *codingContext ;};type state struct{_fbe uint16 ;_cgf ,_dgc uint8 ;_bcb uint8 ;};func (_ea *Encoder )byteOut (){if _ea ._gb ==0xff{_ea .rBlock ();return ;};if _ea ._fe < 0x8000000{_ea .lBlock ();return ;};_ea ._gb ++;if _ea ._gb !=0xff{_ea .lBlock ();return ;};_ea ._fe &=0x7ffffff;_ea .rBlock ();};func (_cge *Encoder )Init (){_cge ._gbd =_fgc (_dda );_cge ._bb =0x8000;_cge ._fe =0;_cge ._ae =12;_cge ._e =-1;_cge ._gb =0;_cge ._bg =0;_cge ._eg =make ([]byte ,_eaf );for _ba :=0;_ba < len (_cge ._fec );_ba ++{_cge ._fec [_ba ]=_fgc (512);};_cge ._bf =nil ;};