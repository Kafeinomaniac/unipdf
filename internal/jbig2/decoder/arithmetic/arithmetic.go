//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_ca "fmt";_a "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_e "io";_ce "math";_b "strings";);func (_ff *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ff ._bf =1;var _ffg uint64 ;for _ffg =0;_ffg < codeLen ;_ffg ++{stats .SetIndex (int32 (_ff ._bf ));_efb ,_cf :=_ff .DecodeBit (stats );if _cf !=nil {return 0,_cf ;};_ff ._bf =(_ff ._bf <<1)|int64 (_efb );};_beg :=_ff ._bf -(1<<codeLen );return _beg ,nil ;};func New (r _g .StreamReader )(*Decoder ,error ){_ea :=&Decoder {_d :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _bc :=_ea .init ();_bc !=nil {return nil ,_bc ;};return _ea ,nil ;};func (_dcb *DecoderStats )toggleMps (){_dcb ._cde [_dcb ._dd ]^=1};func (_fc *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_fcf int ;_fce =_gc [stats .cx ()][0];_bea =int32 (stats .cx ()););defer func (){_fc ._f ++}();_fc ._ad -=_fce ;if (_fc ._cc >>16)< uint64 (_fce ){_fcf =_fc .lpsExchange (stats ,_bea ,_fce );if _cd :=_fc .renormalize ();_cd !=nil {return 0,_cd ;};}else {_fc ._cc -=uint64 (_fce )<<16;if (_fc ._ad &0x8000)==0{_fcf =_fc .mpsExchange (stats ,_bea );if _ed :=_fc .renormalize ();_ed !=nil {return 0,_ed ;};}else {_fcf =int (stats .getMps ());};};return _fcf ,nil ;};var (_gc =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_efbg *DecoderStats )Reset (){for _age :=0;_age < len (_efbg ._gafa );_age ++{_efbg ._gafa [_age ]=0;_efbg ._cde [_age ]=0;};};func (_bg *Decoder )init ()error {_bg ._db =_bg ._d .StreamPosition ();_dc ,_ge :=_bg ._d .ReadByte ();if _ge !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ge );return _ge ;};_bg ._da =_dc ;_bg ._cc =uint64 (_dc )<<16;if _ge =_bg .readByte ();_ge !=nil {return _ge ;};_bg ._cc <<=7;_bg ._be -=7;_bg ._ad =0x8000;_bg ._f ++;return nil ;};type DecoderStats struct{_dd int32 ;_dag int32 ;_gafa []byte ;_cde []byte ;};func (_edf *Decoder )mpsExchange (_fac *DecoderStats ,_ffe int32 )int {_beb :=_fac ._cde [_fac ._dd ];if _edf ._ad < _gc [_ffe ][0]{if _gc [_ffe ][3]==1{_fac .toggleMps ();};_fac .setEntry (int (_gc [_ffe ][2]));return int (1-_beb );};_fac .setEntry (int (_gc [_ffe ][1]));return int (_beb );};func (_caa *Decoder )renormalize ()error {for {if _caa ._be ==0{if _bfg :=_caa .readByte ();_bfg !=nil {return _bfg ;};};_caa ._ad <<=1;_caa ._cc <<=1;_caa ._be --;if (_caa ._ad &0x8000)!=0{break ;};};_caa ._cc &=0xffffffff;return nil ;};func (_de *DecoderStats )SetIndex (index int32 ){_de ._dd =index };func (_gd *DecoderStats )setEntry (_cff int ){_bd :=byte (_cff &0x7f);_gd ._gafa [_gd ._dd ]=_bd };func (_dae *DecoderStats )getMps ()byte {return _dae ._cde [_dae ._dd ]};func (_fdc *Decoder )lpsExchange (_fgf *DecoderStats ,_bgc int32 ,_egd uint32 )int {_ade :=_fgf .getMps ();if _fdc ._ad < _egd {_fgf .setEntry (int (_gc [_bgc ][1]));_fdc ._ad =_egd ;return int (_ade );};if _gc [_bgc ][3]==1{_fgf .toggleMps ();};_fgf .setEntry (int (_gc [_bgc ][2]));_fdc ._ad =_egd ;return int (1-_ade );};func (_ec *DecoderStats )Overwrite (dNew *DecoderStats ){for _bfe :=0;_bfe < len (_ec ._gafa );_bfe ++{_ec ._gafa [_bfe ]=dNew ._gafa [_bfe ];_ec ._cde [_bfe ]=dNew ._cde [_bfe ];};};func (_gg *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_cb ,_cag int32 ;_bfa ,_fg ,_fcg int ;_fcd error ;);if stats ==nil {stats =NewStats (512,1);};_gg ._bf =1;_fg ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};if _bfa ==1{_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};if _bfa ==1{_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};if _bfa ==1{_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};if _bfa ==1{_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};if _bfa ==1{_fcg =32;_cag =4436;}else {_fcg =12;_cag =340;};}else {_fcg =8;_cag =84;};}else {_fcg =6;_cag =20;};}else {_fcg =4;_cag =4;};}else {_fcg =2;_cag =0;};for _ef :=0;_ef < _fcg ;_ef ++{_bfa ,_fcd =_gg .decodeIntBit (stats );if _fcd !=nil {return 0,_fcd ;};_cb =(_cb <<1)|int32 (_bfa );};_cb +=_cag ;if _fg ==0{return _cb ,nil ;}else if _fg ==1&&_cb > 0{return -_cb ,nil ;};return _ce .MaxInt32 ,nil ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_d _g .StreamReader ;_da uint8 ;_cc uint64 ;_ad uint32 ;_bf int64 ;_be int32 ;_f int32 ;_db int64 ;};func (_ae *DecoderStats )cx ()byte {return _ae ._gafa [_ae ._dd ]};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_dd :index ,_dag :contextSize ,_gafa :make ([]byte ,contextSize ),_cde :make ([]byte ,contextSize )};};func (_fgc *DecoderStats )String ()string {_afc :=&_b .Builder {};_afc .WriteString (_ca .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_fgc ._gafa )));for _eb ,_gb :=range _fgc ._gafa {if _gb !=0{_afc .WriteString (_ca .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_eb ,_gb ));};};return _afc .String ();};func (_fd *Decoder )decodeIntBit (_dca *DecoderStats )(int ,error ){_dca .SetIndex (int32 (_fd ._bf ));_bb ,_edg :=_fd .DecodeBit (_dca );if _edg !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_edg );return _bb ,_edg ;};if _fd ._bf < 256{_fd ._bf =((_fd ._bf <<uint64 (1))|int64 (_bb ))&0x1ff;}else {_fd ._bf =(((_fd ._bf <<uint64 (1)|int64 (_bb ))&511)|256)&0x1ff;};return _bb ,nil ;};func (_faf *DecoderStats )Copy ()*DecoderStats {_afb :=&DecoderStats {_dag :_faf ._dag ,_gafa :make ([]byte ,_faf ._dag )};for _ag :=0;_ag < len (_faf ._gafa );_ag ++{_afb ._gafa [_ag ]=_faf ._gafa [_ag ];};return _afb ;};func (_bgg *Decoder )readByte ()error {if _bgg ._d .StreamPosition ()> _bgg ._db {if _ ,_cda :=_bgg ._d .Seek (-1,_e .SeekCurrent );_cda !=nil {return _cda ;};};_efe ,_ga :=_bgg ._d .ReadByte ();if _ga !=nil {return _ga ;};_bgg ._da =_efe ;if _bgg ._da ==0xFF{_eg ,_fa :=_bgg ._d .ReadByte ();if _fa !=nil {return _fa ;};if _eg > 0x8F{_bgg ._cc +=0xFF00;_bgg ._be =8;if _ ,_gaf :=_bgg ._d .Seek (-2,_e .SeekCurrent );_gaf !=nil {return _gaf ;};}else {_bgg ._cc +=uint64 (_eg )<<9;_bgg ._be =7;};}else {_efe ,_ga =_bgg ._d .ReadByte ();if _ga !=nil {return _ga ;};_bgg ._da =_efe ;_bgg ._cc +=uint64 (_bgg ._da )<<8;_bgg ._be =8;};_bgg ._cc &=0xFFFFFFFFFF;return nil ;};