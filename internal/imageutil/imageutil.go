//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_c "errors";_a "fmt";_de "github.com/unidoc/unipdf/v3/internal/bitwise";_gd "image";_f "image/color";_g "image/draw";_e "math";);var (Gray2Model =_f .ModelFunc (_dbbf );Gray4Model =_f .ModelFunc (_ebea );NRGBA16Model =_f .ModelFunc (_cea ););var _ Gray =&Gray2 {};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func _dbbf (_fbgd _f .Color )_f .Color {_afgc :=_f .GrayModel .Convert (_fbgd ).(_f .Gray );return _edad (_afgc );};func (_faeg *Gray16 )Histogram ()(_ece [256]int ){for _ddg :=0;_ddg < _faeg .Width ;_ddg ++{for _cba :=0;_cba < _faeg .Height ;_cba ++{_ece [_faeg .GrayAt (_ddg ,_cba ).Y ]++;};};return _ece ;};func (_fdag *Monochrome )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray1BPC (x ,y ,_fdag .BytesPerLine ,_fdag .Data ,_fdag .Decode );};func (_adec *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_adec .copy ()}};func _afa (_afb RGBA ,_fg CMYK ,_gdg _gd .Rectangle ){for _ec :=0;_ec < _gdg .Max .X ;_ec ++{for _fa :=0;_fa < _gdg .Max .Y ;_fa ++{_gbe :=_afb .RGBAAt (_ec ,_fa );_fg .SetCMYK (_ec ,_fa ,_bbg (_gbe ));};};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_f .CMYK ,error ){_bd :=4*(y *width +x );if _bd +3>=len (data ){return _f .CMYK {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_bd ]&0xff;M :=data [_bd +1]&0xff;Y :=data [_bd +2]&0xff;K :=data [_bd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _f .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};type Gray interface{GrayAt (_bcd ,_ba int )_f .Gray ;SetGray (_gec ,_beff int ,_fea _f .Gray );};func _fgef (_fega []byte ,_fdce Image )error {_efcg :=true ;for _cacf :=0;_cacf < len (_fega );_cacf ++{if _fega [_cacf ]!=0xff{_efcg =false ;break ;};};if _efcg {switch _eeg :=_fdce .(type ){case *NRGBA32 :_eeg .Alpha =nil ;case *NRGBA64 :_eeg .Alpha =nil ;default:return _a .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fdce );};};return nil ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};type Gray16 struct{ImageBase };func _abbg (_gaac NRGBA ,_fde Gray ,_aefc _gd .Rectangle ){for _ecgc :=0;_ecgc < _aefc .Max .X ;_ecgc ++{for _abgg :=0;_abgg < _aefc .Max .Y ;_abgg ++{_adf :=_edc (_gaac .NRGBAAt (_ecgc ,_abgg ));_fde .SetGray (_ecgc ,_abgg ,_adf );};};};func (_eab *Gray4 )setGray (_aee int ,_egfg int ,_bag _f .Gray ){_cec :=_egfg *_eab .BytesPerLine ;_dedb :=_cec +(_aee >>1);if _dedb >=len (_eab .Data ){return ;};_ged :=_bag .Y >>4;_eab .Data [_dedb ]=(_eab .Data [_dedb ]&(^(0xf0>>uint (4*(_aee &1)))))|(_ged <<uint (4-4*(_aee &1)));};var _ Image =&NRGBA32 {};func _cgd (_egba int ,_bdegc int )error {return _a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_egba ,_bdegc );};func (_adcb *Gray16 )ColorModel ()_f .Model {return _f .Gray16Model };func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_fdga *NRGBA32 )Set (x ,y int ,c _f .Color ){_dfdag :=y *_fdga .Width +x ;_abge :=3*_dfdag ;if _abge +2>=len (_fdga .Data ){return ;};_gffc :=_f .NRGBAModel .Convert (c ).(_f .NRGBA );_fdga .setRGBA (_dfdag ,_gffc );};func (_gffd *NRGBA32 )setRGBA (_cfee int ,_gabd _f .NRGBA ){_dcfc :=3*_cfee ;_gffd .Data [_dcfc ]=_gabd .R ;_gffd .Data [_dcfc +1]=_gabd .G ;_gffd .Data [_dcfc +2]=_gabd .B ;if _cfee < len (_gffd .Alpha ){_gffd .Alpha [_cfee ]=_gabd .A ;};};var _ Gray =&Monochrome {};func _baed (_faae *_gd .Gray ,_egbg uint8 )*_gd .Gray {_fcbb :=_faae .Bounds ();_bcge :=_gd .NewGray (_fcbb );for _gdbe :=0;_gdbe < _fcbb .Dx ();_gdbe ++{for _fgeff :=0;_fgeff < _fcbb .Dy ();_fgeff ++{_daac :=_faae .GrayAt (_gdbe ,_fgeff );_bcge .SetGray (_gdbe ,_fgeff ,_f .Gray {Y :_bbce (_daac .Y ,_egbg )});};};return _bcge ;};func _fda (_fac _f .RGBA )_f .Gray {_afab :=(19595*uint32 (_fac .R )+38470*uint32 (_fac .G )+7471*uint32 (_fac .B )+1<<7)>>16;return _f .Gray {Y :uint8 (_afab )};};var _ NRGBA =&NRGBA16 {};func (_eacc *Gray2 )GrayAt (x ,y int )_f .Gray {_geg ,_ :=ColorAtGray2BPC (x ,y ,_eacc .BytesPerLine ,_eacc .Data ,_eacc .Decode );return _geg ;};func _abga (_cccf _gd .Image )(Image ,error ){if _cfdgc ,_dfda :=_cccf .(*NRGBA16 );_dfda {return _cfdgc .Copy (),nil ;};_gded :=_cccf .Bounds ();_fdged ,_fffc :=NewImage (_gded .Max .X ,_gded .Max .Y ,4,3,nil ,nil ,nil );if _fffc !=nil {return nil ,_fffc ;};_aece (_cccf ,_fdged ,_gded );return _fdged ,nil ;};var _ _gd .Image =&NRGBA64 {};func (_cga *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_cga .copy ()}};func (_ffa monochromeModel )Convert (c _f .Color )_f .Color {_agf :=_f .GrayModel .Convert (c ).(_f .Gray );return _daee (_agf ,_ffa );};func (_cf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_cf .copy ()}};func (_ef *CMYK32 )CMYKAt (x ,y int )_f .CMYK {_gg ,_ :=ColorAtCMYK (x ,y ,_ef .Width ,_ef .Data ,_ef .Decode );return _gg ;};func (_fabe *NRGBA32 )NRGBAAt (x ,y int )_f .NRGBA {_fgadc ,_ :=ColorAtNRGBA32 (x ,y ,_fabe .Width ,_fabe .Data ,_fabe .Alpha ,_fabe .Decode );return _fgadc ;};func (_cfbg *Gray4 )Histogram ()(_beb [256]int ){for _fcfa :=0;_fcfa < _cfbg .Width ;_fcfa ++{for _egf :=0;_egf < _cfbg .Height ;_egf ++{_beb [_cfbg .GrayAt (_fcfa ,_egf ).Y ]++;};};return _beb ;};func (_cdb *Gray8 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray8BPC (x ,y ,_cdb .BytesPerLine ,_cdb .Data ,_cdb .Decode );};func (_fbcc *NRGBA32 )Validate ()error {if len (_fbcc .Data )!=3*_fbcc .Width *_fbcc .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _daee (_ebe _f .Gray ,_dca monochromeModel )_f .Gray {if _ebe .Y > uint8 (_dca ){return _f .Gray {Y :_e .MaxUint8 };};return _f .Gray {};};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_acd *Gray4 )Validate ()error {if len (_acd .Data )!=_acd .Height *_acd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dfad *Gray4 )Set (x ,y int ,c _f .Color ){if x >=_dfad .Width ||y >=_dfad .Height {return ;};_dgega :=Gray4Model .Convert (c ).(_f .Gray );_dfad .setGray (x ,y ,_dgega );};func (_ccb *Monochrome )setGray (_aac int ,_fgg _f .Gray ,_cad int ){if _fgg .Y ==0{_ccb .clearBit (_cad ,_aac );}else {_ccb .setBit (_cad ,_aac );};};func init (){_fff ()};func _bcg (_aad _f .RGBA )_f .NRGBA {switch _aad .A {case 0xff:return _f .NRGBA {R :_aad .R ,G :_aad .G ,B :_aad .B ,A :0xff};case 0x00:return _f .NRGBA {};default:_bcc ,_faa ,_ecg ,_aeb :=_aad .RGBA ();_bcc =(_bcc *0xffff)/_aeb ;_faa =(_faa *0xffff)/_aeb ;_ecg =(_ecg *0xffff)/_aeb ;return _f .NRGBA {R :uint8 (_bcc >>8),G :uint8 (_faa >>8),B :uint8 (_ecg >>8),A :uint8 (_aeb >>8)};};};func GrayHistogram (g Gray )(_cfeg [256]int ){switch _gfe :=g .(type ){case Histogramer :return _gfe .Histogram ();case _gd .Image :_ceb :=_gfe .Bounds ();for _daedc :=0;_daedc < _ceb .Max .X ;_daedc ++{for _acg :=0;_acg < _ceb .Max .Y ;_acg ++{_cfeg [g .GrayAt (_daedc ,_acg ).Y ]++;};};return _cfeg ;default:return [256]int {};};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _cfdb ,_bgba ,_defa ,_ffaa int ;for _afeeg :=0;_afeeg < len (histogram );_afeeg ++{if histogram [_afeeg ]> 0{_cfdb =_afeeg ;break ;};};if _cfdb > 0{_cfdb --;};for _cbge :=255;_cbge > 0;_cbge --{if histogram [_cbge ]> 0{_ffaa =_cbge ;break ;};};if _ffaa < 255{_ffaa ++;};for _cbeg :=0;_cbeg < 256;_cbeg ++{if histogram [_cbeg ]> _bgba {_defa =_cbeg ;_bgba =histogram [_cbeg ];};};var _ede bool ;if (_defa -_cfdb )< (_ffaa -_defa ){_ede =true ;var _dfcd int ;_bcea :=255;for _dfcd < _bcea {_fafdg :=histogram [_dfcd ];histogram [_dfcd ]=histogram [_bcea ];histogram [_bcea ]=_fafdg ;_dfcd ++;_bcea --;};_cfdb =255-_ffaa ;_defa =255-_defa ;};if _cfdb ==_defa {return uint8 (_cfdb );};_eeba :=float64 (histogram [_defa ]);_geae :=float64 (_cfdb -_defa );_ebcc :=_e .Sqrt (_eeba *_eeba +_geae *_geae );_eeba /=_ebcc ;_geae /=_ebcc ;_ebcc =_eeba *float64 (_cfdb )+_geae *float64 (histogram [_cfdb ]);_bffe :=_cfdb ;var _adfe float64 ;for _aab :=_cfdb +1;_aab <=_defa ;_aab ++{_aggf :=_eeba *float64 (_aab )+_geae *float64 (histogram [_aab ])-_ebcc ;if _aggf > _adfe {_bffe =_aab ;_adfe =_aggf ;};};_bffe --;if _ede {var _bgcg int ;_afbc :=255;for _bgcg < _afbc {_abdc :=histogram [_bgcg ];histogram [_bgcg ]=histogram [_afbc ];histogram [_afbc ]=_abdc ;_bgcg ++;_afbc --;};return uint8 (255-_bffe );};return uint8 (_bffe );};var (MonochromeConverter =ConverterFunc (_gf );Gray2Converter =ConverterFunc (_efg );Gray4Converter =ConverterFunc (_dfag );GrayConverter =ConverterFunc (_bdab );Gray16Converter =ConverterFunc (_gbeb );NRGBA16Converter =ConverterFunc (_abga );NRGBAConverter =ConverterFunc (_cgf );NRGBA64Converter =ConverterFunc (_gfce );CMYKConverter =ConverterFunc (_dc ););var _ _gd .Image =&Gray2 {};func (_dedbc *NRGBA64 )SetNRGBA64 (x ,y int ,c _f .NRGBA64 ){_egfa :=(y *_dedbc .Width +x )*2;_abae :=_egfa *3;if _abae +5>=len (_dedbc .Data ){return ;};_dedbc .setNRGBA64 (_abae ,c ,_egfa );};func (_acdf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_acdf .copy ()}};func (_adg *Monochrome )Set (x ,y int ,c _f .Color ){_bbc :=y *_adg .BytesPerLine +x >>3;if _bbc > len (_adg .Data )-1{return ;};_fae :=_adg .ColorModel ().Convert (c ).(_f .Gray );_adg .setGray (x ,_fae ,_bbc );};func _bbeb (_cacb _gd .Image ,_fbcf int )(_gd .Rectangle ,bool ,[]byte ){_bfbc :=_cacb .Bounds ();var (_ccag bool ;_ega []byte ;);switch _cfgg :=_cacb .(type ){case SMasker :_ccag =_cfgg .HasAlpha ();case NRGBA ,RGBA ,*_gd .RGBA64 ,nrgba64 ,*_gd .NYCbCrA :_ega =make ([]byte ,_bfbc .Max .X *_bfbc .Max .Y *_fbcf );};return _bfbc ,_ccag ,_ega ;};func (_be *CMYK32 )SetCMYK (x ,y int ,c _f .CMYK ){_bb :=4*(y *_be .Width +x );if _bb +3>=len (_be .Data ){return ;};_be .Data [_bb ]=c .C ;_be .Data [_bb +1]=c .M ;_be .Data [_bb +2]=c .Y ;_be .Data [_bb +3]=c .K ;};func _gbeb (_agbd _gd .Image )(Image ,error ){if _fabf ,_gcab :=_agbd .(*Gray16 );_gcab {return _fabf .Copy (),nil ;};_edg :=_agbd .Bounds ();_agfa ,_ggb :=NewImage (_edg .Max .X ,_edg .Max .Y ,16,1,nil ,nil ,nil );if _ggb !=nil {return nil ,_ggb ;};_cagg (_agbd ,_agfa ,_edg );return _agfa ,nil ;};type NRGBA16 struct{ImageBase };func (_ffad *NRGBA64 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_ffad .Width ,Y :_ffad .Height }};};func _bddc (_abbgd *_gd .Gray )bool {for _eef :=0;_eef < len (_abbgd .Pix );_eef ++{if !_cecd (_abbgd .Pix [_eef ]){return false ;};};return true ;};var _ Image =&Gray2 {};type nrgba64 interface{NRGBA64At (_dcaa ,_eea int )_f .NRGBA64 ;SetNRGBA64 (_afec ,_gbc int ,_bff _f .NRGBA64 );};func (_egg *Gray8 )Base ()*ImageBase {return &_egg .ImageBase };func _eff (_bbcf _f .Gray )_f .Gray {_bbcf .Y >>=4;_bbcf .Y |=_bbcf .Y <<4;return _bbcf };func _gfce (_fdec _gd .Image )(Image ,error ){if _dbd ,_deb :=_fdec .(*NRGBA64 );_deb {return _dbd .Copy (),nil ;};_cfgf ,_abeg ,_cccb :=_bbeb (_fdec ,2);_efae ,_geaa :=NewImage (_cfgf .Max .X ,_cfgf .Max .Y ,16,3,nil ,_cccb ,nil );if _geaa !=nil {return nil ,_geaa ;};_dgf (_fdec ,_efae ,_cfgf );if len (_cccb )!=0&&!_abeg {if _aegd :=_fgef (_cccb ,_efae );_aegd !=nil {return nil ,_aegd ;};};return _efae ,nil ;};func (_fcbf *NRGBA32 )At (x ,y int )_f .Color {_dcfb ,_ :=_fcbf .ColorAt (x ,y );return _dcfb };func (_afcd *NRGBA64 )Set (x ,y int ,c _f .Color ){_gdfg :=(y *_afcd .Width +x )*2;_ffff :=_gdfg *3;if _ffff +5>=len (_afcd .Data ){return ;};_cbga :=_f .NRGBA64Model .Convert (c ).(_f .NRGBA64 );_afcd .setNRGBA64 (_ffff ,_cbga ,_gdfg );};func (_cbfa *Gray2 )At (x ,y int )_f .Color {_ddab ,_ :=_cbfa .ColorAt (x ,y );return _ddab };func (_df *CMYK32 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_df .Width ,Y :_df .Height }};};type Histogramer interface{Histogram ()[256]int ;};func _fdd (_bdef _f .NRGBA64 )_f .NRGBA {return _f .NRGBA {R :uint8 (_bdef .R >>8),G :uint8 (_bdef .G >>8),B :uint8 (_bdef .B >>8),A :uint8 (_bdef .A >>8)};};func (_fdba *Gray16 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_fdba .Width ,Y :_fdba .Height }};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_gbec *Gray4 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray4BPC (x ,y ,_gbec .BytesPerLine ,_gbec .Data ,_gbec .Decode );};var ErrInvalidImage =_c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func (_bga *NRGBA16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA16 (x ,y ,_bga .Width ,_bga .BytesPerLine ,_bga .Data ,_bga .Alpha ,_bga .Decode );};type Gray8 struct{ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _e .Abs (xmax -xmin )< 0.000001{return ymin ;};_afcb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _afcb ;};func (_ebcf *Gray16 )Set (x ,y int ,c _f .Color ){_bdeb :=(y *_ebcf .BytesPerLine /2+x )*2;if _bdeb +1>=len (_ebcf .Data ){return ;};_fab :=_f .Gray16Model .Convert (c ).(_f .Gray16 );_ebcf .Data [_bdeb ],_ebcf .Data [_bdeb +1]=uint8 (_fab .Y >>8),uint8 (_fab .Y &0xff);};func (_efc *Monochrome )setBit (_fbdd ,_cfba int ){_efc .Data [_fbdd ]|=0x80>>uint (_cfba &7)};func _bdge (_ecef *_gd .NYCbCrA ,_bgb NRGBA ,_agag _gd .Rectangle ){for _bfff :=0;_bfff < _agag .Max .X ;_bfff ++{for _bccg :=0;_bccg < _agag .Max .Y ;_bccg ++{_fba :=_ecef .NYCbCrAAt (_bfff ,_bccg );_bgb .SetNRGBA (_bfff ,_bccg ,_efe (_fba ));};};};func _cea (_gbae _f .Color )_f .Color {_bagf :=_f .NRGBAModel .Convert (_gbae ).(_f .NRGBA );return _ccbf (_bagf );};func ConverterFunc (converterFunc func (_fd _gd .Image )(Image ,error ))ColorConverter {return colorConverter {_cc :converterFunc };};var _ _gd .Image =&NRGBA32 {};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray16 ,error ){_edca :=(y *bytesPerLine /2+x )*2;if _edca +1>=len (data ){return _f .Gray16 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bdbf :=uint16 (data [_edca ])<<8|uint16 (data [_edca +1]);if len (decode )==2{_bdbf =uint16 (uint64 (LinearInterpolate (float64 (_bdbf ),0,65535,decode [0],decode [1])));};return _f .Gray16 {Y :_bdbf },nil ;};func (_acff *Gray4 )GrayAt (x ,y int )_f .Gray {_bbe ,_ :=ColorAtGray4BPC (x ,y ,_acff .BytesPerLine ,_acff .Data ,_acff .Decode );return _bbe ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fcc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _efce Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_efce =&Monochrome {ImageBase :_fcc ,ModelThreshold :0x0f};case 2:_efce =&Gray2 {ImageBase :_fcc };case 4:_efce =&Gray4 {ImageBase :_fcc };case 8:_efce =&Gray8 {ImageBase :_fcc };case 16:_efce =&Gray16 {ImageBase :_fcc };};case 3:switch bitsPerComponent {case 4:_efce =&NRGBA16 {ImageBase :_fcc };case 8:_efce =&NRGBA32 {ImageBase :_fcc };case 16:_efce =&NRGBA64 {ImageBase :_fcc };};case 4:_efce =&CMYK32 {ImageBase :_fcc };};if _efce ==nil {return nil ,ErrInvalidImage ;};return _efce ,nil ;};func IsGrayImgBlackAndWhite (i *_gd .Gray )bool {return _bddc (i )};func (_gae *Gray2 )Histogram ()(_ggcc [256]int ){for _dgeg :=0;_dgeg < _gae .Width ;_dgeg ++{for _cfdg :=0;_cfdg < _gae .Height ;_cfdg ++{_ggcc [_gae .GrayAt (_dgeg ,_cfdg ).Y ]++;};};return _ggcc ;};func _aa (_cag Gray ,_aag CMYK ,_gdab _gd .Rectangle ){for _ge :=0;_ge < _gdab .Max .X ;_ge ++{for _fbg :=0;_fbg < _gdab .Max .Y ;_fbg ++{_ac :=_cag .GrayAt (_ge ,_fbg );_aag .SetCMYK (_ge ,_fbg ,_dfc (_ac ));};};};var _ Image =&Gray4 {};func (_eaca *NRGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };var _ Gray =&Gray16 {};func (_adeb *Gray4 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_adeb .Width ,Y :_adeb .Height }};};func (_aed *Gray4 )Base ()*ImageBase {return &_aed .ImageBase };type Gray2 struct{ImageBase };func MonochromeModel (threshold uint8 )_f .Model {return monochromeModel (threshold )};func (_agb *Gray2 )Set (x ,y int ,c _f .Color ){if x >=_agb .Width ||y >=_agb .Height {return ;};_fcf :=Gray2Model .Convert (c ).(_f .Gray );_feg :=y *_agb .BytesPerLine ;_bfc :=_feg +(x >>2);_aaa :=_fcf .Y >>6;_agb .Data [_bfc ]=(_agb .Data [_bfc ]&(^(0xc0>>uint (2*((x )&3)))))|(_aaa <<uint (6-2*(x &3)));};func (_ed *CMYK32 )Validate ()error {if len (_ed .Data )!=4*_ed .Width *_ed .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_cca *monochromeThresholdConverter )Convert (img _gd .Image )(Image ,error ){if _bdb ,_cee :=img .(*Monochrome );_cee {return _bdb .Copy (),nil ;};_dge :=img .Bounds ();_gge ,_ff :=NewImage (_dge .Max .X ,_dge .Max .Y ,1,1,nil ,nil ,nil );if _ff !=nil {return nil ,_ff ;};_gge .(*Monochrome ).ModelThreshold =_cca .Threshold ;for _afee :=0;_afee < _dge .Max .X ;_afee ++{for _ee :=0;_ee < _dge .Max .Y ;_ee ++{_cgg :=img .At (_afee ,_ee );_gge .Set (_afee ,_ee ,_cgg );};};return _gge ,nil ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_cacg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_cacg .Data =make ([]byte ,height *_cacg .BytesPerLine );};return _cacg ;};type monochromeModel uint8 ;var _ _gd .Image =&Gray4 {};func (_aae *ImageBase )MakeAlpha (){_aae .newAlpha ()};func _edc (_ae _f .NRGBA )_f .Gray {_cbb ,_ecc ,_ce ,_ :=_ae .RGBA ();_aca :=(19595*_cbb +38470*_ecc +7471*_ce +1<<15)>>24;return _f .Gray {Y :uint8 (_aca )};};func (_bbd *Gray16 )At (x ,y int )_f .Color {_fafd ,_ :=_bbd .ColorAt (x ,y );return _fafd };func _ffgbc (_ggfa nrgba64 ,_cgdg NRGBA ,_cccc _gd .Rectangle ){for _ddbb :=0;_ddbb < _cccc .Max .X ;_ddbb ++{for _cadf :=0;_cadf < _cccc .Max .Y ;_cadf ++{_bbgc :=_ggfa .NRGBA64At (_ddbb ,_cadf );_cgdg .SetNRGBA (_ddbb ,_cadf ,_fdd (_bbgc ));};};};func (_afbb *NRGBA16 )NRGBAAt (x ,y int )_f .NRGBA {_daf ,_ :=ColorAtNRGBA16 (x ,y ,_afbb .Width ,_afbb .BytesPerLine ,_afbb .Data ,_afbb .Alpha ,_afbb .Decode );return _daf ;};func (_gcdb *Gray16 )Validate ()error {if len (_gcdb .Data )!=_gcdb .Height *_gcdb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gegde (_ddee RGBA ,_gfca NRGBA ,_fgd _gd .Rectangle ){for _cfed :=0;_cfed < _fgd .Max .X ;_cfed ++{for _gbcf :=0;_gbcf < _fgd .Max .Y ;_gbcf ++{_abdfg :=_ddee .RGBAAt (_cfed ,_gbcf );_gfca .SetNRGBA (_cfed ,_gbcf ,_bcg (_abdfg ));};};};func _ffdd (_baee Gray ,_dab NRGBA ,_cae _gd .Rectangle ){for _gegd :=0;_gegd < _cae .Max .X ;_gegd ++{for _ggga :=0;_ggga < _cae .Max .Y ;_ggga ++{_edagg :=_baee .GrayAt (_gegd ,_ggga );_dab .SetNRGBA (_gegd ,_ggga ,_cgb (_edagg ));};};};func (_ade *Monochrome )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_ade .Width ,Y :_ade .Height }};};var _ Gray =&Gray8 {};var _ _gd .Image =&Gray8 {};func _edad (_aefe _f .Gray )_f .Gray {_cbea :=_aefe .Y >>6;_cbea |=_cbea <<2;_aefe .Y =_cbea |_cbea <<4;return _aefe ;};func (_ada *Gray2 )Validate ()error {if len (_ada .Data )!=_ada .Height *_ada .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_caa *NRGBA64 )At (x ,y int )_f .Color {_fced ,_ :=_caa .ColorAt (x ,y );return _fced };func (_aeca *Monochrome )At (x ,y int )_f .Color {_gca ,_ :=_aeca .ColorAt (x ,y );return _gca };func _ccbf (_dcda _f .NRGBA )_f .NRGBA {_dcda .R =_dcda .R >>4|(_dcda .R >>4)<<4;_dcda .G =_dcda .G >>4|(_dcda .G >>4)<<4;_dcda .B =_dcda .B >>4|(_dcda .B >>4)<<4;return _dcda ;};func _efg (_adc _gd .Image )(Image ,error ){if _gfdd ,_egeg :=_adc .(*Gray2 );_egeg {return _gfdd .Copy (),nil ;};_fbdg :=_adc .Bounds ();_aeba ,_gaa :=NewImage (_fbdg .Max .X ,_fbdg .Max .Y ,2,1,nil ,nil ,nil );if _gaa !=nil {return nil ,_gaa ;};_cagg (_adc ,_aeba ,_fbdg );return _aeba ,nil ;};func (_dcf *Gray16 )Base ()*ImageBase {return &_dcf .ImageBase };var _ NRGBA =&NRGBA32 {};func (_fb *CMYK32 )At (x ,y int )_f .Color {_db ,_ :=_fb .ColorAt (x ,y );return _db };func ImgToGray (i _gd .Image )*_gd .Gray {if _agef ,_dgef :=i .(*_gd .Gray );_dgef {return _agef ;};_cab :=i .Bounds ();_ebb :=_gd .NewGray (_cab );for _eaeg :=0;_eaeg < _cab .Max .X ;_eaeg ++{for _bbgg :=0;_bbgg < _cab .Max .Y ;_bbgg ++{_cbef :=i .At (_eaeg ,_bbgg );_ebb .Set (_eaeg ,_bbgg ,_cbef );};};return _ebb ;};func _ded (_da ,_afc CMYK ,_bce _gd .Rectangle ){for _gdd :=0;_gdd < _bce .Max .X ;_gdd ++{for _ca :=0;_ca < _bce .Max .Y ;_ca ++{_afc .SetCMYK (_gdd ,_ca ,_da .CMYKAt (_gdd ,_ca ));};};};func (_aedg *NRGBA64 )setNRGBA64 (_aaca int ,_ccfd _f .NRGBA64 ,_gfc int ){_aedg .Data [_aaca ]=uint8 (_ccfd .R >>8);_aedg .Data [_aaca +1]=uint8 (_ccfd .R &0xff);_aedg .Data [_aaca +2]=uint8 (_ccfd .G >>8);_aedg .Data [_aaca +3]=uint8 (_ccfd .G &0xff);_aedg .Data [_aaca +4]=uint8 (_ccfd .B >>8);_aedg .Data [_aaca +5]=uint8 (_ccfd .B &0xff);if _gfc +1< len (_aedg .Alpha ){_aedg .Alpha [_gfc ]=uint8 (_ccfd .A >>8);_aedg .Alpha [_gfc +1]=uint8 (_ccfd .A &0xff);};};func (_ecdc *NRGBA32 )Base ()*ImageBase {return &_ecdc .ImageBase };func (_eed *Gray8 )ColorModel ()_f .Model {return _f .GrayModel };func (_geb *Gray16 )GrayAt (x ,y int )_f .Gray {_dbbcf ,_ :=_geb .ColorAt (x ,y );return _f .Gray {Y :uint8 (_dbbcf .(_f .Gray16 ).Y >>8)};};func (_cef *Gray2 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray2BPC (x ,y ,_cef .BytesPerLine ,_cef .Data ,_cef .Decode );};func (_gfda *Gray8 )At (x ,y int )_f .Color {_fefa ,_ :=_gfda .ColorAt (x ,y );return _fefa };func _dce (_fbb _f .NRGBA )_f .CMYK {_dga ,_aec ,_ace ,_ :=_fbb .RGBA ();_ecb ,_ggd ,_ebg ,_cfe :=_f .RGBToCMYK (uint8 (_dga >>8),uint8 (_aec >>8),uint8 (_ace >>8));return _f .CMYK {C :_ecb ,M :_ggd ,Y :_ebg ,K :_cfe };};func (_bba *Monochrome )clearBit (_baf ,_cgbc int ){_bba .Data [_baf ]&=^(0x80>>uint (_cgbc &7))};func (_fed *Gray4 )SetGray (x ,y int ,g _f .Gray ){if x >=_fed .Width ||y >=_fed .Height {return ;};g =_eff (g );_fed .setGray (x ,y ,g );};func (_bcf *NRGBA16 )Base ()*ImageBase {return &_bcf .ImageBase };func (_edfa *Gray8 )Validate ()error {if len (_edfa .Data )!=_edfa .Height *_edfa .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_eee :=y *bytesPerLine +x *3/2;if _eee +1>=len (data ){return _f .NRGBA {},_cgd (x ,y );};const (_fdeg =0xf;_cdg =uint8 (0xff););_bdg :=_cdg ;if alpha !=nil {_edage :=y *BytesPerLine (width ,4,1);if _edage < len (alpha ){if x %2==0{_bdg =(alpha [_edage ]>>uint (4))&_fdeg ;}else {_bdg =alpha [_edage ]&_fdeg ;};_bdg |=_bdg <<4;};};var _cdce ,_ecdb ,_beffg uint8 ;if x *3%2==0{_cdce =(data [_eee ]>>uint (4))&_fdeg ;_ecdb =data [_eee ]&_fdeg ;_beffg =(data [_eee +1]>>uint (4))&_fdeg ;}else {_cdce =data [_eee ]&_fdeg ;_ecdb =(data [_eee +1]>>uint (4))&_fdeg ;_beffg =data [_eee +1]&_fdeg ;};if len (decode )==6{_cdce =uint8 (uint32 (LinearInterpolate (float64 (_cdce ),0,15,decode [0],decode [1]))&0xf);_ecdb =uint8 (uint32 (LinearInterpolate (float64 (_ecdb ),0,15,decode [2],decode [3]))&0xf);_beffg =uint8 (uint32 (LinearInterpolate (float64 (_beffg ),0,15,decode [4],decode [5]))&0xf);};return _f .NRGBA {R :(_cdce <<4)|(_cdce &0xf),G :(_ecdb <<4)|(_ecdb &0xf),B :(_beffg <<4)|(_beffg &0xf),A :_bdg },nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cfdc :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _cfdc ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_egbe :=width *colorComponents *bitsPerComponent ;_cdba :=_cfdc *8;_bgf :=8-(_cdba -_egbe );_dba :=_de .NewReader (data );_fgad :=_cfdc -1;_fag :=make ([]byte ,_fgad );_fdff :=make ([]byte ,height *_cfdc );_dfe :=_de .NewWriterMSB (_fdff );var _dag uint64 ;var _ccg error ;for _ccf :=0;_ccf < height ;_ccf ++{_ ,_ccg =_dba .Read (_fag );if _ccg !=nil {return nil ,_ccg ;};_ ,_ccg =_dfe .Write (_fag );if _ccg !=nil {return nil ,_ccg ;};_dag ,_ccg =_dba .ReadBits (byte (_bgf ));if _ccg !=nil {return nil ,_ccg ;};_ ,_ccg =_dfe .WriteBits (_dag ,_bgf );if _ccg !=nil {return nil ,_ccg ;};_dfe .FinishByte ();};return _fdff ,nil ;};func (_bfaf *NRGBA16 )Set (x ,y int ,c _f .Color ){_ceea :=y *_bfaf .BytesPerLine +x *3/2;if _ceea +1>=len (_bfaf .Data ){return ;};_gdgad :=NRGBA16Model .Convert (c ).(_f .NRGBA );_bfaf .setNRGBA (x ,y ,_ceea ,_gdgad );};func (_bcb *NRGBA16 )SetNRGBA (x ,y int ,c _f .NRGBA ){_bafb :=y *_bcb .BytesPerLine +x *3/2;if _bafb +1>=len (_bcb .Data ){return ;};c =_ccbf (c );_bcb .setNRGBA (x ,y ,_bafb ,c );};var _ Image =&Monochrome {};func (_faea *ImageBase )Pix ()[]byte {return _faea .Data };func (_facc *NRGBA32 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_facc .Width ,Y :_facc .Height }};};func _fff (){for _bbgd :=0;_bbgd < 256;_bbgd ++{_fbe [_bbgd ]=uint8 (_bbgd &0x1)+(uint8 (_bbgd >>1)&0x1)+(uint8 (_bbgd >>2)&0x1)+(uint8 (_bbgd >>3)&0x1)+(uint8 (_bbgd >>4)&0x1)+(uint8 (_bbgd >>5)&0x1)+(uint8 (_bbgd >>6)&0x1)+(uint8 (_bbgd >>7)&0x1);};};func _cgf (_cdga _gd .Image )(Image ,error ){if _cff ,_abbf :=_cdga .(*NRGBA32 );_abbf {return _cff .Copy (),nil ;};_ceag ,_afaa ,_efcb :=_bbeb (_cdga ,1);_dea ,_cfg :=NewImage (_ceag .Max .X ,_ceag .Max .Y ,8,3,nil ,_efcb ,nil );if _cfg !=nil {return nil ,_cfg ;};_aece (_cdga ,_dea ,_ceag );if len (_efcb )!=0&&!_afaa {if _abf :=_fgef (_efcb ,_dea );_abf !=nil {return nil ,_abf ;};};return _dea ,nil ;};type NRGBA interface{NRGBAAt (_feag ,_bfa int )_f .NRGBA ;SetNRGBA (_cade ,_cegg int ,_fggb _f .NRGBA );};func (_ccbe *Gray4 )At (x ,y int )_f .Color {_fcda ,_ :=_ccbe .ColorAt (x ,y );return _fcda };var _ _gd .Image =&Monochrome {};func _dae (_cd _f .CMYK )_f .Gray {_age ,_eae ,_cbg :=_f .CMYKToRGB (_cd .C ,_cd .M ,_cd .Y ,_cd .K );_ddec :=(19595*uint32 (_age )+38470*uint32 (_eae )+7471*uint32 (_cbg )+1<<7)>>16;return _f .Gray {Y :uint8 (_ddec )};};func _dgf (_fabc _gd .Image ,_agfe Image ,_dfg _gd .Rectangle ){if _edce ,_fcbff :=_fabc .(SMasker );_fcbff &&_edce .HasAlpha (){_agfe .(SMasker ).MakeAlpha ();};_fe (_fabc ,_agfe ,_dfg );};type Image interface{_g .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_aaaag ,_fefe int )(_f .Color ,error );Validate ()error ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_bcde :=y *bytesPerLine +x >>3;if _bcde >=len (data ){return _f .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ccc :=data [_bcde ]>>uint (7-(x &7))&1;if len (decode )==2{_ccc =uint8 (LinearInterpolate (float64 (_ccc ),0.0,1.0,decode [0],decode [1]))&1;};return _f .Gray {Y :_ccc *255},nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_ced :=y *bytesPerLine +x >>2;if _ced >=len (data ){return _f .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_edd :=data [_ced ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_edd =uint8 (uint32 (LinearInterpolate (float64 (_edd ),0,3.0,decode [0],decode [1]))&3);};return _f .Gray {Y :_edd *85},nil ;};func (_ffbf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ffbf .copy ()}};func _cecd (_fbcfa uint8 )bool {if _fbcfa ==0||_fbcfa ==255{return true ;};return false ;};func (_cbfc *NRGBA16 )Validate ()error {if len (_cbfc .Data )!=3*_cbfc .Width *_cbfc .Height /2{return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_gff *Gray2 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_gff .Width ,Y :_gff .Height }};};func (_abad *NRGBA64 )Validate ()error {if len (_abad .Data )!=3*2*_abad .Width *_abad .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _abag (_bgd ,_gecc Gray ,_cbff _gd .Rectangle ){for _eeb :=0;_eeb < _cbff .Max .X ;_eeb ++{for _bea :=0;_bea < _cbff .Max .Y ;_bea ++{_gecc .SetGray (_eeb ,_bea ,_bgd .GrayAt (_eeb ,_bea ));};};};func (_gee *Gray8 )Histogram ()(_fedd [256]int ){for _ecde :=0;_ecde < len (_gee .Data );_ecde ++{_fedd [_gee .Data [_ecde ]]++;};return _fedd ;};func (_ffg *Monochrome )ColorModel ()_f .Model {return MonochromeModel (_ffg .ModelThreshold )};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func ImgToBinary (i _gd .Image ,threshold uint8 )*_gd .Gray {switch _ebgde :=i .(type ){case *_gd .Gray :if _bddc (_ebgde ){return _ebgde ;};return _baed (_ebgde ,threshold );case *_gd .Gray16 :return _ecgf (_ebgde ,threshold );default:return _bbfd (_ebgde ,threshold );};};func (_abda *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_abda .copy ()}};type NRGBA64 struct{ImageBase };func (_cgc *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cgc .copy ()}};func (_afe *CMYK32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtCMYK (x ,y ,_afe .Width ,_afe .Data ,_afe .Decode );};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_abc *NRGBA64 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA64 (x ,y ,_abc .Width ,_abc .Data ,_abc .Alpha ,_abc .Decode );};func (_cceg *NRGBA64 )Base ()*ImageBase {return &_cceg .ImageBase };var _fbe [256]uint8 ;func _efe (_agd _f .NYCbCrA )_f .NRGBA {_eda :=int32 (_agd .Y )*0x10101;_ceg :=int32 (_agd .Cb )-128;_bef :=int32 (_agd .Cr )-128;_dfa :=_eda +91881*_bef ;if uint32 (_dfa )&0xff000000==0{_dfa >>=8;}else {_dfa =^(_dfa >>31)&0xffff;};_aceb :=_eda -22554*_ceg -46802*_bef ;if uint32 (_aceb )&0xff000000==0{_aceb >>=8;}else {_aceb =^(_aceb >>31)&0xffff;};_edf :=_eda +116130*_ceg ;if uint32 (_edf )&0xff000000==0{_edf >>=8;}else {_edf =^(_edf >>31)&0xffff;};return _f .NRGBA {R :uint8 (_dfa >>8),G :uint8 (_aceb >>8),B :uint8 (_edf >>8),A :_agd .A };};func (_cbe *Gray2 )Base ()*ImageBase {return &_cbe .ImageBase };func _dc (_bc _gd .Image )(Image ,error ){if _dbb ,_cfd :=_bc .(*CMYK32 );_cfd {return _dbb .Copy (),nil ;};_gda :=_bc .Bounds ();_cg ,_dbbc :=NewImage (_gda .Max .X ,_gda .Max .Y ,8,4,nil ,nil ,nil );if _dbbc !=nil {return nil ,_dbbc ;};switch _ag :=_bc .(type ){case CMYK :_ded (_ag ,_cg .(CMYK ),_gda );case Gray :_aa (_ag ,_cg .(CMYK ),_gda );case NRGBA :_gcd (_ag ,_cg .(CMYK ),_gda );case RGBA :_afa (_ag ,_cg .(CMYK ),_gda );default:_fe (_bc ,_cg ,_gda );};return _cg ,nil ;};func _cagg (_egca _gd .Image ,_befe Image ,_ffge _gd .Rectangle ){switch _gac :=_egca .(type ){case Gray :_abag (_gac ,_befe .(Gray ),_ffge );case NRGBA :_abbg (_gac ,_befe .(Gray ),_ffge );case CMYK :_ecee (_gac ,_befe .(Gray ),_ffge );case RGBA :_efbe (_gac ,_befe .(Gray ),_ffge );default:_fe (_egca ,_befe .(Image ),_ffge );};};func (_bdeg *Monochrome )Histogram ()(_dgc [256]int ){for _ ,_eac :=range _bdeg .Data {_dgc [0xff]+=int (_fbe [_bdeg .Data [_eac ]]);};return _dgc ;};func (_edcd *ImageBase )HasAlpha ()bool {if _edcd .Alpha ==nil {return false ;};for _fgc :=range _edcd .Alpha {if _edcd .Alpha [_fgc ]!=0xff{return true ;};};return false ;};type CMYK interface{CMYKAt (_af ,_dd int )_f .CMYK ;SetCMYK (_eg ,_dde int ,_b _f .CMYK );};type Gray4 struct{ImageBase };type RGBA interface{RGBAAt (_beg ,_ecfe int )_f .RGBA ;SetRGBA (_bgg ,_aeed int ,_deg _f .RGBA );};func _fe (_dfd _gd .Image ,_gea Image ,_dg _gd .Rectangle ){for _efb :=0;_efb < _dg .Max .X ;_efb ++{for _ga :=0;_ga < _dg .Max .Y ;_ga ++{_cbf :=_dfd .At (_efb ,_ga );_gea .Set (_efb ,_ga ,_cbf );};};};func _egc (_ab _f .CMYK )_f .NRGBA {_cbbe ,_cfde ,_aef :=_f .CMYKToRGB (_ab .C ,_ab .M ,_ab .Y ,_ab .K );return _f .NRGBA {R :_cbbe ,G :_cfde ,B :_aef ,A :0xff};};func (_gb *CMYK32 )ColorModel ()_f .Model {return _f .CMYKModel };var _ Image =&NRGBA16 {};func (_edag *Gray8 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_edag .Width ,Y :_edag .Height }};};func (_aga *Monochrome )GrayAt (x ,y int )_f .Gray {_dedf ,_ :=ColorAtGray1BPC (x ,y ,_aga .BytesPerLine ,_aga .Data ,_aga .Decode );return _dedf ;};type CMYK32 struct{ImageBase };func _gf (_dgd _gd .Image )(Image ,error ){if _ggc ,_ad :=_dgd .(*Monochrome );_ad {return _ggc ,nil ;};_ecbb ,_aba :=_dgd .(Gray );if !_aba {_fdb ,_abab :=GrayConverter .Convert (_dgd );if _abab !=nil {return nil ,_abab ;};_ecbb =_fdb .(Gray );};_aaf :=_dgd .Bounds ();_ecda ,_ecca :=NewImage (_aaf .Max .X ,_aaf .Max .Y ,1,1,nil ,nil ,nil );if _ecca !=nil {return nil ,_ecca ;};_ggca :=_ecda .(*Monochrome );_gde :=AutoThresholdTriangle (GrayHistogram (_ecbb ));for _dbba :=0;_dbba < _aaf .Max .X ;_dbba ++{for _egd :=0;_egd < _aaf .Max .Y ;_egd ++{_gab :=_daee (_ecbb .GrayAt (_dbba ,_egd ),monochromeModel (_gde ));_ggca .SetGray (_dbba ,_egd ,_gab );};};return _ecda ,nil ;};func (_ddb *NRGBA16 )Bounds ()_gd .Rectangle {return _gd .Rectangle {Max :_gd .Point {X :_ddb .Width ,Y :_ddb .Height }};};func _dfag (_eaf _gd .Image )(Image ,error ){if _bac ,_aaaa :=_eaf .(*Gray4 );_aaaa {return _bac .Copy (),nil ;};_fcb :=_eaf .Bounds ();_ecbd ,_fdc :=NewImage (_fcb .Max .X ,_fcb .Max .Y ,4,1,nil ,nil ,nil );if _fdc !=nil {return nil ,_fdc ;};_cagg (_eaf ,_ecbd ,_fcb );return _ecbd ,nil ;};func (_daa *Monochrome )SetGray (x ,y int ,g _f .Gray ){_bge :=y *_daa .BytesPerLine +x >>3;if _bge > len (_daa .Data )-1{return ;};g =_daee (g ,monochromeModel (_daa .ModelThreshold ));_daa .setGray (x ,g ,_bge );};type colorConverter struct{_cc func (_eb _gd .Image )(Image ,error );};func (_fcg *NRGBA16 )At (x ,y int )_f .Color {_bdbc ,_ :=_fcg .ColorAt (x ,y );return _bdbc };func (_gdcg *Monochrome )Validate ()error {if len (_gdcg .Data )!=_gdcg .Height *_gdcg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gdc colorConverter )Convert (src _gd .Image )(Image ,error ){return _gdc ._cc (src )};var _ _gd .Image =&Gray16 {};func _ggf (_fbba CMYK ,_ggag NRGBA ,_dfbg _gd .Rectangle ){for _bbag :=0;_bbag < _dfbg .Max .X ;_bbag ++{for _gce :=0;_gce < _dfbg .Max .Y ;_gce ++{_gdb :=_fbba .CMYKAt (_bbag ,_gce );_ggag .SetNRGBA (_bbag ,_gce ,_egc (_gdb ));};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _aece (_eeda _gd .Image ,_bed Image ,_bded _gd .Rectangle ){if _gbea ,_dgdbe :=_eeda .(SMasker );_dgdbe &&_gbea .HasAlpha (){_bed .(SMasker ).MakeAlpha ();};switch _gaad :=_eeda .(type ){case Gray :_ffdd (_gaad ,_bed .(NRGBA ),_bded );case NRGBA :_bgae (_gaad ,_bed .(NRGBA ),_bded );case *_gd .NYCbCrA :_bdge (_gaad ,_bed .(NRGBA ),_bded );case CMYK :_ggf (_gaad ,_bed .(NRGBA ),_bded );case RGBA :_gegde (_gaad ,_bed .(NRGBA ),_bded );case nrgba64 :_ffgbc (_gaad ,_bed .(NRGBA ),_bded );default:_fe (_eeda ,_bed ,_bded );};};func _ecgf (_eaa *_gd .Gray16 ,_aeceb uint8 )*_gd .Gray {_cgff :=_eaa .Bounds ();_beda :=_gd .NewGray (_cgff );for _edab :=0;_edab < _cgff .Dx ();_edab ++{for _egaf :=0;_egaf < _cgff .Dy ();_egaf ++{_bdc :=_eaa .Gray16At (_edab ,_egaf );_beda .SetGray (_edab ,_egaf ,_f .Gray {Y :_bbce (uint8 (_bdc .Y /256),_aeceb )});};};return _beda ;};func (_cge *NRGBA64 )ColorModel ()_f .Model {return _f .NRGBA64Model };func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_fdg *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_fdg .ImageBase .copy (),ModelThreshold :_fdg .ModelThreshold };};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_abbe *ImageBase )GetAlpha ()[]byte {return _abbe .Alpha };func _ecee (_eggb CMYK ,_edfe Gray ,_eafe _gd .Rectangle ){for _ffd :=0;_ffd < _eafe .Max .X ;_ffd ++{for _bcda :=0;_bcda < _eafe .Max .Y ;_bcda ++{_cac :=_dae (_eggb .CMYKAt (_ffd ,_bcda ));_edfe .SetGray (_ffd ,_bcda ,_cac );};};};func _ebea (_fga _f .Color )_f .Color {_eag :=_f .GrayModel .Convert (_fga ).(_f .Gray );return _eff (_eag )};func (_ege *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ege .copy ()}};func _bbfd (_dedg _gd .Image ,_dbdf uint8 )*_gd .Gray {_gcg :=_dedg .Bounds ();_dafc :=_gd .NewGray (_gcg );var (_dbf _f .Color ;_bfda _f .Gray ;);for _adbf :=0;_adbf < _gcg .Max .X ;_adbf ++{for _fdacf :=0;_fdacf < _gcg .Max .Y ;_fdacf ++{_dbf =_dedg .At (_adbf ,_fdacf );_dafc .Set (_adbf ,_fdacf ,_dbf );_bfda =_dafc .GrayAt (_adbf ,_fdacf );_dafc .SetGray (_adbf ,_fdacf ,_f .Gray {Y :_bbce (_bfda .Y ,_dbdf )});};};return _dafc ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_eaef :=y *width +x ;_daef :=3*_eaef ;if _daef +2>=len (data ){return _f .NRGBA {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_abdf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _eaef {_abdf =alpha [_eaef ];};_fccc ,_eccc ,_gdgd :=data [_daef ],data [_daef +1],data [_daef +2];if len (decode )==6{_fccc =uint8 (uint32 (LinearInterpolate (float64 (_fccc ),0,255,decode [0],decode [1]))&0xff);_eccc =uint8 (uint32 (LinearInterpolate (float64 (_eccc ),0,255,decode [2],decode [3]))&0xff);_gdgd =uint8 (uint32 (LinearInterpolate (float64 (_gdgd ),0,255,decode [4],decode [5]))&0xff);};return _f .NRGBA {R :_fccc ,G :_eccc ,B :_gdgd ,A :_abdf },nil ;};func _dfc (_abe _f .Gray )_f .CMYK {return _f .CMYK {K :0xff-_abe .Y }};func (_efee *NRGBA16 )ColorModel ()_f .Model {return NRGBA16Model };func (_acebe *ImageBase )newAlpha (){_cdc :=BytesPerLine (_acebe .Width ,_acebe .BitsPerComponent ,1);_acebe .Alpha =make ([]byte ,_acebe .Height *_cdc );};var _ _gd .Image =&NRGBA16 {};func (_begg *NRGBA32 )SetNRGBA (x ,y int ,c _f .NRGBA ){_fbed :=y *_begg .Width +x ;_cgaf :=3*_fbed ;if _cgaf +2>=len (_begg .Data ){return ;};_begg .setRGBA (_fbed ,c );return ;};var _ Image =&Gray16 {};var _ Image =&Gray8 {};type ColorConverter interface{Convert (_edb _gd .Image )(Image ,error );};var _ Gray =&Gray4 {};func (_fdge *Gray4 )ColorModel ()_f .Model {return Gray4Model };func (_adb *NRGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA32 (x ,y ,_adb .Width ,_adb .Data ,_adb .Alpha ,_adb .Decode );};func _bbg (_faf _f .RGBA )_f .CMYK {_ecd ,_ecf ,_dda ,_aeg :=_f .RGBToCMYK (_faf .R ,_faf .G ,_faf .B );return _f .CMYK {C :_ecd ,M :_ecf ,Y :_dda ,K :_aeg };};func (_dfcf *Gray8 )SetGray (x ,y int ,g _f .Gray ){_bdd :=y *_dfcf .BytesPerLine +x ;if _bdd > len (_dfcf .Data )-1{return ;};_dfcf .Data [_bdd ]=g .Y ;};func (_cadc *Gray16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray16BPC (x ,y ,_cadc .BytesPerLine ,_cadc .Data ,_cadc .Decode );};func (_fc *CMYK32 )Base ()*ImageBase {return &_fc .ImageBase };func (_cde *Monochrome )Base ()*ImageBase {return &_cde .ImageBase };func (_bg *CMYK32 )Set (x ,y int ,c _f .Color ){_ea :=4*(y *_bg .Width +x );if _ea +3>=len (_bg .Data ){return ;};_ddc :=_f .CMYKModel .Convert (c ).(_f .CMYK );_bg .Data [_ea ]=_ddc .C ;_bg .Data [_ea +1]=_ddc .M ;_bg .Data [_ea +2]=_ddc .Y ;_bg .Data [_ea +3]=_ddc .K ;};func (_cce *Gray2 )SetGray (x ,y int ,gray _f .Gray ){_daed :=_edad (gray );_acf :=y *_cce .BytesPerLine ;_gfd :=_acf +(x >>2);if _gfd >=len (_cce .Data ){return ;};_gecf :=_daed .Y >>6;_cce .Data [_gfd ]=(_cce .Data [_gfd ]&(^(0xc0>>uint (2*((x )&3)))))|(_gecf <<uint (6-2*(x &3)));};func _bbce (_gfbe ,_afeed uint8 )uint8 {if _gfbe < _afeed {return 255;};return 0;};func _efbe (_dcb RGBA ,_abd Gray ,_cdd _gd .Rectangle ){for _edcg :=0;_edcg < _cdd .Max .X ;_edcg ++{for _fabfc :=0;_fabfc < _cdd .Max .Y ;_fabfc ++{_bbf :=_fda (_dcb .RGBAAt (_edcg ,_fabfc ));_abd .SetGray (_edcg ,_fabfc ,_bbf );};};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA64 ,error ){_ggab :=(y *width +x )*2;_bgdf :=_ggab *3;if _bgdf +5>=len (data ){return _f .NRGBA64 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _ebgd =0xffff;_ceff :=uint16 (_ebgd );if alpha !=nil &&len (alpha )> _ggab +1{_ceff =uint16 (alpha [_ggab ])<<8|uint16 (alpha [_ggab +1]);};_fgb :=uint16 (data [_bgdf ])<<8|uint16 (data [_bgdf +1]);_faga :=uint16 (data [_bgdf +2])<<8|uint16 (data [_bgdf +3]);_ffae :=uint16 (data [_bgdf +4])<<8|uint16 (data [_bgdf +5]);if len (decode )==6{_fgb =uint16 (uint64 (LinearInterpolate (float64 (_fgb ),0,65535,decode [0],decode [1]))&_ebgd );_faga =uint16 (uint64 (LinearInterpolate (float64 (_faga ),0,65535,decode [2],decode [3]))&_ebgd );_ffae =uint16 (uint64 (LinearInterpolate (float64 (_ffae ),0,65535,decode [4],decode [5]))&_ebgd );};return _f .NRGBA64 {R :_fgb ,G :_faga ,B :_ffae ,A :_ceff },nil ;};type NRGBA32 struct{ImageBase };func _cgb (_bf _f .Gray )_f .NRGBA {return _f .NRGBA {R :_bf .Y ,G :_bf .Y ,B :_bf .Y ,A :0xff}};func FromGoImage (i _gd .Image )(Image ,error ){switch _edcge :=i .(type ){case Image :return _edcge .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_gd .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_gd .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_efbg *Gray2 )ColorModel ()_f .Model {return Gray2Model };func (_agg *ImageBase )copy ()ImageBase {_gcda :=*_agg ;_gcda .Data =make ([]byte ,len (_agg .Data ));copy (_gcda .Data ,_agg .Data );return _gcda ;};func _bgae (_acae ,_afd NRGBA ,_edagf _gd .Rectangle ){for _eegd :=0;_eegd < _edagf .Max .X ;_eegd ++{for _adfd :=0;_adfd < _edagf .Max .Y ;_adfd ++{_afd .SetNRGBA (_eegd ,_adfd ,_acae .NRGBAAt (_eegd ,_adfd ));};};};var _ Image =&NRGBA64 {};func (_ggg *Gray8 )GrayAt (x ,y int )_f .Gray {_ddf ,_ :=ColorAtGray8BPC (x ,y ,_ggg .BytesPerLine ,_ggg .Data ,_ggg .Decode );return _ddf ;};func (_fdf *Gray16 )SetGray (x ,y int ,g _f .Gray ){_ecge :=(y *_fdf .BytesPerLine /2+x )*2;if _ecge +1>=len (_fdf .Data ){return ;};_fdf .Data [_ecge ]=g .Y ;_fdf .Data [_ecge +1]=g .Y ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_gdga :=y *bytesPerLine +x ;if _gdga >=len (data ){return _f .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ebc :=data [_gdga ];if len (decode )==2{_ebc =uint8 (uint32 (LinearInterpolate (float64 (_ebc ),0,255,decode [0],decode [1]))&0xff);};return _f .Gray {Y :_ebc },nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_fbgg :=y *bytesPerLine +x >>1;if _fbgg >=len (data ){return _f .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_adgf :=data [_fbgg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_adgf =uint8 (uint32 (LinearInterpolate (float64 (_adgf ),0,15,decode [0],decode [1]))&0xf);};return _f .Gray {Y :_adgf *17&0xff},nil ;};func (_gdf *Gray8 )Set (x ,y int ,c _f .Color ){_ffgf :=y *_gdf .BytesPerLine +x ;if _ffgf > len (_gdf .Data )-1{return ;};_fef :=_f .GrayModel .Convert (c );_gdf .Data [_ffgf ]=_fef .(_f .Gray ).Y ;};var _ Image =&CMYK32 {};func (_gdfe *NRGBA64 )NRGBA64At (x ,y int )_f .NRGBA64 {_egbf ,_ :=ColorAtNRGBA64 (x ,y ,_gdfe .Width ,_gdfe .Data ,_gdfe .Alpha ,_gdfe .Decode );return _egbf ;};func (_eggf *NRGBA16 )setNRGBA (_ggeb ,_dfb ,_bgge int ,_beaf _f .NRGBA ){if _ggeb *3%2==0{_eggf .Data [_bgge ]=(_beaf .R >>4)<<4|(_beaf .G >>4);_eggf .Data [_bgge +1]=(_beaf .B >>4)<<4|(_eggf .Data [_bgge +1]&0xf);}else {_eggf .Data [_bgge ]=(_eggf .Data [_bgge ]&0xf0)|(_beaf .R >>4);_eggf .Data [_bgge +1]=(_beaf .G >>4)<<4|(_beaf .B >>4);};if _eggf .Alpha !=nil {_ffb :=_dfb *BytesPerLine (_eggf .Width ,4,1);if _ffb < len (_eggf .Alpha ){if _ggeb %2==0{_eggf .Alpha [_ffb ]=(_beaf .A >>uint (4))<<uint (4)|(_eggf .Alpha [_bgge ]&0xf);}else {_eggf .Alpha [_ffb ]=(_eggf .Alpha [_ffb ]&0xf0)|(_beaf .A >>uint (4));};};};};func _bdab (_cfc _gd .Image )(Image ,error ){if _bfb ,_gcb :=_cfc .(*Gray8 );_gcb {return _bfb .Copy (),nil ;};_adca :=_cfc .Bounds ();_ggge ,_ffe :=NewImage (_adca .Max .X ,_adca .Max .Y ,8,1,nil ,nil ,nil );if _ffe !=nil {return nil ,_ffe ;};_cagg (_cfc ,_ggge ,_adca );return _ggge ,nil ;};func _gcd (_fce NRGBA ,_bde CMYK ,_gga _gd .Rectangle ){for _dac :=0;_dac < _gga .Max .X ;_dac ++{for _def :=0;_def < _gga .Max .Y ;_def ++{_cb :=_fce .NRGBAAt (_dac ,_def );_bde .SetCMYK (_dac ,_def ,_dce (_cb ));};};};