//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_cg "errors";_a "github.com/unidoc/unipdf/v3/common";_ac "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_bfb *Reader )Align ()(_ccg byte ){_ccg =_bfb ._aab ;_bfb ._aab =0;return _ccg };func (_fcb *BufferedWriter )Len ()int {return _fcb .byteCapacity ()};func (_dfac *SubstreamReader )readBool ()(_fbfad bool ,_bbf error ){if _dfac ._cag ==0{_dfac ._gdca ,_bbf =_dfac .readBufferByte ();if _bbf !=nil {return false ,_bbf ;};_fbfad =(_dfac ._gdca &0x80)!=0;_dfac ._gdca ,_dfac ._cag =_dfac ._gdca &0x7f,7;return _fbfad ,nil ;};_dfac ._cag --;_fbfad =(_dfac ._gdca &(1<<_dfac ._cag ))!=0;_dfac ._gdca &=1<<_dfac ._cag -1;return _fbfad ,nil ;};func (_faef *Reader )BitPosition ()int {return int (_faef ._aab )};func (_egb *BufferedWriter )writeFullBytes (_bbd []byte )int {_fef :=copy (_egb ._g [_egb .fullOffset ():],_bbd );_egb ._fb +=_fef ;return _fef ;};func (_dg *SubstreamReader )Offset ()uint64 {return _dg ._fabb };func (_eeb *Reader )readUnalignedByte ()(_fcd byte ,_be error ){_ddf :=_eeb ._aab ;_fcd =_eeb ._cfb <<(8-_ddf );_eeb ._cfb ,_be =_eeb .readBufferByte ();if _be !=nil {return 0,_be ;};_fcd |=_eeb ._cfb >>_ddf ;_eeb ._cfb &=1<<_ddf -1;return _fcd ,nil ;};var _ _c .Writer =&BufferedWriter {};func (_efe *Reader )ReadBool ()(bool ,error ){return _efe .readBool ()};func (_cgb *SubstreamReader )ReadBit ()(_cge int ,_adc error ){_bgc ,_adc :=_cgb .readBool ();if _adc !=nil {return 0,_adc ;};if _bgc {_cge =1;};return _cge ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_fdf :data }};func (_gd *BufferedWriter )WriteBits (bits uint64 ,number int )(_aa int ,_gf error ){const _ee ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ac .Errorf (_ee ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_dac :=number /8;if _dac > 0{_gga :=number -_dac *8;for _gdc :=_dac -1;_gdc >=0;_gdc --{_egg :=byte ((bits >>uint (_gdc *8+_gga ))&0xff);if _gf =_gd .WriteByte (_egg );_gf !=nil {return _aa ,_ac .Wrapf (_gf ,_ee ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dac -_gdc +1);};};number -=_dac *8;if number ==0{return _dac ,nil ;};};var _bc int ;for _eb :=0;_eb < number ;_eb ++{if _gd ._cb {_bc =int ((bits >>uint (number -1-_eb ))&0x1);}else {_bc =int (bits &0x1);bits >>=1;};if _gf =_gd .WriteBit (_bc );_gf !=nil {return _aa ,_ac .Wrapf (_gf ,_ee ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eb );};};return _dac ,nil ;};func (_cdb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cdb .writeBit (uint8 (bit ));};return _ac .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_fd *BufferedWriter )ResetBitIndex (){_fd ._fae =0};const (_fe =64;_fc =int (^uint (0)>>1););func NewReader (data []byte )*Reader {return &Reader {_gee :data }};func (_dcc *Writer )WriteBits (bits uint64 ,number int )(_dagg int ,_fdfd error ){const _gda ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ac .Errorf (_gda ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_aafe :=number /8;if _aafe > 0{_dfge :=number -_aafe *8;for _dee :=_aafe -1;_dee >=0;_dee --{_abg :=byte ((bits >>uint (_dee *8+_dfge ))&0xff);if _fdfd =_dcc .WriteByte (_abg );_fdfd !=nil {return _dagg ,_ac .Wrapf (_fdfd ,_gda ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aafe -_dee +1);};};number -=_aafe *8;if number ==0{return _aafe ,nil ;};};var _edg int ;for _bbg :=0;_bbg < number ;_bbg ++{if _dcc ._dbdg {_edg =int ((bits >>uint (number -1-_bbg ))&0x1);}else {_edg =int (bits &0x1);bits >>=1;};if _fdfd =_dcc .WriteBit (_edg );_fdfd !=nil {return _dagg ,_ac .Wrapf (_fdfd ,_gda ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bbg );};};return _aafe ,nil ;};func _afd (_ffcf ,_gec uint64 )uint64 {if _ffcf < _gec {return _ffcf ;};return _gec ;};func (_ggg *Reader )ConsumeRemainingBits (){if _ggg ._aab !=0{_ ,_agdd :=_ggg .ReadBits (_ggg ._aab );if _agdd !=nil {_a .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_agdd );};};};func (_bba *SubstreamReader )Reset (){_bba ._cdd =_bba ._edf ;_bba ._cag =_bba ._dbd };func (_dbe *BufferedWriter )tryGrowByReslice (_dad int )bool {if _ed :=len (_dbe ._g );_dad <=cap (_dbe ._g )-_ed {_dbe ._g =_dbe ._g [:_ed +_dad ];return true ;};return false ;};func (_dfg *SubstreamReader )readBufferByte ()(byte ,error ){if _dfg ._cdd >=_dfg ._fffa {return 0,_c .EOF ;};if _dfg ._cdd >=_dfg ._fdd ||_dfg ._cdd < _dfg ._age {if _bgb :=_dfg .fillBuffer ();_bgb !=nil {return 0,_bgb ;};};_ggcb :=_dfg ._cee [_dfg ._cdd -_dfg ._age ];_dfg ._cdd ++;return _ggcb ,nil ;};func (_dbed *SubstreamReader )StreamPosition ()int64 {return int64 (_dbed ._cdd )};func (_bg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_d :=int (_bg ._fae )+skip ;if _d >=0&&_d < 8{_bg ._fae =uint8 (_d );return nil ;};_d =int (_bg ._fae )+_bg ._fb *8+skip ;if _d < 0{return _ac .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ga :=_d /8;_fg :=_d %8;_bg ._fae =uint8 (_fg );if _ab :=_ga -_bg ._fb ;_ab > 0&&len (_bg ._g )-1< _ga {if _bg ._fae !=0{_ab ++;};_bg .expandIfNeeded (_ab );};_bg ._fb =_ga ;return nil ;};func (_fea *Reader )Read (p []byte )(_fgg int ,_dadc error ){if _fea ._aab ==0{return _fea .read (p );};for ;_fgg < len (p );_fgg ++{if p [_fgg ],_dadc =_fea .readUnalignedByte ();_dadc !=nil {return 0,_dadc ;};};return _fgg ,nil ;};func (_gg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ac .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_gg ._g )-1< _gg ._fb {_gg .expandIfNeeded (1);};_da :=_gg ._fae ;if _gg ._cb {_da =7-_gg ._fae ;};_gg ._g [_gg ._fb ]|=byte (uint16 (bit <<_da )&0xff);_gg ._fae ++;if _gg ._fae ==8{_gg ._fb ++;_gg ._fae =0;};return nil ;};func (_ec *Reader )ReadUint32 ()(uint32 ,error ){_dd :=make ([]byte ,4);_ ,_fgc :=_ec .Read (_dd );if _fgc !=nil {return 0,_fgc ;};return _f .BigEndian .Uint32 (_dd ),nil ;};func (_bb *BufferedWriter )writeByte (_ebb byte ){switch {case _bb ._fae ==0:_bb ._g [_bb ._fb ]=_ebb ;_bb ._fb ++;case _bb ._cb :_bb ._g [_bb ._fb ]|=_ebb >>_bb ._fae ;_bb ._fb ++;_bb ._g [_bb ._fb ]=byte (uint16 (_ebb )<<(8-_bb ._fae )&0xff);default:_bb ._g [_bb ._fb ]|=byte (uint16 (_ebb )<<_bb ._fae &0xff);_bb ._fb ++;_bb ._g [_bb ._fb ]=_ebb >>(8-_bb ._fae );};};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};type Reader struct{_gee []byte ;_cfb byte ;_aab byte ;_ce int64 ;_gbg int ;_fab int ;_aaf int64 ;_gge byte ;};func (_gad *Reader )readBool ()(_ad bool ,_dcg error ){if _gad ._aab ==0{_gad ._cfb ,_dcg =_gad .readBufferByte ();if _dcg !=nil {return false ,_dcg ;};_ad =(_gad ._cfb &0x80)!=0;_gad ._cfb ,_gad ._aab =_gad ._cfb &0x7f,7;return _ad ,nil ;};_gad ._aab --;_ad =(_gad ._cfb &(1<<_gad ._aab ))!=0;_gad ._cfb &=1<<_gad ._aab -1;return _ad ,nil ;};func (_bcag *SubstreamReader )readUnalignedByte ()(_bea byte ,_daa error ){_geb :=_bcag ._cag ;_bea =_bcag ._gdca <<(8-_geb );_bcag ._gdca ,_daa =_bcag .readBufferByte ();if _daa !=nil {return 0,_daa ;};_bea |=_bcag ._gdca >>_geb ;_bcag ._gdca &=1<<_geb -1;return _bea ,nil ;};var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ffe *BufferedWriter )writeShiftedBytes (_agd []byte )int {for _ ,_fga :=range _agd {_ffe .writeByte (_fga );};return len (_agd );};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_cg .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_a .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_fffc :r ,_fabb :offset ,_fffa :length ,_cee :make ([]byte ,length )},nil ;};func (_ae *Reader )Reset (){_ae ._ce =_ae ._aaf ;_ae ._aab =_ae ._gge };func (_daab *Writer )Data ()[]byte {return _daab ._fdf };func (_ba *BufferedWriter )Reset (){_ba ._g =_ba ._g [:0];_ba ._fb =0;_ba ._fae =0};func (_cda *SubstreamReader )BitPosition ()int {return int (_cda ._cag )};func (_cffb *Writer )ResetBit (){_cffb ._gc =0};func (_cbd *Reader )readBufferByte ()(byte ,error ){if _cbd ._ce >=int64 (len (_cbd ._gee )){return 0,_c .EOF ;};_cbd ._fab =-1;_dcd :=_cbd ._gee [_cbd ._ce ];_cbd ._ce ++;_cbd ._gbg =int (_dcd );return _dcd ,nil ;};type SubstreamReader struct{_cdd uint64 ;_fffc StreamReader ;_fabb uint64 ;_fffa uint64 ;_cee []byte ;_age uint64 ;_fdd uint64 ;_gdca byte ;_cag byte ;_edf uint64 ;_dbd byte ;};func (_cgba *Writer )byteCapacity ()int {_dacgd :=len (_cgba ._fdf )-_cgba ._cef ;if _cgba ._gc !=0{_dacgd --;};return _dacgd ;};type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ccd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cb :true }};func (_df *BufferedWriter )fullOffset ()int {_ge :=_df ._fb ;if _df ._fae !=0{_ge ++;};return _ge ;};func (_ggc *SubstreamReader )Align ()(_fad byte ){_fad =_ggc ._cag ;_ggc ._cag =0;return _fad };func (_faf *SubstreamReader )ReadByte ()(byte ,error ){if _faf ._cag ==0{return _faf .readBufferByte ();};return _faf .readUnalignedByte ();};func (_fff *Reader )ReadBit ()(_ef int ,_agf error ){_baa ,_agf :=_fff .readBool ();if _agf !=nil {return 0,_agf ;};if _baa {_ef =1;};return _ef ,nil ;};func (_cgbg *Writer )WriteByte (c byte )error {return _cgbg .writeByte (c )};func (_ebd *BufferedWriter )grow (_fba int ){if _ebd ._g ==nil &&_fba < _fe {_ebd ._g =make ([]byte ,_fba ,_fe );return ;};_af :=len (_ebd ._g );if _ebd ._fae !=0{_af ++;};_ag :=cap (_ebd ._g );switch {case _fba <=_ag /2-_af :_a .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ebd ._g ),cap (_ebd ._g ),_fba );_a .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ag ,_af );copy (_ebd ._g ,_ebd ._g [_ebd .fullOffset ():]);case _ag > _fc -_ag -_fba :_a .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_egga :=make ([]byte ,2*_ag +_fba );copy (_egga ,_ebd ._g );_ebd ._g =_egga ;};_ebd ._g =_ebd ._g [:_af +_fba ];};func (_ece *Writer )UseMSB ()bool {return _ece ._dbdg };func (_acg *Writer )Write (p []byte )(int ,error ){if len (p )> _acg .byteCapacity (){return 0,_c .EOF ;};for _ ,_eddb :=range p {if _beg :=_acg .writeByte (_eddb );_beg !=nil {return 0,_beg ;};};return len (p ),nil ;};func (_gb *BufferedWriter )expandIfNeeded (_dc int ){if !_gb .tryGrowByReslice (_dc ){_gb .grow (_dc );};};var _ _c .ByteWriter =&BufferedWriter {};func (_ace *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ace ._fab =-1;var _bbdc int64 ;switch whence {case _c .SeekStart :_bbdc =offset ;case _c .SeekCurrent :_bbdc =_ace ._ce +offset ;case _c .SeekEnd :_bbdc =int64 (len (_ace ._gee ))+offset ;default:return 0,_cg .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _bbdc < 0{return 0,_cg .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ace ._ce =_bbdc ;_ace ._aab =0;return _bbdc ,nil ;};func (_e *BufferedWriter )Data ()[]byte {return _e ._g };func NewWriterMSB (data []byte )*Writer {return &Writer {_fdf :data ,_dbdg :true }};func (_ecb *SubstreamReader )fillBuffer ()error {if uint64 (_ecb ._fffc .StreamPosition ())!=_ecb ._cdd +_ecb ._fabb {_ ,_eggc :=_ecb ._fffc .Seek (int64 (_ecb ._cdd +_ecb ._fabb ),_c .SeekStart );if _eggc !=nil {return _eggc ;};};_ecb ._age =uint64 (_ecb ._cdd );_gdf :=_afd (uint64 (len (_ecb ._cee )),_ecb ._fffa -_ecb ._cdd );_gdgb :=make ([]byte ,_gdf );_eecb ,_deb :=_ecb ._fffc .Read (_gdgb );if _deb !=nil {return _deb ;};for _gag :=uint64 (0);_gag < _gdf ;_gag ++{_ecb ._cee [_gag ]=_gdgb [_gag ];};_ecb ._fdd =_ecb ._age +uint64 (_eecb );return nil ;};func (_dda *Reader )read (_caf []byte )(int ,error ){if _dda ._ce >=int64 (len (_dda ._gee )){return 0,_c .EOF ;};_dda ._fab =-1;_dcf :=copy (_caf ,_dda ._gee [_dda ._ce :]);_dda ._ce +=int64 (_dcf );return _dcf ,nil ;};func (_bbc *Reader )Length ()uint64 {return uint64 (len (_bbc ._gee ))};func (_abb *SubstreamReader )ReadBool ()(bool ,error ){return _abb .readBool ()};func (_cac *SubstreamReader )Mark (){_cac ._edf =_cac ._cdd ;_cac ._dbd =_cac ._cag };type Writer struct{_fdf []byte ;_gc uint8 ;_cef int ;_dbdg bool ;};func (_dag *Writer )SkipBits (skip int )error {const _ecd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_add :=int (_dag ._gc )+skip ;if _add >=0&&_add < 8{_dag ._gc =uint8 (_add );return nil ;};_add =int (_dag ._gc )+_dag ._cef *8+skip ;if _add < 0{return _ac .Errorf (_ecd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ebc :=_add /8;_egf :=_add %8;_a .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_a .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dag ._gc ,_dag ._cef ,int (_dag ._gc )+(_dag ._cef )*8,len (_dag ._fdf ),cap (_dag ._fdf ));_a .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_add ,_egf );_dag ._gc =uint8 (_egf );if _baf :=_ebc -_dag ._cef ;_baf > 0&&len (_dag ._fdf )-1< _ebc {_a .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_baf );return _ac .Errorf (_ecd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dag ._cef =_ebc ;_a .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dag ._gc ,_dag ._cef );return nil ;};var _ BinaryWriter =&Writer {};func (_dbc *Reader )ReadByte ()(byte ,error ){if _dbc ._aab ==0{return _dbc .readBufferByte ();};return _dbc .readUnalignedByte ();};func (_ccf *Reader )StreamPosition ()int64 {return _ccf ._ce };func (_cbc *Reader )Mark (){_cbc ._aaf =_cbc ._ce ;_cbc ._gge =_cbc ._aab };func (_baae *Writer )writeByte (_adg byte )error {if _baae ._cef > len (_baae ._fdf )-1{return _c .EOF ;};if _baae ._cef ==len (_baae ._fdf )-1&&_baae ._gc !=0{return _c .EOF ;};if _baae ._gc ==0{_baae ._fdf [_baae ._cef ]=_adg ;_baae ._cef ++;return nil ;};if _baae ._dbdg {_baae ._fdf [_baae ._cef ]|=_adg >>_baae ._gc ;_baae ._cef ++;_baae ._fdf [_baae ._cef ]=byte (uint16 (_adg )<<(8-_baae ._gc )&0xff);}else {_baae ._fdf [_baae ._cef ]|=byte (uint16 (_adg )<<_baae ._gc &0xff);_baae ._cef ++;_baae ._fdf [_baae ._cef ]=_adg >>(8-_baae ._gc );};return nil ;};func (_dfa *Reader )ReadBits (n byte )(_fde uint64 ,_afc error ){if n < _dfa ._aab {_fdc :=_dfa ._aab -n ;_fde =uint64 (_dfa ._cfb >>_fdc );_dfa ._cfb &=1<<_fdc -1;_dfa ._aab =_fdc ;return _fde ,nil ;};if n > _dfa ._aab {if _dfa ._aab > 0{_fde =uint64 (_dfa ._cfb );n -=_dfa ._aab ;};for n >=8{_fac ,_ffg :=_dfa .readBufferByte ();if _ffg !=nil {return 0,_ffg ;};_fde =_fde <<8+uint64 (_fac );n -=8;};if n > 0{if _dfa ._cfb ,_afc =_dfa .readBufferByte ();_afc !=nil {return 0,_afc ;};_cad :=8-n ;_fde =_fde <<n +uint64 (_dfa ._cfb >>_cad );_dfa ._cfb &=1<<_cad -1;_dfa ._aab =_cad ;}else {_dfa ._aab =0;};return _fde ,nil ;};_dfa ._aab =0;return uint64 (_dfa ._cfb ),nil ;};func (_fbf *SubstreamReader )ReadBits (n byte )(_dgf uint64 ,_fbfa error ){if n < _fbf ._cag {_ea :=_fbf ._cag -n ;_dgf =uint64 (_fbf ._gdca >>_ea );_fbf ._gdca &=1<<_ea -1;_fbf ._cag =_ea ;return _dgf ,nil ;};if n > _fbf ._cag {if _fbf ._cag > 0{_dgf =uint64 (_fbf ._gdca );n -=_fbf ._cag ;};var _edfc byte ;for n >=8{_edfc ,_fbfa =_fbf .readBufferByte ();if _fbfa !=nil {return 0,_fbfa ;};_dgf =_dgf <<8+uint64 (_edfc );n -=8;};if n > 0{if _fbf ._gdca ,_fbfa =_fbf .readBufferByte ();_fbfa !=nil {return 0,_fbfa ;};_ggf :=8-n ;_dgf =_dgf <<n +uint64 (_fbf ._gdca >>_ggf );_fbf ._gdca &=1<<_ggf -1;_fbf ._cag =_ggf ;}else {_fbf ._cag =0;};return _dgf ,nil ;};_fbf ._cag =0;return uint64 (_fbf ._gdca ),nil ;};func (_ff *BufferedWriter )byteCapacity ()int {_eed :=len (_ff ._g )-_ff ._fb ;if _ff ._fae !=0{_eed --;};return _eed ;};func (_eg *BufferedWriter )FinishByte (){if _eg ._fae ==0{return ;};_eg ._fae =0;_eg ._fb ++;};var _ BinaryWriter =&BufferedWriter {};func (_adf *SubstreamReader )Read (b []byte )(_afg int ,_eec error ){if _adf ._cdd >=_adf ._fffa {_a .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_adf ._cdd ,_adf ._fffa );return 0,_c .EOF ;};for ;_afg < len (b );_afg ++{if b [_afg ],_eec =_adf .readUnalignedByte ();_eec !=nil {if _eec ==_c .EOF {return _afg ,nil ;};return 0,_eec ;};};return _afg ,nil ;};func (_fbd *Writer )writeBit (_ffeb uint8 )error {if len (_fbd ._fdf )-1< _fbd ._cef {return _c .EOF ;};_bae :=_fbd ._gc ;if _fbd ._dbdg {_bae =7-_fbd ._gc ;};_fbd ._fdf [_fbd ._cef ]|=byte (uint16 (_ffeb <<_bae )&0xff);_fbd ._gc ++;if _fbd ._gc ==8{_fbd ._cef ++;_fbd ._gc =0;};return nil ;};func (_dcfg *Writer )FinishByte (){if _dcfg ._gc ==0{return ;};_dcfg ._gc =0;_dcfg ._cef ++;};type BitWriter interface{WriteBit (_bf int )error ;WriteBits (_aad uint64 ,_cf int )(_cd int ,_edd error );FinishByte ();SkipBits (_ffef int )error ;};type BufferedWriter struct{_g []byte ;_fae uint8 ;_fb int ;_cb bool ;};func (_bbcg *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bfa :=make ([]byte ,4);_ ,_bbe :=_bbcg .Read (_bfa );if _bbe !=nil {return 0,_bbe ;};return _f .BigEndian .Uint32 (_bfa ),nil ;};func (_dce *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_dce ._cdd =uint64 (offset );case _c .SeekCurrent :_dce ._cdd +=uint64 (offset );case _c .SeekEnd :_dce ._cdd =_dce ._fffa +uint64 (offset );default:return 0,_cg .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_dce ._cag =0;return int64 (_dce ._cdd ),nil ;};func (_cff *SubstreamReader )Length ()uint64 {return _cff ._fffa };func (_gac *BufferedWriter )Write (d []byte )(int ,error ){_gac .expandIfNeeded (len (d ));if _gac ._fae ==0{return _gac .writeFullBytes (d ),nil ;};return _gac .writeShiftedBytes (d ),nil ;};func (_cc *BufferedWriter )WriteByte (bt byte )error {if _cc ._fb > len (_cc ._g )-1||(_cc ._fb ==len (_cc ._g )-1&&_cc ._fae !=0){_cc .expandIfNeeded (1);};_cc .writeByte (bt );return nil ;};