//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_fc "bytes";_f "errors";_af "fmt";_ga "github.com/unidoc/unipdf/v3/common";_ba "github.com/unidoc/unipdf/v3/contentstream";_ef "github.com/unidoc/unipdf/v3/contentstream/draw";_ec "github.com/unidoc/unipdf/v3/core";_ee "github.com/unidoc/unipdf/v3/internal/transform";_c "github.com/unidoc/unipdf/v3/model";_ag "image";_g "io";_b "math";_e "os";_ac "sort";_eg "strconv";_be "strings";_fa "unicode";);

// SetSellerAddress sets the seller address of the invoice.
func (_dcef *Invoice )SetSellerAddress (address *InvoiceAddress ){_dcef ._cfac =address };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fggd *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fggd ._eagg [0],_fggd ._eagg [1]};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        â€¢ This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_ddg []*listItem ;_gfeg margins ;_geeb TextChunk ;_gbdg float64 ;_fede bool ;_fdbf positioning ;_caae TextStyle ;};

// AddSection adds a new content section at the end of the invoice.
func (_gabf *Invoice )AddSection (title ,content string ){_gabf ._aeegf =append (_gabf ._aeegf ,[2]string {title ,content });};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cdda *TOC )SetLineSeparator (separator string ){_cdda ._aadc =separator };

// SetBorderColor sets the border color for the path.
func (_eceb *FilledCurve )SetBorderColor (color Color ){_eceb ._bbcda =_c .NewPdfColorDeviceRGB (color .ToRGB ());};func _ceee ()*FilledCurve {_aeg :=FilledCurve {};_aeg ._gccf =[]_ef .CubicBezierCurve {};return &_aeg };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_ecbge *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_aab *_c .PdfWriter )error ){_ecbge ._abe =pdfWriterAccessFunc ;};func _ccbb (_cagc string ,_gecd ,_dbaa TextStyle )*TOC {_deec :=_dbaa ;_deec .FontSize =14;_eagc :=_abdg (_deec );_eagc .SetEnableWrap (true );_eagc .SetTextAlignment (TextAlignmentLeft );_eagc .SetMargins (0,0,0,5);_gbeb :=_eagc .Append (_cagc );_gbeb .Style =_deec ;return &TOC {_aaea :_eagc ,_baag :[]*TOCLine {},_aagd :_gecd ,_dfgea :_gecd ,_egabb :_gecd ,_accfc :_gecd ,_aadc :"\u002e",_dced :10,_edeef :margins {0,0,2,2},_gece :_abfc ,_dbeeg :_gecd ,_gbgg :true };};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_bgdg *Creator )Draw (d Drawable )error {if _bgdg .getActivePage ()==nil {_bgdg .NewPage ();};_gged ,_bfg ,_cbb :=d .GeneratePageBlocks (_bgdg ._eged );if _cbb !=nil {return _cbb ;};for _adc ,_bafd :=range _gged {if _adc > 0{_bgdg .NewPage ();};_bfde :=_bgdg .getActivePage ();if _bgf ,_aga :=_bgdg ._bff [_bfde ];_aga {if _babc :=_bgf .mergeBlocks (_bafd );_babc !=nil {return _babc ;};if _ddaa :=_cgbb (_bafd ._ab ,_bgf ._ab );_ddaa !=nil {return _ddaa ;};}else {_bgdg ._bff [_bfde ]=_bafd ;};};_bgdg ._eged .X =_bfg .X ;_bgdg ._eged .Y =_bfg .Y ;_bgdg ._eged .Height =_bfg .PageHeight -_bfg .Y -_bfg .Margins ._abcd ;return nil ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bbbfd *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _bbbfd ._aegf [0],_bbbfd ._aegf [1]};

// Width returns the current page width.
func (_ecdce *Creator )Width ()float64 {return _ecdce ._ecbg };func (_dcd *Block )duplicate ()*Block {_dde :=&Block {};*_dde =*_dcd ;_acc :=_ba .ContentStreamOperations {};for _ ,_fb :=range *_dcd ._ca {_acc =append (_acc ,_fb );};_dde ._ca =&_acc ;return _dde ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_gddf *Creator )SetPageSize (size PageSize ){_gddf ._fafa =size ;_gddf ._ecbg =size [0];_gddf ._beeb =size [1];_aaf :=0.1*_gddf ._ecbg ;_gddf ._dcb ._eccf =_aaf ;_gddf ._dcb ._gdce =_aaf ;_gddf ._dcb ._efbe =_aaf ;_gddf ._dcb ._abcd =_aaf ;};

// NewDivision returns a new Division container component.
func (_cfca *Creator )NewDivision ()*Division {return _bdag ()};

// SetPos sets absolute positioning with specified coordinates.
func (_efed *StyledParagraph )SetPos (x ,y float64 ){_efed ._cgdb =_cdaa ;_efed ._dcaa =x ;_efed ._dfbd =y ;};

// Width returns the Block's width.
func (_cca *Block )Width ()float64 {return _cca ._fe };

// SetStyleBottom sets border style for bottom side.
func (_cbc *border )SetStyleBottom (style CellBorderStyle ){_cbc ._gbad =style };func (_fdbg *Invoice )generateHeaderBlocks (_fcbbf DrawContext )([]*Block ,DrawContext ,error ){_aefd :=_abdg (_fdbg ._fcdg );_aefd .SetEnableWrap (true );_aefd .Append (_fdbg ._eabe );_dgba :=_eaed (2);if _fdbg ._bcga !=nil {_fead :=_dgba .NewCell ();_fead .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fead .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fead .SetIndent (0);_fead .SetContent (_fdbg ._bcga );_fdbg ._bcga .ScaleToHeight (_aefd .Height ()+20);}else {_dgba .SkipCells (1);};_dbee :=_dgba .NewCell ();_dbee .SetHorizontalAlignment (CellHorizontalAlignmentRight );_dbee .SetVerticalAlignment (CellVerticalAlignmentMiddle );_dbee .SetContent (_aefd );return _dgba .GeneratePageBlocks (_fcbbf );};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_caee *Ellipse )GetCoords ()(float64 ,float64 ){return _caee ._ffab ,_caee ._dgg };

// SetBorderColor sets the border color.
func (_faff *Polygon )SetBorderColor (color Color ){_faff ._cdcg .BorderColor =_c .NewPdfColorDeviceRGB (color .ToRGB ());};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Write output of creator to io.Writer interface.
func (_bcae *Creator )Write (ws _g .Writer )error {if _fdb :=_bcae .Finalize ();_fdb !=nil {return _fdb ;};_becd :=_c .NewPdfWriter ();_becd .SetOptimizer (_bcae ._fgbb );if _bcae ._efdg !=nil {_bdd :=_becd .SetForms (_bcae ._efdg );if _bdd !=nil {_ga .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bdd );return _bdd ;};};if _bcae ._ceg !=nil {_becd .AddOutlineTree (_bcae ._ceg );}else if _bcae ._eab !=nil &&_bcae .AddOutlines {_becd .AddOutlineTree (&_bcae ._eab .ToPdfOutline ().PdfOutlineTreeNode );};if _bcae ._caad !=nil {if _fdaa :=_becd .SetPageLabels (_bcae ._caad );_fdaa !=nil {_ga .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_fdaa );return _fdaa ;};};if _bcae ._cecd !=nil {for _ ,_fadf :=range _bcae ._cecd {_gff :=_fadf .SubsetRegistered ();if _gff !=nil {_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_gff );return _gff ;};};};if _bcae ._abe !=nil {_feec :=_bcae ._abe (&_becd );if _feec !=nil {_ga .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_feec );return _feec ;};};for _ ,_ebd :=range _bcae ._fcc {_fcbd :=_becd .AddPage (_ebd );if _fcbd !=nil {_ga .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_fcbd );return _fcbd ;};};_gaef :=_becd .Write (ws );if _gaef !=nil {return _gaef ;};return nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_bdbc *Creator )MoveRight (dx float64 ){_bdbc ._eged .X +=dx };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_eeca *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _eeca ._dded ,_eeca ._bbaa ,_eeca ._ebae ,_eeca ._ffecc ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_befgd *StyledParagraph )Height ()float64 {_befgd .wrapText ();var _fbcg float64 ;for _ ,_eceg :=range _befgd ._baedf {var _bdbf float64 ;for _ ,_dbfc :=range _eceg {_ceeb :=_befgd ._fdae *_dbfc .Style .FontSize ;if _ceeb > _bdbf {_bdbf =_ceeb ;};};_fbcg +=_bdbf ;};return _fbcg ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetFillOpacity sets the fill opacity.
func (_befg *Rectangle )SetFillOpacity (opacity float64 ){_befg ._cbgf =opacity };

// Length calculates and returns the line length.
func (_affg *Line )Length ()float64 {return _b .Sqrt (_b .Pow (_affg ._ebae -_affg ._dded ,2.0)+_b .Pow (_affg ._ffecc -_affg ._bbaa ,2.0));};func (_cedb *Invoice )generateTotalBlocks (_feee DrawContext )([]*Block ,DrawContext ,error ){_cfbgb :=_eaed (4);_cfbgb .SetMargins (0,0,10,10);_eadab :=[][2]*InvoiceCell {_cedb ._eagg };_eadab =append (_eadab ,_cedb ._bdff ...);_eadab =append (_eadab ,_cedb ._aegf );for _ ,_faba :=range _eadab {_ade ,_debc :=_faba [0],_faba [1];if _debc .Value ==""{continue ;};_cfbgb .SkipCells (2);_aged :=_cfbgb .NewCell ();_aged .SetBackgroundColor (_ade .BackgroundColor );_aged .SetHorizontalAlignment (_debc .Alignment );_cedb .setCellBorder (_aged ,_ade );_afde :=_abdg (_ade .TextStyle );_afde .SetMargins (0,0,2,1);_afde .Append (_ade .Value );_aged .SetContent (_afde );_aged =_cfbgb .NewCell ();_aged .SetBackgroundColor (_debc .BackgroundColor );_aged .SetHorizontalAlignment (_debc .Alignment );_cedb .setCellBorder (_aged ,_ade );_afde =_abdg (_debc .TextStyle );_afde .SetMargins (0,0,2,1);_afde .Append (_debc .Value );_aged .SetContent (_afde );};return _cfbgb .GeneratePageBlocks (_feee );};

// Height returns the Block's height.
func (_cgf *Block )Height ()float64 {return _cgf ._gg };

// SetStyleLeft sets border style for left side.
func (_ceff *border )SetStyleLeft (style CellBorderStyle ){_ceff ._bda =style };

// Scale block by specified factors in the x and y directions.
func (_ega *Block )Scale (sx ,sy float64 ){_bdc :=_ba .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ega ._ca =append (*_bdc ,*_ega ._ca ...);_ega ._ca .WrapIfNeeded ();_ega ._fe *=sx ;_ega ._gg *=sy ;};func _ddf (_fcb string ,_gee _ec .PdfObject ,_df *_c .PdfPageResources )_ec .PdfObjectName {_eeg :=_be .TrimRightFunc (_be .TrimSpace (_fcb ),func (_eda rune )bool {return _fa .IsNumber (_eda )});if _eeg ==""{_eeg ="\u0046\u006f\u006e\u0074";};_cafa :=0;_aeaf :=_ec .PdfObjectName (_fcb );for {_cge ,_dab :=_df .GetFontByName (_aeaf );if !_dab ||_cge ==_gee {break ;};_cafa ++;_aeaf =_ec .PdfObjectName (_af .Sprintf ("\u0025\u0073\u0025\u0064",_eeg ,_cafa ));};return _aeaf ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_eefg *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfee :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdbe ,_gaed :=_bfee .setOpacity (_eefg ._ebfg ,_eefg ._ebfg );if _gaed !=nil {return nil ,ctx ,_gaed ;};_egdb :=_eefg ._gbefb .Points ;for _ebfb :=range _egdb {_bbfga :=&_egdb [_ebfb ];_bbfga .Y =ctx .PageHeight -_bbfga .Y ;};_fdbde ,_ ,_gaed :=_eefg ._gbefb .Draw (_cdbe );if _gaed !=nil {return nil ,ctx ,_gaed ;};if _gaed =_bfee .addContentsByString (string (_fdbde ));_gaed !=nil {return nil ,ctx ,_gaed ;};return []*Block {_bfee },ctx ,nil ;};

// Level returns the indentation level of the TOC line.
func (_ffbad *TOCLine )Level ()uint {return _ffbad ._cgca };

// NewChapter creates a new chapter with the specified title as the heading.
func (_bbcd *Creator )NewChapter (title string )*Chapter {_bbcd ._fegg ++;_gfcf :=_bbcd .NewTextStyle ();_gfcf .FontSize =16;return _effc (nil ,_bbcd ._bcdg ,_bbcd ._eab ,title ,_bbcd ._fegg ,_gfcf );};func (_fffc *Creator )getActivePage ()*_c .PdfPage {if _fffc ._baff ==nil {if len (_fffc ._fcc )==0{return nil ;};return _fffc ._fcc [len (_fffc ._fcc )-1];};return _fffc ._baff ;};

// Width returns the width of the Paragraph.
func (_bbbfdf *Paragraph )Width ()float64 {if _bbbfdf ._aabde &&int (_bbbfdf ._adbbc )> 0{return _bbbfdf ._adbbc ;};return _bbbfdf .getTextWidth ()/1000.0;};const (_abfc positioning =iota ;_cdaa ;);

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_efdc float64 ;_gcce float64 ;_bbag float64 ;_cffc float64 ;_fcadc float64 ;_bfcf float64 ;_becf *_c .PdfColorDeviceRGB ;_ggeg float64 ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_c .PdfPage )(*Block ,error ){_afd :=&Block {};_cc ,_dd :=page .GetAllContentStreams ();if _dd !=nil {return nil ,_dd ;};_acd :=_ba .NewContentStreamParser (_cc );_gf ,_dd :=_acd .Parse ();if _dd !=nil {return nil ,_dd ;};_gf .WrapIfNeeded ();_afd ._ca =_gf ;if page .Resources !=nil {_afd ._ab =page .Resources ;}else {_afd ._ab =_c .NewPdfPageResources ();};_dc ,_dd :=page .GetMediaBox ();if _dd !=nil {return nil ,_dd ;};if _dc .Llx !=0||_dc .Lly !=0{_afd .translate (-_dc .Llx ,_dc .Lly );};_afd ._fe =_dc .Urx -_dc .Llx ;_afd ._gg =_dc .Ury -_dc .Lly ;if page .Rotate !=nil {_afd ._aff =-float64 (*page .Rotate );};return _afd ,nil ;};func _befa (_aec string ,_gfaa TextStyle )*Paragraph {_dbaga :=&Paragraph {_bgcc :_aec ,_feeda :_gfaa .Font ,_dgaa :_gfaa .FontSize ,_gaga :1.0,_aabde :true ,_faga :true ,_aeed :TextAlignmentLeft ,_egf :0,_fcea :1,_beaf :1,_cbade :_abfc };_dbaga .SetColor (_gfaa .Color );return _dbaga ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_gbg *Block )Draw (d Drawable )error {_cd :=DrawContext {};_cd .Width =_gbg ._fe ;_cd .Height =_gbg ._gg ;_cd .PageWidth =_gbg ._fe ;_cd .PageHeight =_gbg ._gg ;_cd .X =0;_cd .Y =0;_ecd ,_ ,_fed :=d .GeneratePageBlocks (_cd );if _fed !=nil {return _fed ;};if len (_ecd )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ddc :=range _ecd {if _dge :=_gbg .mergeBlocks (_ddc );_dge !=nil {return _dge ;};};return nil ;};

// Logo returns the logo of the invoice.
func (_ggaaa *Invoice )Logo ()*Image {return _ggaaa ._bcga };func _aefc (_cgcf ,_cebg ,_gcbe ,_efdea float64 )*Line {_bebcf :=&Line {};_bebcf ._dded =_cgcf ;_bebcf ._bbaa =_cebg ;_bebcf ._ebae =_gcbe ;_bebcf ._ffecc =_efdea ;_bebcf ._gbc =_c .NewPdfColorDeviceRGB (0,0,0);_bebcf ._bafg =1.0;return _bebcf ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_eefe *_c .PdfColorDeviceRGB ;_fbbb _ef .LineStyle ;_bagb CellBorderStyle ;_gfdea *_c .PdfColorDeviceRGB ;_eedfc float64 ;_efbea CellBorderStyle ;_cfbb *_c .PdfColorDeviceRGB ;_bedg float64 ;_gaac CellBorderStyle ;_deeec *_c .PdfColorDeviceRGB ;_eadce float64 ;_fega CellBorderStyle ;_gbbcc *_c .PdfColorDeviceRGB ;_ffce float64 ;_degfg ,_effad int ;_cgfb int ;_aeccf int ;_dbaec VectorDrawable ;_eebdc CellHorizontalAlignment ;_fdcfe CellVerticalAlignment ;_ggbf float64 ;_bbgdf *Table ;};func (_cabgf *InvoiceAddress )fmtLine (_dada ,_dcce string ,_agab bool )string {if _agab {_dcce ="";};return _af .Sprintf ("\u0025\u0073\u0025s\u000a",_dcce ,_dada );};

// InsertColumn inserts a column in the line items table at the specified index.
func (_fced *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_fbaa :=uint (len (_fced ._fdfd ));if index > _fbaa {index =_fbaa ;};_bbga :=_fced .NewColumn (description );_fced ._fdfd =append (_fced ._fdfd [:index ],append ([]*InvoiceCell {_bbga },_fced ._fdfd [index :]...)...);return _bbga ;};

// SetLevel sets the indentation level of the TOC line.
func (_gffd *TOCLine )SetLevel (level uint ){_gffd ._cgca =level ;_gffd ._afdf ._fcgc ._eccf =_gffd ._gagce +float64 (_gffd ._cgca -1)*_gffd ._cddd ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_cbdfe *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_fgbaf :=range subtable ._eafba {_adca :=&TableCell {};*_adca =*_fgbaf ;_adca ._bbgdf =_cbdfe ;_adca ._effad +=col -1;if _gfga :=_cbdfe ._ecgb -(_adca ._effad -1);_gfga < _adca ._aeccf {_cbdfe ._ecgb +=_adca ._aeccf -_gfga ;_cbdfe .resetColumnWidths ();_ga .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_cbdfe ._ecgb );};_adca ._degfg +=row -1;_cbadf :=subtable ._ccaae [_fgbaf ._degfg -1];if _adca ._degfg > _cbdfe ._bced {for _adca ._degfg > _cbdfe ._bced {_cbdfe ._bced ++;_cbdfe ._ccaae =append (_cbdfe ._ccaae ,_cbdfe ._dacf );};_cbdfe ._ccaae [_adca ._degfg -1]=_cbadf ;}else {_cbdfe ._ccaae [_adca ._degfg -1]=_b .Max (_cbdfe ._ccaae [_adca ._degfg -1],_cbadf );};_cbdfe ._eafba =append (_cbdfe ._eafba ,_adca );};_ac .Slice (_cbdfe ._eafba ,func (_cgde ,_dgcbc int )bool {_dadaf :=_cbdfe ._eafba [_cgde ]._degfg ;_fege :=_cbdfe ._eafba [_dgcbc ]._degfg ;if _dadaf < _fege {return true ;};if _dadaf > _fege {return false ;};return _cbdfe ._eafba [_cgde ]._effad < _cbdfe ._eafba [_dgcbc ]._effad ;});};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_bbfg *Invoice )InfoLines ()[][2]*InvoiceCell {_beed :=[][2]*InvoiceCell {_bbfg ._eacd ,_bbfg ._bccb ,_bbfg ._dbcc };return append (_beed ,_bbfg ._ecff ...);};

// Rows returns the total number of rows the table has.
func (_cdcgd *Table )Rows ()int {return _cdcgd ._bced };

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_aaad *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _cdba (x ,y ,width ,height );};func (_eeb *Chapter )headingNumber ()string {var _ffae string ;if _eeb ._dcfb {if _eeb ._gge !=0{_ffae =_eg .Itoa (_eeb ._gge )+"\u002e";};if _eeb ._ccf !=nil {_fceb :=_eeb ._ccf .headingNumber ();if _fceb !=""{_ffae =_fceb +_ffae ;};};};return _ffae ;};

// Height returns Image's document height.
func (_ccb *Image )Height ()float64 {return _ccb ._add };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_cedd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_cedd ._acg ._eccf =left ;_cedd ._acg ._gdce =right ;_cedd ._acg ._efbe =top ;_cedd ._acg ._abcd =bottom ;};

// NewInvoice returns an instance of an empty invoice.
func (_bged *Creator )NewInvoice ()*Invoice {_geg :=_bged .NewTextStyle ();_geg .Font =_bged ._adbb ;return _bbbd (_bged .NewTextStyle (),_geg );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_deba *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbbbe :=ctx ;_bcbf ,ctx ,_bcbc :=_deba ._aaea .GeneratePageBlocks (ctx );if _bcbc !=nil {return _bcbf ,ctx ,_bcbc ;};for _ ,_badf :=range _deba ._baag {_dgdee :=_badf ._aced ;if !_deba ._gbgg {_badf ._aced =0;};_ddac ,_gabe ,_daaeg :=_badf .GeneratePageBlocks (ctx );_badf ._aced =_dgdee ;if _daaeg !=nil {return _bcbf ,ctx ,_daaeg ;};if len (_ddac )< 1{continue ;};_bcbf [len (_bcbf )-1].mergeBlocks (_ddac [0]);_bcbf =append (_bcbf ,_ddac [1:]...);ctx =_gabe ;};if _deba ._gece .isRelative (){ctx .X =_gbbbe .X ;};if _deba ._gece .isAbsolute (){return _bcbf ,_gbbbe ,nil ;};return _bcbf ,ctx ,nil ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_acaa *Image )SetWidth (w float64 ){_acaa ._aeeg =w };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_dgeac *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_dgeac ._bcdg =toc ;};

// SetNotes sets the notes section of the invoice.
func (_affb *Invoice )SetNotes (title ,content string ){_affb ._bbfd =[2]string {title ,content }};func (_afbe *Creator )initContext (){_afbe ._eged .X =_afbe ._dcb ._eccf ;_afbe ._eged .Y =_afbe ._dcb ._efbe ;_afbe ._eged .Width =_afbe ._ecbg -_afbe ._dcb ._gdce -_afbe ._dcb ._eccf ;_afbe ._eged .Height =_afbe ._beeb -_afbe ._dcb ._abcd -_afbe ._dcb ._efbe ;_afbe ._eged .PageHeight =_afbe ._beeb ;_afbe ._eged .PageWidth =_afbe ._ecbg ;_afbe ._eged .Margins =_afbe ._dcb ;};

// SetStyleTop sets border style for top side.
func (_cadd *border )SetStyleTop (style CellBorderStyle ){_cadd ._fdcf =style };func (_dddg *Table )newCell (_bceg int )*TableCell {_dddg ._abed ++;_bfed :=(_dddg ._abed -1)/_dddg ._ecgb +1;for _bfed > _dddg ._bced {_dddg ._bced ++;_dddg ._ccaae =append (_dddg ._ccaae ,_dddg ._dacf );};_ffagf :=(_dddg ._abed -1)%(_dddg ._ecgb )+1;_fgafc :=&TableCell {};_fgafc ._degfg =_bfed ;_fgafc ._effad =_ffagf ;_fgafc ._cgfb =1;_fgafc ._ggbf =5;_fgafc ._bagb =CellBorderStyleNone ;_fgafc ._fbbb =_ef .LineStyleSolid ;_fgafc ._eebdc =CellHorizontalAlignmentLeft ;_fgafc ._fdcfe =CellVerticalAlignmentTop ;_fgafc ._eedfc =0;_fgafc ._bedg =0;_fgafc ._eadce =0;_fgafc ._ffce =0;_gfbe :=ColorBlack ;_fgafc ._gfdea =_c .NewPdfColorDeviceRGB (_gfbe .ToRGB ());_fgafc ._cfbb =_c .NewPdfColorDeviceRGB (_gfbe .ToRGB ());_fgafc ._deeec =_c .NewPdfColorDeviceRGB (_gfbe .ToRGB ());_fgafc ._gbbcc =_c .NewPdfColorDeviceRGB (_gfbe .ToRGB ());if _bceg < 1{_ga .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_bceg );_bceg =1;};_daed :=_dddg ._ecgb -(_fgafc ._effad -1);if _bceg > _daed {_ga .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_bceg ,_daed );_bceg =_daed ;};_fgafc ._aeccf =_bceg ;_dddg ._abed +=_bceg -1;_dddg ._eafba =append (_dddg ._eafba ,_fgafc );_fgafc ._bbgdf =_dddg ;return _fgafc ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetSubtotal sets the subtotal of the invoice.
func (_aedb *Invoice )SetSubtotal (value string ){_aedb ._eagg [1].Value =value };

// SetFillColor sets the fill color for the path.
func (_acae *FilledCurve )SetFillColor (color Color ){_acae ._feggc =_c .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_dbcf *Chapter )SetIncludeInTOC (includeInTOC bool ){_dbcf ._ceag =includeInTOC };func (_cccf *TOCLine )getLineLink ()*_c .PdfAnnotation {if _cccf ._aced <=0{return nil ;};return _dfc (_cccf ._aced -1,_cccf ._fdfbe ,_cccf ._dgdf ,0);};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_eggc DrawContext )([]*Block ,DrawContext ,error );};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetTitle sets the title of the invoice.
func (_fdfg *Invoice )SetTitle (title string ){_fdfg ._eabe =title };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_dfdbg *Invoice )SetAddressStyle (style TextStyle ){_dfdbg ._geag =style };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_fbbc *Paragraph )SetMaxLines (maxLines int ){_fbbc ._cbef =maxLines ;_fbbc .wrapText ()};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_afbgd *Invoice )SetNoteStyle (style TextStyle ){_afbgd ._afgd =style };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_aaaff *Paragraph )SetColor (col Color ){_dadef :=_c .NewPdfColorDeviceRGB (col .ToRGB ());_aaaff ._ddba =*_dadef ;};func (_bab *Block )drawToPage (_egeb *_c .PdfPage )error {_beg :=&_ba .ContentStreamOperations {};if _egeb .Resources ==nil {_egeb .Resources =_c .NewPdfPageResources ();};_aca :=_efd (_beg ,_egeb .Resources ,_bab ._ca ,_bab ._ab );if _aca !=nil {return _aca ;};if _aca =_cgbb (_bab ._ab ,_egeb .Resources );_aca !=nil {return _aca ;};if _aca =_egeb .AppendContentBytes (_beg .Bytes (),true );_aca !=nil {return _aca ;};for _ ,_ggf :=range _bab ._agd {_egeb .AddAnnotation (_ggf );};return nil ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_gdcbf *Invoice )Notes ()(string ,string ){return _gdcbf ._bbfd [0],_gdcbf ._bbfd [1]};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cgff *Block )ScaleToHeight (h float64 ){_eba :=h /_cgff ._gg ;_cgff .Scale (_eba ,_eba )};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_fcae :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ga .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcae ;};var _ccd ,_fbg ,_bac int ;if len (hexStr )==4{var _cfff ,_dfd ,_bfe int ;_gfc ,_abc :=_af .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_cfff ,&_dfd ,&_bfe );if _abc !=nil {_ga .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_abc );return _fcae ;};if _gfc !=3{_ga .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcae ;};_ccd =_cfff *16+_cfff ;_fbg =_dfd *16+_dfd ;_bac =_bfe *16+_bfe ;}else {_dff ,_ecfc :=_af .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_ccd ,&_fbg ,&_bac );if _ecfc !=nil {_ga .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcae ;};if _dff !=3{_ga .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_dff );return _fcae ;};};_fdd :=float64 (_ccd )/255.0;_ffb :=float64 (_fbg )/255.0;_eec :=float64 (_bac )/255.0;_fcae ._ggd =_fdd ;_fcae ._gggcd =_ffb ;_fcae ._gcad =_eec ;return _fcae ;};func _bdag ()*Division {return &Division {_gab :[]VectorDrawable {}}};

// MoveX moves the drawing context to absolute position x.
func (_ebbb *Creator )MoveX (x float64 ){_ebbb ._eged .X =x };

// SetFillColor sets the fill color.
func (_aecc *Polygon )SetFillColor (color Color ){_aecc ._cdcg .FillColor =_c .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_aabf *Invoice )SetColumns (cols []*InvoiceCell ){_aabf ._fdfd =cols };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fcec *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _fcec ._dbcc [0],_fcec ._dbcc [1]};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_ggea float64 ;_agff float64 ;_debg float64 ;_bcee float64 ;_dgec *_c .PdfColorDeviceRGB ;_cbgf float64 ;_cfbgg *_c .PdfColorDeviceRGB ;_dcgc float64 ;_ceaa float64 ;};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_caca *Division )Width ()float64 {return 0};

// GetRowHeight returns the height of the specified row.
func (_gfdca *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gfdca ._ccaae ){return 0,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gfdca ._ccaae [row -1],nil ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_edb *Creator )NewImageFromGoImage (goimg _ag .Image )(*Image ,error ){return _bdfa (goimg )};

// Width returns the width of the Paragraph.
func (_fgga *StyledParagraph )Width ()float64 {if _fgga ._afgdg &&int (_fgga ._fbbf )> 0{return _fgga ._fbbf ;};return _fgga .getTextWidth ()/1000.0;};

// SetBorderWidth sets the border width.
func (_gcba *Ellipse )SetBorderWidth (bw float64 ){_gcba ._dce =bw };func (_gdef *Invoice )setCellBorder (_ccc *TableCell ,_gcgbd *InvoiceCell ){for _ ,_bdfg :=range _gcgbd .BorderSides {_ccc .SetBorder (_bdfg ,CellBorderStyleSingle ,_gcgbd .BorderWidth );};_ccc .SetBorderColor (_gcgbd .BorderColor );};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_gfag *StyledParagraph )Insert (index uint ,text string )*TextChunk {_efee :=uint (len (_gfag ._cfea ));if index > _efee {index =_efee ;};_geda :=NewTextChunk (text ,_gfag ._fbfe );_gfag ._cfea =append (_gfag ._cfea [:index ],append ([]*TextChunk {_geda },_gfag ._cfea [index :]...)...);_gfag .wrapText ();return _geda ;};

// SetBorderOpacity sets the border opacity.
func (_dbccb *Rectangle )SetBorderOpacity (opacity float64 ){_dbccb ._ceaa =opacity };

// TOC returns the table of contents component of the creator.
func (_cacb *Creator )TOC ()*TOC {return _cacb ._bcdg };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ccee *Creator )MoveDown (dy float64 ){_ccee ._eged .Y +=dy };

// SetBorderWidth sets the border width.
func (_gabc *Rectangle )SetBorderWidth (bw float64 ){_gabc ._dcgc =bw };

// SetAngle sets Image rotation angle in degrees.
func (_cdgc *Image )SetAngle (angle float64 ){_cdgc ._bdg =angle };

// Lines returns all the lines the table of contents has.
func (_egbc *TOC )Lines ()[]*TOCLine {return _egbc ._baag };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bbd *Block )ScaleToWidth (w float64 ){_ebc :=w /_bbd ._fe ;_bbd .Scale (_ebc ,_ebc )};

// SetFont sets the Paragraph's font.
func (_ddgc *Paragraph )SetFont (font *_c .PdfFont ){_ddgc ._feeda =font };

// SetStyleRight sets border style for right side.
func (_dae *border )SetStyleRight (style CellBorderStyle ){_dae ._cag =style };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_adg *Creator )NewPolyBezierCurve (curves []_ef .CubicBezierCurve )*PolyBezierCurve {return _feecg (curves );};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_dded float64 ;_bbaa float64 ;_ebae float64 ;_ffecc float64 ;_gbc *_c .PdfColorDeviceRGB ;_bafg float64 ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_ddfa *Invoice )SetNoteHeadingStyle (style TextStyle ){_ddfa ._ccag =style };

// NewImageFromData creates an Image from image data.
func (_afbad *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gbef (data )};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_befca *Creator )SetOptimizer (optimizer _c .Optimizer ){_befca ._fgbb =optimizer };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_cfcae *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _fdff (number ,title ,page ,level ,style );};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dbag *Creator )SetPageLabels (pageLabels _ec .PdfObject ){_dbag ._caad =pageLabels };

// AddTotalLine adds a new line in the invoice totals table.
func (_gdag *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gcde :=&InvoiceCell {_gdag ._feae ,desc };_cfbea :=&InvoiceCell {_gdag ._feae ,value };_gdag ._bdff =append (_gdag ._bdff ,[2]*InvoiceCell {_gcde ,_cfbea });return _gcde ,_cfbea ;};

// CurCol returns the currently active cell's column number.
func (_bcdf *Table )CurCol ()int {_cbdde :=(_bcdf ._abed -1)%(_bcdf ._ecgb )+1;return _cbdde };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_eaaa *TableCell )SetContent (vd VectorDrawable )error {switch _fbcc :=vd .(type ){case *Paragraph :if _fbcc ._faga {_fbcc ._aabde =true ;};_eaaa ._dbaec =vd ;case *StyledParagraph :if _fbcc ._eaaf {_fbcc ._afgdg =true ;};_eaaa ._dbaec =vd ;case *Image :_eaaa ._dbaec =vd ;case *Table :_eaaa ._dbaec =vd ;case *List :_eaaa ._dbaec =vd ;case *Division :_eaaa ._dbaec =vd ;default:_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _ec .ErrTypeError ;};return nil ;};

// SetBorderColor sets the border color.
func (_cbca *Ellipse )SetBorderColor (col Color ){_cbca ._dbeb =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_eabb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_eabb ._dcb ._eccf =left ;_eabb ._dcb ._gdce =right ;_eabb ._dcb ._efbe =top ;_eabb ._dcb ._abcd =bottom ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_fcee *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcee ._abb ._eccf ,_fcee ._abb ._gdce ,_fcee ._abb ._efbe ,_fcee ._abb ._abcd ;};

// NewImageFromFile creates an Image from a file.
func (_bcaa *Creator )NewImageFromFile (path string )(*Image ,error ){return _dfde (path )};

// SetAnnotation sets a annotation on a TextChunk.
func (_fcbbe *TextChunk )SetAnnotation (annotation *_c .PdfAnnotation ){_fcbbe ._cacaf =annotation };func (_cadg *Paragraph )getMaxLineWidth ()float64 {if _cadg ._ecca ==nil ||len (_cadg ._ecca )==0{_cadg .wrapText ();};var _ggega float64 ;for _ ,_daded :=range _cadg ._ecca {_fdaae :=_cadg .getTextLineWidth (_daded );if _fdaae > _ggega {_ggega =_fdaae ;};};return _ggega ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_ebee *TOC )SetHeading (text string ,style TextStyle ){_fbdd :=_ebee .Heading ();_fbdd .Reset ();_bdege :=_fbdd .Append (text );_bdege .Style =style ;};

// Columns returns all the columns in the invoice line items table.
func (_bddf *Invoice )Columns ()[]*InvoiceCell {return _bddf ._fdfd };func (_becbf *Paragraph )getTextWidth ()float64 {_efbc :=0.0;for _ ,_fbgf :=range _becbf ._bgcc {if _fbgf =='\u000A'{continue ;};_bfafb ,_adbaa :=_becbf ._feeda .GetRuneMetrics (_fbgf );if !_adbaa {_ga .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_fbgf ,_fbgf );return -1;};_efbc +=_becbf ._dgaa *_bfafb .Wx ;};return _efbc ;};

// SetDate sets the date of the invoice.
func (_adbbf *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_adbbf ._bccb [1].Value =date ;return _adbbf ._bccb [0],_adbbf ._bccb [1];};

// RotatedSize returns the width and height of the rotated block.
func (_dg *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_aba ,_efb :=_bdaeg (_dg ._fe ,_dg ._gg ,_dg ._aff );return _aba ,_efb ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gafcd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_defa ,_febd :=_gafcd .Wrap (width );if _febd !=nil {return nil ,_febd ;};_efaed :=int (height /_gafcd .Style .FontSize );if _efaed >=len (_defa ){return nil ,nil ;};_bdab :="\u000a";_gafcd .Text =_be .Replace (_be .Join (_defa [:_efaed ],"\u0020"),_bdab +"\u0020",_bdab ,-1);_fcdd :=_be .Replace (_be .Join (_defa [_efaed :],"\u0020"),_bdab +"\u0020",_bdab ,-1);return NewTextChunk (_fcdd ,_gafcd .Style ),nil ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_abd *Chapter )NewSubchapter (title string )*Chapter {_gcb :=_gcaee (_abd ._dcf ._feeda );_gcb .FontSize =14;_abd ._feef ++;_ffcb :=_effc (_abd ,_abd ._cdf ,_abd ._ceea ,title ,_abd ._feef ,_gcb );_abd .Add (_ffcb );return _ffcb ;};func (_dbcac *Paragraph )wrapText ()error {if !_dbcac ._aabde ||int (_dbcac ._adbbc )<=0{_dbcac ._ecca =[]string {_dbcac ._bgcc };return nil ;};_dedb :=NewTextChunk (_dbcac ._bgcc ,TextStyle {Font :_dbcac ._feeda ,FontSize :_dbcac ._dgaa });_bfcd ,_ebba :=_dedb .Wrap (_dbcac ._adbbc );if _ebba !=nil {return _ebba ;};if _dbcac ._cbef > 0&&len (_bfcd )> _dbcac ._cbef {_bfcd =_bfcd [:_dbcac ._cbef ];};_dbcac ._ecca =_bfcd ;return nil ;};func _fdff (_aaee ,_gagbe ,_dbff TextChunk ,_dgeb uint ,_ddgcg TextStyle )*TOCLine {_bbdg :=_abdg (_ddgcg );_bbdg .SetEnableWrap (true );_bbdg .SetTextAlignment (TextAlignmentLeft );_bbdg .SetMargins (0,0,2,2);_aebb :=&TOCLine {_afdf :_bbdg ,Number :_aaee ,Title :_gagbe ,Page :_dbff ,Separator :TextChunk {Text :"\u002e",Style :_ddgcg },_gagce :0,_cgca :_dgeb ,_cddd :10,_dgbba :_abfc };_bbdg ._fcgc ._eccf =_aebb ._gagce +float64 (_aebb ._cgca -1)*_aebb ._cddd ;_bbdg ._abae =_aebb .prepareParagraph ;return _aebb ;};

// NewPageBreak create a new page break.
func (_eegf *Creator )NewPageBreak ()*PageBreak {return _adce ()};type listItem struct{_daaa VectorDrawable ;_gaf TextChunk ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ea *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ce :=_ba .NewContentCreator ();_fee ,_gd :=_ea .Width (),_ea .Height ();if _ea ._agc .isRelative (){_ce .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gd );}else {_ce .Translate (_ea ._d ,ctx .PageHeight -_ea ._db -_gd );};_cff :=_gd ;if _ea ._aff !=0{_ce .Translate (_fee /2,_gd /2);_ce .RotateDeg (_ea ._aff );_ce .Translate (-_fee /2,-_gd /2);_ ,_cff =_ea .RotatedSize ();};if _ea ._agc .isRelative (){ctx .Y +=_cff ;};_dba :=_ea .duplicate ();_efe :=append (*_ce .Operations (),*_dba ._ca ...);_efe .WrapIfNeeded ();_dba ._ca =&_efe ;return []*Block {_dba },ctx ,nil ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_dad *Creator )RotateDeg (angleDeg int64 )error {_ged :=_dad .getActivePage ();if _ged ==nil {_ga .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ga .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bbbe int64 ;if _ged .Rotate !=nil {_bbbe =*(_ged .Rotate );};_bbbe +=angleDeg ;_ged .Rotate =&_bbbe ;return nil ;};func (_aea *Block )transform (_cfe _ee .Matrix ){_acbd :=_ba .NewContentCreator ().Add_cm (_cfe [0],_cfe [1],_cfe [3],_cfe [4],_cfe [6],_cfe [7]).Operations ();*_aea ._ca =append (*_acbd ,*_aea ._ca ...);_aea ._ca .WrapIfNeeded ();};func (_ggb *Block )addContents (_bb *_ba .ContentStreamOperations ){_ggb ._ca .WrapIfNeeded ();_bb .WrapIfNeeded ();*_ggb ._ca =append (*_ggb ._ca ,*_bb ...);};

// SetLineColor sets the line color.
func (_egec *Polyline )SetLineColor (color Color ){_egec ._gbefb .LineColor =_c .NewPdfColorDeviceRGB (color .ToRGB ());};

// MoveY moves the drawing context to absolute position y.
func (_cgea *Creator )MoveY (y float64 ){_cgea ._eged .Y =y };func (_cfba *StyledParagraph )getMaxLineWidth ()float64 {if _cfba ._baedf ==nil ||len (_cfba ._baedf )==0{_cfba .wrapText ();};var _gagaa float64 ;for _ ,_cebc :=range _cfba ._baedf {_befcd :=_cfba .getTextLineWidth (_cebc );if _befcd > _gagaa {_gagaa =_befcd ;};};return _gagaa ;};

// SetLineWidth sets the line width.
func (_acafc *Polyline )SetLineWidth (lineWidth float64 ){_acafc ._gbefb .LineWidth =lineWidth };

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_afdf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gagce float64 ;_cgca uint ;_cddd float64 ;_dgbba positioning ;_fdfbe float64 ;_dgdf float64 ;_aced int64 ;};

// SetMargins sets the margins of the paragraph.
func (_eedb *List )SetMargins (left ,right ,top ,bottom float64 ){_eedb ._gfeg ._eccf =left ;_eedb ._gfeg ._gdce =right ;_eedb ._gfeg ._efbe =top ;_eedb ._gfeg ._abcd =bottom ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_fae *Block )SetMargins (left ,right ,top ,bottom float64 ){_fae ._cf ._eccf =left ;_fae ._cf ._gdce =right ;_fae ._cf ._efbe =top ;_fae ._cf ._abcd =bottom ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bfga *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfga ._bcgb ._eccf ,_bfga ._bcgb ._gdce ,_bfga ._bcgb ._efbe ,_bfga ._bcgb ._abcd ;};

// SetLogo sets the logo of the invoice.
func (_dcdfa *Invoice )SetLogo (logo *Image ){_dcdfa ._bcga =logo };func _abdg (_bfdb TextStyle )*StyledParagraph {return &StyledParagraph {_cfea :[]*TextChunk {},_fbfe :_bfdb ,_cbbb :_caddf (_bfdb .Font ),_fdae :1.0,_dfge :TextAlignmentLeft ,_afgdg :true ,_eaaf :true ,_egda :0,_bcdcc :1,_fbeag :1,_cgdb :_abfc };};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cfea []*TextChunk ;_fbfe TextStyle ;_cbbb TextStyle ;_dfge TextAlignment ;_fdae float64 ;_afgdg bool ;_fbbf float64 ;_eaaf bool ;_egda float64 ;_fcgc margins ;_cgdb positioning ;_dcaa float64 ;_dfbd float64 ;_bcdcc float64 ;_fbeag float64 ;_baedf [][]*TextChunk ;_abae func (_fgfa *StyledParagraph ,_edbf DrawContext );};func (_dbc *Block )translate (_bg ,_gb float64 ){_gdd :=_ba .NewContentCreator ().Translate (_bg ,-_gb ).Operations ();*_dbc ._ca =append (*_gdd ,*_dbc ._ca ...);_dbc ._ca .WrapIfNeeded ();};

// Indent returns the left offset of the list when nested into another list.
func (_bea *List )Indent ()float64 {return _bea ._gbdg };func (_bce positioning )isAbsolute ()bool {return _bce ==_cdaa };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_dedd *List )Width ()float64 {return 0};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_fagd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_fagd ._ecgb {_ga .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fagd ._abac =widths ;return nil ;};func (_fccb *Creator )newPage ()*_c .PdfPage {_daf :=_c .NewPdfPage ();_aefe :=_fccb ._fafa [0];_gaa :=_fccb ._fafa [1];_dbf :=_c .PdfRectangle {Llx :0,Lly :0,Urx :_aefe ,Ury :_gaa };_daf .MediaBox =&_dbf ;_fccb ._ecbg =_aefe ;_fccb ._beeb =_gaa ;_fccb .initContext ();return _daf ;};

// SetHeight sets the Image's document height to specified h.
func (_bed *Image )SetHeight (h float64 ){_bed ._add =h };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_cgb *Block )AddAnnotation (annotation *_c .PdfAnnotation ){for _ ,_fab :=range _cgb ._agd {if _fab ==annotation {return ;};};_cgb ._agd =append (_cgb ._agd ,annotation );};

// SetMargins sets the margins TOC line.
func (_ggba *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_ggba ._gagce =left ;_gcgd :=&_ggba ._afdf ._fcgc ;_gcgd ._eccf =_ggba ._gagce +float64 (_ggba ._cgca -1)*_ggba ._cddd ;_gcgd ._gdce =right ;_gcgd ._efbe =top ;_gcgd ._abcd =bottom ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_dadec *Paragraph )SetEnableWrap (enableWrap bool ){_dadec ._aabde =enableWrap ;_dadec ._faga =false ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_bdf *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dddc :=ctx ;if _bdf ._aed .isRelative (){ctx .X +=_bdf ._acg ._eccf ;ctx .Y +=_bdf ._acg ._efbe ;ctx .Width -=_bdf ._acg ._eccf +_bdf ._acg ._gdce ;ctx .Height -=_bdf ._acg ._efbe ;};_adab ,_fgd ,_fedf :=_bdf ._dcf .GeneratePageBlocks (ctx );if _fedf !=nil {return _adab ,ctx ,_fedf ;};ctx =_fgd ;_gbdf :=ctx .X ;_ddcb :=ctx .Y -_bdf ._dcf .Height ();_eee :=int64 (ctx .Page );_befc :=_bdf .headingNumber ();_fcf :=_bdf .headingText ();if _bdf ._ceag {_bca :=_bdf ._cdf .Add (_befc ,_bdf ._cage ,_eg .FormatInt (_eee ,10),_bdf ._gbadd );if _bdf ._cdf ._gbgg {_bca .SetLink (_eee ,_gbdf ,_ddcb );};};if _bdf ._aaa ==nil {_bdf ._aaa =_c .NewOutlineItem (_fcf ,_c .NewOutlineDest (_eee -1,_gbdf ,_ddcb ));if _bdf ._ccf !=nil {_bdf ._ccf ._aaa .Add (_bdf ._aaa );}else {_bdf ._ceea .Add (_bdf ._aaa );};}else {_bgcb :=&_bdf ._aaa .Dest ;_bgcb .Page =_eee -1;_bgcb .X =_gbdf ;_bgcb .Y =_ddcb ;};for _ ,_cgd :=range _bdf ._bcgc {_dca ,_aedc ,_cced :=_cgd .GeneratePageBlocks (ctx );if _cced !=nil {return _adab ,ctx ,_cced ;};if len (_dca )< 1{continue ;};_adab [len (_adab )-1].mergeBlocks (_dca [0]);_adab =append (_adab ,_dca [1:]...);ctx =_aedc ;};if _bdf ._aed .isRelative (){ctx .X =_dddc .X ;};if _bdf ._aed .isAbsolute (){return _adab ,_dddc ,nil ;};return _adab ,ctx ,nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ca *_ba .ContentStreamOperations ;_ab *_c .PdfPageResources ;_agc positioning ;_d ,_db float64 ;_fe float64 ;_gg float64 ;_aff float64 ;_cf margins ;_agd []*_c .PdfAnnotation ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_eaga *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_ecdb :=&_eaga ._afdf ._fcgc ;return _eaga ._gagce ,_ecdb ._gdce ,_ecdb ._efbe ,_ecdb ._abcd ;};

// SetAngle sets the rotation angle of the text.
func (_ddeb *Paragraph )SetAngle (angle float64 ){_ddeb ._egf =angle };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_ggge *Rectangle )GetCoords ()(float64 ,float64 ){return _ggge ._ggea ,_ggge ._agff };

// SetFillOpacity sets the fill opacity.
func (_dacc *Polygon )SetFillOpacity (opacity float64 ){_dacc ._afdg =opacity };func (_fbf *Invoice )newCell (_beea string ,_gcccf InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gcccf ,_beea };};func (_fcfg *StyledParagraph )getTextWidth ()float64 {var _aece float64 ;_gbafg :=len (_fcfg ._cfea );for _adfb ,_eddd :=range _fcfg ._cfea {_baadg :=&_eddd .Style ;_dgdb :=len (_eddd .Text );for _ceba ,_efdcg :=range _eddd .Text {if _efdcg =='\u000A'{continue ;};_gaeb ,_cgdbb :=_baadg .Font .GetRuneMetrics (_efdcg );if !_cgdbb {_ga .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_efdcg );return -1;};_aece +=_baadg .FontSize *_gaeb .Wx ;if _efdcg !=' '&&(_adfb !=_gbafg -1||_ceba !=_dgdb -1){_aece +=_baadg .CharSpacing *1000.0;};};};return _aece ;};

// SkipCells skips over a specified number of cells in the table.
func (_ggbcg *Table )SkipCells (num int ){if num < 0{_ga .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ggbcg ._abed +=num ;};

// Cols returns the total number of columns the table has.
func (_fefc *Table )Cols ()int {return _fefc ._ecgb };

// SetWidth sets line width.
func (_gbac *Curve )SetWidth (width float64 ){_gbac ._ggeg =width };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_aaff *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_baga :=_ef .Circle {X :_aaff ._ffab -_aaff ._degg /2,Y :ctx .PageHeight -_aaff ._dgg -_aaff ._cfee /2,Width :_aaff ._degg ,Height :_aaff ._cfee ,Opacity :1.0,BorderWidth :_aaff ._dce };if _aaff ._bfdeb !=nil {_baga .FillEnabled =true ;_baga .FillColor =_aaff ._bfdeb ;};if _aaff ._dbeb !=nil {_baga .BorderEnabled =true ;_baga .BorderColor =_aaff ._dbeb ;_baga .BorderWidth =_aaff ._dce ;};_gbee ,_ ,_eaf :=_baga .Draw ("");if _eaf !=nil {return nil ,ctx ,_eaf ;};_eaf =_ffec .addContentsByString (string (_gbee ));if _eaf !=nil {return nil ,ctx ,_eaf ;};return []*Block {_ffec },ctx ,nil ;};func (_cbab *Invoice )drawAddress (_bdfc *InvoiceAddress )[]*StyledParagraph {var _dadf []*StyledParagraph ;if _bdfc .Heading !=""{_bdeb :=_abdg (_cbab ._ecbf );_bdeb .SetMargins (0,0,0,7);_bdeb .Append (_bdfc .Heading );_dadf =append (_dadf ,_bdeb );};_agge :=_abdg (_cbab ._geag );_agge .SetLineHeight (1.2);_dfa :=_bdfc .Separator ;if _dfa ==""{_dfa =_cbab ._gdgfb ;};_dcbg :=_bdfc .City ;if _bdfc .State !=""{if _dcbg !=""{_dcbg +=_dfa ;};_dcbg +=_bdfc .State ;};if _bdfc .Zip !=""{if _dcbg !=""{_dcbg +=_dfa ;};_dcbg +=_bdfc .Zip ;};if _bdfc .Name !=""{_agge .Append (_bdfc .Name +"\u000a");};if _bdfc .Street !=""{_agge .Append (_bdfc .Street +"\u000a");};if _bdfc .Street2 !=""{_agge .Append (_bdfc .Street2 +"\u000a");};if _dcbg !=""{_agge .Append (_dcbg +"\u000a");};if _bdfc .Country !=""{_agge .Append (_bdfc .Country +"\u000a");};_fdfe :=_abdg (_cbab ._geag );_fdfe .SetLineHeight (1.2);_fdfe .SetMargins (0,0,7,0);if _bdfc .Phone !=""{_fdfe .Append (_bdfc .fmtLine (_bdfc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_bdfc .HidePhoneLabel ));};if _bdfc .Email !=""{_fdfe .Append (_bdfc .fmtLine (_bdfc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_bdfc .HideEmailLabel ));};_dadf =append (_dadf ,_agge ,_fdfe );return _dadf ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// Height returns the height of the list.
func (_gebfa *List )Height ()float64 {var _cegf float64 ;for _ ,_fdfb :=range _gebfa ._ddg {_cegf +=_fdfb ._daaa .Height ();};return _cegf ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_gedb *Table )SetMargins (left ,right ,top ,bottom float64 ){_gedb ._abb ._eccf =left ;_gedb ._abb ._gdce =right ;_gedb ._abb ._efbe =top ;_gedb ._abb ._abcd =bottom ;};func (_efgcf *TOCLine )prepareParagraph (_cbce *StyledParagraph ,_dgfbe DrawContext ){_cebf :=_efgcf .Title .Text ;if _efgcf .Number .Text !=""{_cebf ="\u0020"+_cebf ;};_cebf +="\u0020";_cebfb :=_efgcf .Page .Text ;if _cebfb !=""{_cebfb ="\u0020"+_cebfb ;};_cbce ._cfea =[]*TextChunk {{Text :_efgcf .Number .Text ,Style :_efgcf .Number .Style ,_cacaf :_efgcf .getLineLink ()},{Text :_cebf ,Style :_efgcf .Title .Style ,_cacaf :_efgcf .getLineLink ()},{Text :_cebfb ,Style :_efgcf .Page .Style ,_cacaf :_efgcf .getLineLink ()}};_cbce .wrapText ();_gacgf :=len (_cbce ._baedf );if _gacgf ==0{return ;};_caafd :=_dgfbe .Width *1000-_cbce .getTextLineWidth (_cbce ._baedf [_gacgf -1]);_abcdd :=_cbce .getTextLineWidth ([]*TextChunk {&_efgcf .Separator });_abceb :=int (_caafd /_abcdd );_gbfg :=_be .Repeat (_efgcf .Separator .Text ,_abceb );_ecde :=_efgcf .Separator .Style ;_ddgd :=_cbce .Insert (2,_gbfg );_ddgd .Style =_ecde ;_ddgd ._cacaf =_efgcf .getLineLink ();_caafd =_caafd -float64 (_abceb )*_abcdd ;if _caafd > 500{_aaac ,_bfgf :=_ecde .Font .GetRuneMetrics (' ');if _bfgf &&_caafd > _aaac .Wx {_gfead :=int (_caafd /_aaac .Wx );if _gfead > 0{_degge :=_ecde ;_degge .FontSize =1;_ddgd =_cbce .Insert (2,_be .Repeat ("\u0020",_gfead ));_ddgd .Style =_degge ;_ddgd ._cacaf =_efgcf .getLineLink ();};};};};

// SetTerms sets the terms and conditions section of the invoice.
func (_adgba *Invoice )SetTerms (title ,content string ){_adgba ._ddag =[2]string {title ,content }};

// Reset removes all the text chunks the paragraph contains.
func (_egaab *StyledParagraph )Reset (){_egaab ._cfea =[]*TextChunk {}};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_fbbg *Image )ScaleToWidth (w float64 ){_eage :=_fbbg ._add /_fbbg ._aeeg ;_fbbg ._aeeg =w ;_fbbg ._add =w *_eage ;};

// Scale scales Image by a constant factor, both width and height.
func (_aadf *Image )Scale (xFactor ,yFactor float64 ){_aadf ._aeeg =xFactor *_aadf ._aeeg ;_aadf ._add =yFactor *_aadf ._add ;};func _bagg (_ccff ,_beeg ,_efedb string ,_bace uint ,_begd TextStyle )*TOCLine {return _fdff (TextChunk {Text :_ccff ,Style :_begd },TextChunk {Text :_beeg ,Style :_begd },TextChunk {Text :_efedb ,Style :_begd },_bace ,_begd );};

// SetFillOpacity sets the fill opacity.
func (_egb *PolyBezierCurve )SetFillOpacity (opacity float64 ){_egb ._ddcfb =opacity };func _bccbc (_fbc TextStyle )*List {return &List {_geeb :TextChunk {Text :"\u2022\u0020",Style :_fbc },_gbdg :0,_fede :true ,_fdbf :_abfc ,_caae :_fbc };};

// Invoice represents a configurable invoice template.
type Invoice struct{_eabe string ;_bcga *Image ;_gdb *InvoiceAddress ;_cfac *InvoiceAddress ;_gdgfb string ;_eacd [2]*InvoiceCell ;_bccb [2]*InvoiceCell ;_dbcc [2]*InvoiceCell ;_ecff [][2]*InvoiceCell ;_fdfd []*InvoiceCell ;_gfb [][]*InvoiceCell ;_eagg [2]*InvoiceCell ;_aegf [2]*InvoiceCell ;_bdff [][2]*InvoiceCell ;_bbfd [2]string ;_ddag [2]string ;_aeegf [][2]string ;_ggaa TextStyle ;_effa TextStyle ;_fcdg TextStyle ;_geag TextStyle ;_ecbf TextStyle ;_afgd TextStyle ;_ccag TextStyle ;_cgba InvoiceCellProps ;_dcab InvoiceCellProps ;_ddcd InvoiceCellProps ;_feae InvoiceCellProps ;_cbcb positioning ;};

// AppendColumn appends a column to the line items table.
func (_fddc *Invoice )AppendColumn (description string )*InvoiceCell {_degf :=_fddc .NewColumn (description );_fddc ._fdfd =append (_fddc ._fdfd ,_degf );return _degf ;};

// Lines returns all the rows of the invoice line items table.
func (_bdae *Invoice )Lines ()[][]*InvoiceCell {return _bdae ._gfb };func _dfc (_adfdd int64 ,_cbdg ,_ccbfd ,_afec float64 )*_c .PdfAnnotation {_gabg :=_c .NewPdfAnnotationLink ();_cffb :=_c .NewBorderStyle ();_cffb .SetBorderWidth (0);_gabg .BS =_cffb .ToPdfObject ();if _adfdd < 0{_adfdd =0;};_gabg .Dest =_ec .MakeArray (_ec .MakeInteger (_adfdd ),_ec .MakeName ("\u0058\u0059\u005a"),_ec .MakeFloat (_cbdg ),_ec .MakeFloat (_ccbfd ),_ec .MakeFloat (_afec ));return _gabg .PdfAnnotation ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_bdefc *List )SetIndent (indent float64 ){_bdefc ._gbdg =indent ;_bdefc ._fede =false };

// Width returns Image's document width.
func (_dffd *Image )Width ()float64 {return _dffd ._aeeg };

// SetInline sets the inline mode of the division.
func (_egee *Division )SetInline (inline bool ){_egee ._edae =inline };

// SetBorder sets the cell's border style.
func (_gffg *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gffg ._bagb =CellBorderStyleSingle ;_gffg ._eedfc =width ;_gffg ._efbea =CellBorderStyleSingle ;_gffg ._bedg =width ;_gffg ._gaac =CellBorderStyleSingle ;_gffg ._eadce =width ;_gffg ._fega =CellBorderStyleSingle ;_gffg ._ffce =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gffg ._bagb =CellBorderStyleDouble ;_gffg ._eedfc =width ;_gffg ._efbea =CellBorderStyleDouble ;_gffg ._bedg =width ;_gffg ._gaac =CellBorderStyleDouble ;_gffg ._eadce =width ;_gffg ._fega =CellBorderStyleDouble ;_gffg ._ffce =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gffg ._bagb =style ;_gffg ._eedfc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gffg ._efbea =style ;_gffg ._bedg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gffg ._gaac =style ;_gffg ._eadce =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gffg ._fega =style ;_gffg ._ffce =width ;};};

// BuyerAddress returns the buyer address used in the invoice template.
func (_agdgc *Invoice )BuyerAddress ()*InvoiceAddress {return _agdgc ._gdb };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cfcce *StyledParagraph )SetTextAlignment (align TextAlignment ){_cfcce ._dfge =align };

// SetColorBottom sets border color for bottom.
func (_bga *border )SetColorBottom (col Color ){_bga ._eff =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// WriteToFile writes the Creator output to file specified by path.
func (_bae *Creator )WriteToFile (outputPath string )error {_eedd ,_bded :=_e .Create (outputPath );if _bded !=nil {return _bded ;};defer _eedd .Close ();return _bae .Write (_eedd );};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_acf *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acf ._cceed ._eccf ,_acf ._cceed ._gdce ,_acf ._cceed ._efbe ,_acf ._cceed ._abcd ;};func _effc (_ecae *Chapter ,_fabb *TOC ,_gbb *_c .Outline ,_dcff string ,_cefa int ,_fba TextStyle )*Chapter {var _agcb uint =1;if _ecae !=nil {_agcb =_ecae ._gbadd +1;};_dbae :=&Chapter {_gge :_cefa ,_cage :_dcff ,_dcfb :true ,_ceag :true ,_ccf :_ecae ,_cdf :_fabb ,_ceea :_gbb ,_bcgc :[]Drawable {},_gbadd :_agcb };_feed :=_befa (_dbae .headingText (),_fba );_feed .SetFont (_fba .Font );_feed .SetFontSize (_fba .FontSize );_dbae ._dcf =_feed ;return _dbae ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_befb *Creator )CreateTableOfContents (genTOCFunc func (_dgcb *TOC )error ){_befb ._fbbd =genTOCFunc ;};

// SetColorRight sets border color for right.
func (_efaa *border )SetColorRight (col Color ){_efaa ._ecfb =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetBorderOpacity sets the border opacity.
func (_dcefc *Polygon )SetBorderOpacity (opacity float64 ){_dcefc ._bggb =opacity };

// The Image type is used to draw an image onto PDF.
type Image struct{_bbg *_c .XObjectImage ;_dbca *_c .Image ;_bdg float64 ;_aeeg ,_add float64 ;_cbe ,_fafd float64 ;_dade positioning ;_cfae HorizontalAlignment ;_cgg float64 ;_eeaf float64 ;_adcf float64 ;_cceed margins ;_dacb ,_bfge float64 ;_bece _ec .StreamEncoder ;};func (_gfbb *Invoice )newColumn (_bgad string ,_edf CellHorizontalAlignment )*InvoiceCell {_cafae :=&InvoiceCell {_gfbb ._dcab ,_bgad };_cafae .Alignment =_edf ;return _cafae ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_ffbdc *Line )SetColor (col Color ){_ffbdc ._gbc =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gge int ;_cage string ;_dcf *Paragraph ;_bcgc []Drawable ;_feef int ;_dcfb bool ;_ceag bool ;_aed positioning ;_daa ,_bccg float64 ;_acg margins ;_ccf *Chapter ;_cdf *TOC ;_ceea *_c .Outline ;_aaa *_c .OutlineItem ;_gbadd uint ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_gffb *Invoice )Terms ()(string ,string ){return _gffb ._ddag [0],_gffb ._ddag [1]};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_ggff *Image )SetEncoder (encoder _ec .StreamEncoder ){_ggff ._bece =encoder };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_effb *Creator )AddPage (page *_c .PdfPage )error {_dagb ,_cdff :=page .GetMediaBox ();if _cdff !=nil {_ga .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cdff );return _cdff ;};_dagb .Normalize ();_ggadf ,_aag :=_dagb .Llx ,_dagb .Lly ;_acdc :=_ee .IdentityMatrix ();_fbba :=page .Rotate ;_aeaa :=_fbba !=nil &&*_fbba %360!=0&&*_fbba %90==0;if _aeaa {_gaaf :=float64 ((360+*page .Rotate %360)%360);_acdc =_ee .RotationMatrix (_gaaf *_b .Pi /180);if _gaaf ==90{_acdc =_acdc .Translate (_dagb .Width (),0);}else if _gaaf ==180{_acdc =_acdc .Translate (_dagb .Width (),_dagb .Height ());}else if _gaaf ==270{_acdc =_acdc .Translate (0,_dagb .Height ());};_acdc =_acdc .Round (0.000001);_gdg :=_cadfa (_dagb ,_acdc );_dagb =_gdg ;_dagb .Normalize ();};if _ggadf !=0||_aag !=0{_acdc =_acdc .Translate (_ggadf ,_aag );};if !_acdc .Identity (){if _effb ._ggbd ==nil {_effb ._ggbd =map[*_c .PdfPage ]_ee .Matrix {};};_acdc =_acdc .Round (0.000001);_effb ._ggbd [page ]=_acdc ;};_effb ._ecbg =_dagb .Width ();_effb ._beeb =_dagb .Height ();_effb .initContext ();_effb ._fcc =append (_effb ._fcc ,page );_effb ._eged .Page ++;return nil ;};func _dece (_dfdb *_c .Image )(*Image ,error ){_ffef :=float64 (_dfdb .Width );_agb :=float64 (_dfdb .Height );return &Image {_dbca :_dfdb ,_cbe :_ffef ,_fafd :_agb ,_aeeg :_ffef ,_add :_agb ,_bdg :0,_adcf :1.0,_dade :_abfc },nil ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_cfga *Invoice )TitleStyle ()TextStyle {return _cfga ._fcdg };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_baca *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _baca ._bbg ==nil {if _fcg :=_baca .makeXObject ();_fcg !=nil {return nil ,ctx ,_fcg ;};};var _agcd []*Block ;_eece :=ctx ;_afaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _baca ._dade .isRelative (){if _baca ._add > ctx .Height {_agcd =append (_agcd ,_afaa );_afaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_afbg :=ctx ;_afbg .Y =ctx .Margins ._efbe ;_afbg .X =ctx .Margins ._eccf +_baca ._cceed ._eccf ;_afbg .Height =ctx .PageHeight -ctx .Margins ._efbe -ctx .Margins ._abcd -_baca ._cceed ._abcd ;_afbg .Width =ctx .PageWidth -ctx .Margins ._eccf -ctx .Margins ._gdce -_baca ._cceed ._eccf -_baca ._cceed ._gdce ;ctx =_afbg ;}else {ctx .Y +=_baca ._cceed ._efbe ;ctx .Height -=_baca ._cceed ._efbe +_baca ._cceed ._abcd ;ctx .X +=_baca ._cceed ._eccf ;ctx .Width -=_baca ._cceed ._eccf +_baca ._cceed ._gdce ;};}else {ctx .X =_baca ._cgg ;ctx .Y =_baca ._eeaf ;};ctx ,_ecbgb :=_befbf (_afaa ,_baca ,ctx );if _ecbgb !=nil {return nil ,ctx ,_ecbgb ;};_agcd =append (_agcd ,_afaa );if _baca ._dade .isAbsolute (){ctx =_eece ;}else {ctx .Y +=_baca ._cceed ._abcd ;ctx .Height -=_baca ._cceed ._abcd ;};return _agcd ,ctx ,nil ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_daag *Chapter )SetShowNumbering (show bool ){_daag ._dcfb =show ;_daag ._dcf .SetText (_daag .headingText ());};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_cfbef *Table )NewCell ()*TableCell {return _cfbef .newCell (1)};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gddd *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aaab :=ctx ;_cdb :=[]func (_fcga DrawContext )([]*Block ,DrawContext ,error ){_gddd .generateHeaderBlocks ,_gddd .generateInformationBlocks ,_gddd .generateLineBlocks ,_gddd .generateTotalBlocks ,_gddd .generateNoteBlocks };var _edec []*Block ;for _ ,_dcfbf :=range _cdb {_edfb ,_ccbf ,_bacc :=_dcfbf (ctx );if _bacc !=nil {return _edec ,ctx ,_bacc ;};if len (_edec )==0{_edec =_edfb ;}else if len (_edfb )> 0{_edec [len (_edec )-1].mergeBlocks (_edfb [0]);_edec =append (_edec ,_edfb [1:]...);};ctx =_ccbf ;};if _gddd ._cbcb .isRelative (){ctx .X =_aaab .X ;};if _gddd ._cbcb .isAbsolute (){return _edec ,_aaab ,nil ;};return _edec ,ctx ,nil ;};func (_bfb *Image )makeXObject ()error {_fdcdc :=_bfb ._bece ;if _fdcdc ==nil {_fdcdc =_ec .NewFlateEncoder ();};_bbca ,_gbf :=_c .NewXObjectImageFromImage (_bfb ._dbca ,nil ,_fdcdc );if _gbf !=nil {_ga .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gbf );return _gbf ;};_bfb ._bbg =_bbca ;return nil ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// CreateFrontPage sets a function to generate a front Page.
func (_cabd *Creator )CreateFrontPage (genFrontPageFunc func (_gde FrontpageFunctionArgs )){_cabd ._ecea =genFrontPageFunc ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_cbdf *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fbbab (xc ,yc ,width ,height );};

// SetLineHeight sets the line height (1.0 default).
func (_cfbc *StyledParagraph )SetLineHeight (lineheight float64 ){_cfbc ._fdae =lineheight };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_gbdgd *_ef .PolyBezierCurve ;_ddcfb float64 ;_bfeb float64 ;};

// SetDueDate sets the due date of the invoice.
func (_dgdd *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_dgdd ._dbcc [1].Value =dueDate ;return _dgdd ._dbcc [0],_dgdd ._dbcc [1];};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_cdcg *_ef .Polygon ;_afdg float64 ;_bggb float64 ;};func _cdba (_gcbaf ,_fde ,_affba ,_bgfd float64 )*Rectangle {return &Rectangle {_ggea :_gcbaf ,_agff :_fde ,_debg :_affba ,_bcee :_bgfd ,_cfbgg :_c .NewPdfColorDeviceRGB (0,0,0),_dcgc :1.0,_cbgf :1.0,_ceaa :1.0};};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dceae *TOC )SetLineSeparatorStyle (style TextStyle ){_dceae ._egabb =style };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_edfc *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fabc float64 ;var _ccgd []*StyledParagraph ;for _ ,_gagc :=range _edfc ._ddg {_dffec :=_abdg (_edfc ._caae );_dffec .SetEnableWrap (false );_dffec .SetTextAlignment (TextAlignmentRight );_dffec .Append (_gagc ._gaf .Text ).Style =_gagc ._gaf .Style ;_dbce :=_dffec .getTextWidth ()/1000.0/ctx .Width ;if _fabc < _dbce {_fabc =_dbce ;};_ccgd =append (_ccgd ,_dffec );};_aadg :=_eaed (2);_aadg .SetColumnWidths (_fabc ,1-_fabc );_aadg .SetMargins (_edfc ._gbdg ,0,0,0);for _dbgc ,_acgb :=range _edfc ._ddg {_eae :=_aadg .NewCell ();_eae .SetIndent (0);_eae .SetContent (_ccgd [_dbgc ]);_eae =_aadg .NewCell ();_eae .SetIndent (0);_eae .SetContent (_acgb ._daaa );};return _aadg .GeneratePageBlocks (ctx );};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_fcc []*_c .PdfPage ;_bff map[*_c .PdfPage ]*Block ;_ggbd map[*_c .PdfPage ]_ee .Matrix ;_baff *_c .PdfPage ;_fafa PageSize ;_eged DrawContext ;_dcb margins ;_ecbg ,_beeb float64 ;_fegg int ;_ecea func (_ecac FrontpageFunctionArgs );_fbbd func (_bbc *TOC )error ;_cefd func (_cbf *Block ,_ccg HeaderFunctionArgs );_gdc func (_cbgd *Block ,_bbee FooterFunctionArgs );_abe func (_cfgca *_c .PdfWriter )error ;_cgec bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_bcdg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_eab *_c .Outline ;_ceg *_c .PdfOutlineTreeNode ;_efdg *_c .PdfAcroForm ;_caad _ec .PdfObject ;_fgbb _c .Optimizer ;_cecd []*_c .PdfFont ;_fbea *_c .PdfFont ;_adbb *_c .PdfFont ;};func (_fgae *FilledCurve )draw (_gaea string )([]byte ,*_c .PdfRectangle ,error ){_bfae :=_ef .NewCubicBezierPath ();for _ ,_edgaa :=range _fgae ._gccf {_bfae =_bfae .AppendCurve (_edgaa );};creator :=_ba .NewContentCreator ();creator .Add_q ();if _fgae .FillEnabled {creator .Add_rg (_fgae ._feggc .R (),_fgae ._feggc .G (),_fgae ._feggc .B ());};if _fgae .BorderEnabled {creator .Add_RG (_fgae ._bbcda .R (),_fgae ._bbcda .G (),_fgae ._bbcda .B ());creator .Add_w (_fgae .BorderWidth );};if len (_gaea )> 1{creator .Add_gs (_ec .PdfObjectName (_gaea ));};_ef .DrawBezierPathWithCreator (_bfae ,creator );creator .Add_h ();if _fgae .FillEnabled &&_fgae .BorderEnabled {creator .Add_B ();}else if _fgae .FillEnabled {creator .Add_f ();}else if _fgae .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_fffe :=_bfae .GetBoundingBox ();if _fgae .BorderEnabled {_fffe .Height +=_fgae .BorderWidth ;_fffe .Width +=_fgae .BorderWidth ;_fffe .X -=_fgae .BorderWidth /2;_fffe .Y -=_fgae .BorderWidth /2;};_gdad :=&_c .PdfRectangle {};_gdad .Llx =_fffe .X ;_gdad .Lly =_fffe .Y ;_gdad .Urx =_fffe .X +_fffe .Width ;_gdad .Ury =_fffe .Y +_fffe .Height ;return creator .Bytes (),_gdad ,nil ;};

// SetNumber sets the number of the invoice.
func (_gbbg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gbbg ._eacd [1].Value =number ;return _gbbg ._eacd [0],_gbbg ._eacd [1];};

// SetFontSize sets the font size in document units (points).
func (_ffed *Paragraph )SetFontSize (fontSize float64 ){_ffed ._dgaa =fontSize };var PPMM =float64 (72*1.0/25.4);func _feecg (_bgaf []_ef .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_gbdgd :&_ef .PolyBezierCurve {Curves :_bgaf ,BorderColor :_c .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_ddcfb :1.0,_bfeb :1.0};};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_ageb *Image )ConvertToBinary ()error {return _ageb ._dbca .ConvertToBinary ()};func _dfde (_efdf string )(*Image ,error ){_gcaf ,_fef :=_e .Open (_efdf );if _fef !=nil {return nil ,_fef ;};defer _gcaf .Close ();_cabg ,_fef :=_c .ImageHandling .Read (_gcaf );if _fef !=nil {_ga .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fef );return nil ,_fef ;};return _dece (_cabg );};func (_fedeg *StyledParagraph )appendChunk (_egad *TextChunk )*TextChunk {_fedeg ._cfea =append (_fedeg ._cfea ,_egad );_fedeg .wrapText ();return _egad ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ddge *List )Marker ()*TextChunk {return &_ddge ._geeb };

// GetCoords returns coordinates of border.
func (_bgc *border )GetCoords ()(float64 ,float64 ){return _bgc ._agf ,_bgc ._aef };

// Height returns the height for the Division component assuming all stacked on top of each other.
func (_eegc *Division )Height ()float64 {_ebdb :=0.0;_eada :=0.0;for _ ,_cdac :=range _eegc ._gab {_ceb ,_efde :=_cdac .Width (),_cdac .Height ();switch _dcba :=_cdac .(type ){case *Paragraph :_adf :=_dcba ;_ceb +=_adf ._bcgb ._eccf +_adf ._bcgb ._gdce ;_efde +=_adf ._bcgb ._efbe +_adf ._bcgb ._abcd ;case *StyledParagraph :_dadb :=_dcba ;_ceb +=_dadb ._fcgc ._eccf +_dadb ._fcgc ._gdce ;_efde +=_dadb ._fcgc ._efbe +_dadb ._fcgc ._abcd ;};_ebdb +=_efde ;_eada =_ebdb ;};return _eada ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_fafg *StyledParagraph )SetText (text string )*TextChunk {_fafg .Reset ();return _fafg .Append (text );};

// DrawFooter sets a function to draw a footer on created output pages.
func (_bag *Creator )DrawFooter (drawFooterFunc func (_dbb *Block ,_eacc FooterFunctionArgs )){_bag ._gdc =drawFooterFunc ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_gccc *Image )ScaleToHeight (h float64 ){_bbcg :=_gccc ._aeeg /_gccc ._add ;_gccc ._add =h ;_gccc ._aeeg =h *_bbcg ;};

// SetFillColor sets background color for border.
func (_fac *border )SetFillColor (col Color ){_fac ._cfg =_c .NewPdfColorDeviceRGB (col .ToRGB ())};func (_ffaeb *StyledParagraph )getTextHeight ()float64 {var _dccbf float64 ;for _ ,_egab :=range _ffaeb ._cfea {_eegce :=_egab .Style .FontSize *_ffaeb ._fdae ;if _eegce > _dccbf {_dccbf =_eegce ;};};return _dccbf ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ggca *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _acdg (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_gab []VectorDrawable ;_faec positioning ;_gcceg margins ;_edae bool ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ebcb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ebcb ._cfae };

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_eddc *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_degb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abg :=_ef .Line {LineWidth :_eddc ._bafg ,Opacity :1.0,LineColor :_eddc ._gbc ,LineEndingStyle1 :_ef .LineEndingStyleNone ,LineEndingStyle2 :_ef .LineEndingStyleNone ,X1 :_eddc ._dded ,Y1 :ctx .PageHeight -_eddc ._bbaa ,X2 :_eddc ._ebae ,Y2 :ctx .PageHeight -_eddc ._ffecc };_cde ,_ ,_dgeg :=_abg .Draw ("");if _dgeg !=nil {return nil ,ctx ,_dgeg ;};_dgeg =_degb .addContentsByString (string (_cde ));if _dgeg !=nil {return nil ,ctx ,_dgeg ;};return []*Block {_degb },ctx ,nil ;};type margins struct{_eccf float64 ;_gdce float64 ;_efbe float64 ;_abcd float64 ;};

// NewColumn returns a new column for the line items invoice table.
func (_geac *Invoice )NewColumn (description string )*InvoiceCell {return _geac .newColumn (description ,CellHorizontalAlignmentLeft );};

// Angle returns the block rotation angle in degrees.
func (_cb *Block )Angle ()float64 {return _cb ._aff };

// NewPolygon creates a new polygon.
func (_ccde *Creator )NewPolygon (points [][]_ef .Point )*Polygon {return _dagbb (points )};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_gbefb *_ef .Polyline ;_ebfg float64 ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adag *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _adag ._eacd [0],_adag ._eacd [1]};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_adge *List )Add (item VectorDrawable )(*TextChunk ,error ){_effe :=&listItem {_daaa :item ,_gaf :_adge ._geeb };switch _fdgdb :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fdgdb ._fede {_fdgdb ._gbdg =15;};default:return nil ,_f .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_adge ._ddg =append (_adge ._ddg ,_effe );return &_effe ._gaf ,nil ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// Title returns the title of the invoice.
func (_afab *Invoice )Title ()string {return _afab ._eabe };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_fdbgc *TOCLine )SetLink (page int64 ,x ,y float64 ){_fdbgc ._fdfbe =x ;_fdbgc ._dgdf =y ;_fdbgc ._aced =page ;_dbaf :=_fdbgc ._afdf ._cbbb .Color ;_fdbgc .Number .Style .Color =_dbaf ;_fdbgc .Title .Style .Color =_dbaf ;_fdbgc .Separator .Style .Color =_dbaf ;_fdbgc .Page .Style .Color =_dbaf ;};

// Heading returns the heading component of the table of contents.
func (_dgbd *TOC )Heading ()*StyledParagraph {return _dgbd ._aaea };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ecab *Invoice )TotalLines ()[][2]*InvoiceCell {_gdgdb :=[][2]*InvoiceCell {_ecab ._eagg };_gdgdb =append (_gdgdb ,_ecab ._bdff ...);return append (_gdgdb ,_ecab ._aegf );};type rgbColor struct{_ggd ,_gggcd ,_gcad float64 };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bec *Creator )NewPage ()*_c .PdfPage {_dedf :=_bec .newPage ();_bec ._fcc =append (_bec ._fcc ,_dedf );_bec ._eged .Page ++;return _dedf ;};

// SetLineWidth sets the line width.
func (_bcce *Line )SetLineWidth (lw float64 ){_bcce ._bafg =lw };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_aaea *StyledParagraph ;_baag []*TOCLine ;_aagd TextStyle ;_dfgea TextStyle ;_egabb TextStyle ;_accfc TextStyle ;_aadc string ;_dced float64 ;_edeef margins ;_gece positioning ;_dbeeg TextStyle ;_gbgg bool ;};var PPI float64 =72;

// SetLineOpacity sets the line opacity.
func (_efabg *Polyline )SetLineOpacity (opacity float64 ){_efabg ._ebfg =opacity };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_ffab float64 ;_dgg float64 ;_degg float64 ;_cfee float64 ;_bfdeb *_c .PdfColorDeviceRGB ;_dbeb *_c .PdfColorDeviceRGB ;_dce float64 ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_ffbe *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_ffbe .Text },nil ;};var _gfgb []string ;var _bcbd []rune ;var _afbgc float64 ;var _deeag []float64 ;_dcfbb :=_ffbe .Style ;_feeg :=[]rune (_ffbe .Text );for _ ,_cbed :=range _feeg {if _cbed =='\u000A'{_gfgb =append (_gfgb ,_be .TrimRightFunc (string (_bcbd ),_fa .IsSpace )+string (_cbed ));_bcbd =nil ;_afbgc =0;_deeag =nil ;continue ;};_abccd :=_cbed ==' ';_eccga ,_ffdf :=_dcfbb .Font .GetRuneMetrics (_cbed );if !_ffdf {_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cbed ,_cbed ,_dcfbb .Font .BaseFont (),_dcfbb .Font .Subtype ());_ga .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dcfbb .Font );_ga .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dcfbb .Font .Encoder ());return nil ,_f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_edbc :=_dcfbb .FontSize *_eccga .Wx ;_fafb :=_edbc ;if !_abccd {_fafb =_edbc +_dcfbb .CharSpacing *1000.0;};if _afbgc +_edbc > width *1000.0{_gddff :=-1;if !_abccd {for _gcgcf :=len (_bcbd )-1;_gcgcf >=0;_gcgcf --{if _bcbd [_gcgcf ]==' '{_gddff =_gcgcf ;break ;};};};_abbfa :=string (_bcbd );if _gddff > 0{_abbfa =string (_bcbd [0:_gddff +1]);_bcbd =append (_bcbd [_gddff +1:],_cbed );_deeag =append (_deeag [_gddff +1:],_fafb );_afbgc =0;for _ ,_adfg :=range _deeag {_afbgc +=_adfg ;};}else {if _abccd {_bcbd =[]rune {};_deeag =[]float64 {};_afbgc =0;}else {_bcbd =[]rune {_cbed };_deeag =[]float64 {_fafb };_afbgc =_fafb ;};};_gfgb =append (_gfgb ,_be .TrimRightFunc (_abbfa ,_fa .IsSpace ));}else {_bcbd =append (_bcbd ,_cbed );_afbgc +=_fafb ;_deeag =append (_deeag ,_fafb );};};if len (_bcbd )> 0{_gfgb =append (_gfgb ,string (_bcbd ));};return _gfgb ,nil ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_dccb *Paragraph )Height ()float64 {_dccb .wrapText ();return float64 (len (_dccb ._ecca ))*_dccb ._gaga *_dccb ._dgaa ;};

// SetPos sets absolute positioning with specified coordinates.
func (_aefdf *Paragraph )SetPos (x ,y float64 ){_aefdf ._cbade =_cdaa ;_aefdf ._bgeg =x ;_aefdf ._adabb =y ;};func _dagbb (_afaba [][]_ef .Point )*Polygon {return &Polygon {_cdcg :&_ef .Polygon {Points :_afaba },_afdg :1.0,_bggb :1.0};};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gdfg *TableCell )SetBorderLineStyle (style _ef .LineStyle ){_gdfg ._fbbb =style };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// NewTable create a new Table with a specified number of columns.
func (_fcd *Creator )NewTable (cols int )*Table {return _eaed (cols )};func (_caeea *Table )resetColumnWidths (){_caeea ._abac =[]float64 {};_fgbe :=float64 (1.0)/float64 (_caeea ._ecgb );for _degae :=0;_degae < _caeea ._ecgb ;_degae ++{_caeea ._abac =append (_caeea ._abac ,_fgbe );};};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ecdd *TOC )SetLineTitleStyle (style TextStyle ){_ecdd ._dfgea =style };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_geae *Paragraph )SetTextAlignment (align TextAlignment ){_geae ._aeed =align };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_fgdc *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cafeb :=ctx ;var _gddg []*Block ;_gfdbg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fgdc ._cbade .isRelative (){ctx .X +=_fgdc ._bcgb ._eccf ;ctx .Y +=_fgdc ._bcgb ._efbe ;ctx .Width -=_fgdc ._bcgb ._eccf +_fgdc ._bcgb ._gdce ;ctx .Height -=_fgdc ._bcgb ._efbe +_fgdc ._bcgb ._abcd ;_fgdc .SetWidth (ctx .Width );if _fgdc .Height ()> ctx .Height {_gddg =append (_gddg ,_gfdbg );_gfdbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_edc :=ctx ;_edc .Y =ctx .Margins ._efbe ;_edc .X =ctx .Margins ._eccf +_fgdc ._bcgb ._eccf ;_edc .Height =ctx .PageHeight -ctx .Margins ._efbe -ctx .Margins ._abcd -_fgdc ._bcgb ._abcd ;_edc .Width =ctx .PageWidth -ctx .Margins ._eccf -ctx .Margins ._gdce -_fgdc ._bcgb ._eccf -_fgdc ._bcgb ._gdce ;ctx =_edc ;};}else {if int (_fgdc ._adbbc )<=0{_fgdc .SetWidth (_fgdc .getTextWidth ());};ctx .X =_fgdc ._bgeg ;ctx .Y =_fgdc ._adabb ;};ctx ,_fbae :=_eabbc (_gfdbg ,_fgdc ,ctx );if _fbae !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbae );return nil ,ctx ,_fbae ;};_gddg =append (_gddg ,_gfdbg );if _fgdc ._cbade .isRelative (){ctx .X -=_fgdc ._bcgb ._eccf ;ctx .Width =_cafeb .Width ;return _gddg ,ctx ,nil ;};return _gddg ,_cafeb ,nil ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_agg *Image )SetMargins (left ,right ,top ,bottom float64 ){_agg ._cceed ._eccf =left ;_agg ._cceed ._gdce =right ;_agg ._cceed ._efbe =top ;_agg ._cceed ._abcd =bottom ;};func _efd (_cea *_ba .ContentStreamOperations ,_feg *_c .PdfPageResources ,_gag *_ba .ContentStreamOperations ,_gfg *_c .PdfPageResources )error {_gae :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};_gfa :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};_fca :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};_bcc :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};_ebf :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};_fg :=map[_ec .PdfObjectName ]_ec .PdfObjectName {};for _ ,_cbd :=range *_gag {switch _cbd .Operand {case "\u0044\u006f":if len (_cbd .Params )==1{if _ebfd ,_agca :=_cbd .Params [0].(*_ec .PdfObjectName );_agca {if _ ,_caf :=_gae [*_ebfd ];!_caf {var _beb _ec .PdfObjectName ;_bgg ,_ :=_gfg .GetXObjectByName (*_ebfd );if _bgg !=nil {_beb =*_ebfd ;for {_gggc ,_ :=_feg .GetXObjectByName (_beb );if _gggc ==nil ||_gggc ==_bgg {break ;};_beb =_beb +"\u0030";};};_feg .SetXObjectByName (_beb ,_bgg );_gae [*_ebfd ]=_beb ;};_eag :=_gae [*_ebfd ];_cbd .Params [0]=&_eag ;};};case "\u0054\u0066":if len (_cbd .Params )==2{if _ebe ,_caa :=_cbd .Params [0].(*_ec .PdfObjectName );_caa {if _ ,_dcdf :=_gfa [*_ebe ];!_dcdf {_cfb ,_cfeg :=_gfg .GetFontByName (*_ebe );_da :=*_ebe ;if _cfeg &&_cfb !=nil {_da =_ddf (_ebe .String (),_cfb ,_feg );};_feg .SetFontByName (_da ,_cfb );_gfa [*_ebe ]=_da ;};_faf :=_gfa [*_ebe ];_cbd .Params [0]=&_faf ;};};case "\u0043\u0053","\u0063\u0073":if len (_cbd .Params )==1{if _fea ,_begf :=_cbd .Params [0].(*_ec .PdfObjectName );_begf {if _ ,_dcc :=_fca [*_fea ];!_dcc {var _ecf _ec .PdfObjectName ;_cef ,_dee :=_gfg .GetColorspaceByName (*_fea );if _dee {_ecf =*_fea ;for {_ggad ,_fbdf :=_feg .GetColorspaceByName (_ecf );if !_fbdf ||_cef ==_ggad {break ;};_ecf =_ecf +"\u0030";};_feg .SetColorspaceByName (_ecf ,_cef );_fca [*_fea ]=_ecf ;}else {_ga .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _cee ,_gdf :=_fca [*_fea ];_gdf {_cbd .Params [0]=&_cee ;}else {_ga .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_fea );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_cbd .Params )==1{if _adb ,_bba :=_cbd .Params [0].(*_ec .PdfObjectName );_bba {if _ ,_gac :=_bcc [*_adb ];!_gac {var _ggc _ec .PdfObjectName ;_ecb ,_fgb :=_gfg .GetPatternByName (*_adb );if _fgb {_ggc =*_adb ;for {_cfd ,_abfa :=_feg .GetPatternByName (_ggc );if !_abfa ||_cfd ==_ecb {break ;};_ggc =_ggc +"\u0030";};_aad :=_feg .SetPatternByName (_ggc ,_ecb .ToPdfObject ());if _aad !=nil {return _aad ;};_bcc [*_adb ]=_ggc ;};};if _bbae ,_eaca :=_bcc [*_adb ];_eaca {_cbd .Params [0]=&_bbae ;};};};case "\u0073\u0068":if len (_cbd .Params )==1{if _ece ,_acbc :=_cbd .Params [0].(*_ec .PdfObjectName );_acbc {if _ ,_eaa :=_ebf [*_ece ];!_eaa {var _fce _ec .PdfObjectName ;_bde ,_fge :=_gfg .GetShadingByName (*_ece );if _fge {_fce =*_ece ;for {_dda ,_acdb :=_feg .GetShadingByName (_fce );if !_acdb ||_bde ==_dda {break ;};_fce =_fce +"\u0030";};_cefb :=_feg .SetShadingByName (_fce ,_bde .ToPdfObject ());if _cefb !=nil {_ga .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_cefb );return _cefb ;};_ebf [*_ece ]=_fce ;}else {_ga .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cbg ,_fgc :=_ebf [*_ece ];_fgc {_cbd .Params [0]=&_cbg ;}else {_ga .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ece );};};};case "\u0067\u0073":if len (_cbd .Params )==1{if _cec ,_bgb :=_cbd .Params [0].(*_ec .PdfObjectName );_bgb {if _ ,_aeb :=_fg [*_cec ];!_aeb {var _edg _ec .PdfObjectName ;_cgc ,_ddca :=_gfg .GetExtGState (*_cec );if _ddca {_edg =*_cec ;_ddad :=1;for {_bfd ,_bdca :=_feg .GetExtGState (_edg );if !_bdca ||_cgc ==_bfd {break ;};_edg =_ec .PdfObjectName (_af .Sprintf ("\u0047\u0053\u0025\u0064",_ddad ));_ddad ++;};};_feg .AddExtGState (_edg ,_cgc );_fg [*_cec ]=_edg ;};_fff :=_fg [*_cec ];_cbd .Params [0]=&_fff ;};};};*_cea =append (*_cea ,_cbd );};return nil ;};

// SetBorderWidth sets the border width.
func (_bdbce *Polygon )SetBorderWidth (borderWidth float64 ){_bdbce ._cdcg .BorderWidth =borderWidth };func (_fegd *StyledParagraph )getLineHeight (_agfa int )(_dcega ,_bgca float64 ){if _fegd ._baedf ==nil ||len (_fegd ._baedf )==0{_fegd .wrapText ();};if _agfa < 0||_agfa > len (_fegd ._baedf )-1{_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_agfa );return 0,0;};_cffd :=_fegd ._baedf [_agfa ];for _ ,_fafff :=range _cffd {_bbgb ,_adbbd :=_fafff .Style .Font .GetFontDescriptor ();if _adbbd !=nil {_ga .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fabcg float64 ;if _bbgb !=nil {if _fabcg ,_adbbd =_bbgb .GetCapHeight ();_adbbd !=nil {_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_adbbd );};};if int (_fabcg )<=0{_ga .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fabcg =1000;};_cga :=_fabcg /1000.0*_fafff .Style .FontSize *_fegd ._fdae ;if _cga > _dcega {_dcega =_cga ;};_cga =_fegd ._fdae *_fafff .Style .FontSize ;if _cga > _bgca {_bgca =_cga ;};};return _dcega ,_bgca ;};func (_gagd *StyledParagraph )getTextLineWidth (_gbbca []*TextChunk )float64 {var _bfbg float64 ;_facg :=len (_gbbca );for _dcefe ,_bgfda :=range _gbbca {_efadf :=&_bgfda .Style ;_gebc :=len (_bgfda .Text );for _bcca ,_fedfd :=range _bgfda .Text {if _fedfd =='\u000A'{continue ;};_cbbbg ,_cdea :=_efadf .Font .GetRuneMetrics (_fedfd );if !_cdea {_ga .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fedfd );return -1;};_bfbg +=_efadf .FontSize *_cbbbg .Wx ;if _fedfd !=' '&&(_dcefe !=_facg -1||_bcca !=_gebc -1){_bfbg +=_efadf .CharSpacing *1000.0;};};};return _bfbg ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_caacc *StyledParagraph )wrapText ()error {if !_caacc ._afgdg ||int (_caacc ._fbbf )<=0{_caacc ._baedf =[][]*TextChunk {_caacc ._cfea };return nil ;};_caacc ._baedf =[][]*TextChunk {};var _aecca []*TextChunk ;var _gbba float64 ;_fgba :=func (_ffba *_c .PdfAnnotation )*_c .PdfAnnotation {if _ffba ==nil {return nil ;};var _dbgg *_c .PdfAnnotation ;switch _eaeg :=_ffba .GetContext ().(type ){case *_c .PdfAnnotationLink :if _cfbad :=_eaeb (_eaeg );_cfbad !=nil {_dbgg =_cfbad .PdfAnnotation ;};};return _dbgg ;};for _ ,_bcef :=range _caacc ._cfea {_abcc :=_bcef .Style ;_ebbad :=_bcef ._cacaf ;var (_gdaf []rune ;_def []float64 ;);for _ ,_fddg :=range _bcef .Text {if _fddg =='\u000A'{_aecca =append (_aecca ,&TextChunk {Text :_be .TrimRightFunc (string (_gdaf ),_fa .IsSpace ),Style :_abcc ,_cacaf :_fgba (_ebbad )});_caacc ._baedf =append (_caacc ._baedf ,_aecca );_aecca =nil ;_gbba =0;_gdaf =nil ;_def =nil ;continue ;};_fedg :=_fddg ==' ';_eaec ,_edcc :=_abcc .Font .GetRuneMetrics (_fddg );if !_edcc {_ga .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fddg );return _f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ebgc :=_abcc .FontSize *_eaec .Wx ;_dgegg :=_ebgc ;if !_fedg {_dgegg =_ebgc +_abcc .CharSpacing *1000.0;};if _gbba +_ebgc > _caacc ._fbbf *1000.0{_gbca :=-1;if !_fedg {for _bccge :=len (_gdaf )-1;_bccge >=0;_bccge --{if _gdaf [_bccge ]==' '{_gbca =_bccge ;break ;};};};_afed :=string (_gdaf );if _gbca >=0{_afed =string (_gdaf [0:_gbca +1]);_gdaf =_gdaf [_gbca +1:];_gdaf =append (_gdaf ,_fddg );_def =_def [_gbca +1:];_def =append (_def ,_dgegg );_gbba =0;for _ ,_aabe :=range _def {_gbba +=_aabe ;};}else {if _fedg {_gbba =0;_gdaf =[]rune {};_def =[]float64 {};}else {_gbba =_dgegg ;_gdaf =[]rune {_fddg };_def =[]float64 {_dgegg };};};_aecca =append (_aecca ,&TextChunk {Text :_be .TrimRightFunc (string (_afed ),_fa .IsSpace ),Style :_abcc ,_cacaf :_fgba (_ebbad )});_caacc ._baedf =append (_caacc ._baedf ,_aecca );_aecca =[]*TextChunk {};}else {_gbba +=_dgegg ;_gdaf =append (_gdaf ,_fddg );_def =append (_def ,_dgegg );};};if len (_gdaf )> 0{_aecca =append (_aecca ,&TextChunk {Text :string (_gdaf ),Style :_abcc ,_cacaf :_fgba (_ebbad )});};};if len (_aecca )> 0{_caacc ._baedf =append (_caacc ._baedf ,_aecca );};return nil ;};

// SetFillColor sets the fill color.
func (_ddebc *Rectangle )SetFillColor (col Color ){_ddebc ._dgec =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// LevelOffset returns the amount of space an indentation level occupies.
func (_eaef *TOCLine )LevelOffset ()float64 {return _eaef ._cddd };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_gef *Creator )SetForms (form *_c .PdfAcroForm )error {_gef ._efdg =form ;return nil };

// Append adds a new text chunk to the paragraph.
func (_bfdbg *StyledParagraph )Append (text string )*TextChunk {_beebc :=NewTextChunk (text ,_bfdbg ._fbfe );return _bfdbg .appendChunk (_beebc );};

// GeneratePageBlocks generate the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
// Implements the Drawable interface.
func (_eedda *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _affa []*Block ;_eadd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gced :=ctx ;if _eedda ._gceb .isAbsolute (){ctx .X =_eedda ._bafda ;ctx .Y =_eedda ._fbcgb ;}else {ctx .X +=_eedda ._abb ._eccf ;ctx .Y +=_eedda ._abb ._efbe ;ctx .Width -=_eedda ._abb ._eccf +_eedda ._abb ._gdce ;ctx .Height -=_eedda ._abb ._abcd +_eedda ._abb ._efbe ;};_dcbb :=ctx .Width ;_gfcc :=ctx .X ;_abbf :=ctx .Y ;ctx .Height =ctx .PageHeight -ctx .Y -ctx .Margins ._abcd ;_ebgg :=ctx .Height ;_cecc :=0;_eccg :=-1;_dead :=-1;for _gdeb ,_fgcff :=range _eedda ._eafba {_bdfd :=float64 (0.0);for _gegcg :=0;_gegcg < _fgcff ._aeccf ;_gegcg ++{_bdfd +=_eedda ._abac [_fgcff ._effad +_gegcg -1];};_cgdbbe :=float64 (0.0);for _afgef :=0;_afgef < _fgcff ._effad -1;_afgef ++{_cgdbbe +=_eedda ._abac [_afgef ]*_dcbb ;};_eddg :=float64 (0.0);for _cbcc :=_cecc ;_cbcc < _fgcff ._degfg -1;_cbcc ++{_eddg +=_eedda ._ccaae [_cbcc ];};_dbec :=_bdfd *_dcbb ;_faac :=float64 (0.0);for _fbee :=0;_fbee < _fgcff ._cgfb ;_fbee ++{_faac +=_eedda ._ccaae [_fgcff ._degfg +_fbee -1];};if _eedda ._gagg {if _fgcff ._degfg >=_eedda ._cbeg &&_fgcff ._degfg <=_eedda ._ggbg {if _eccg < 0{_eccg =_gdeb ;};_dead =_gdeb ;};};switch _ebdbc :=_fgcff ._dbaec .(type ){case *Paragraph :_dcea :=_ebdbc ;if _dcea ._aabde {_dcea .SetWidth (_dbec -_fgcff ._ggbf );};_agcda :=_dcea .Height ()+_dcea ._bcgb ._abcd +_dcea ._bcgb ._abcd ;_agcda +=0.5*_dcea ._dgaa *_dcea ._gaga ;if _agcda > _faac {_dfee :=_agcda -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_dfee ;};case *StyledParagraph :_ffgf :=_ebdbc ;if _ffgf ._afgdg {_ffgf .SetWidth (_dbec -_fgcff ._ggbf );};_faffff :=_ffgf .Height ()+_ffgf ._fcgc ._efbe +_ffgf ._fcgc ._abcd ;_faffff +=0.5*_ffgf .getTextHeight ();if _faffff > _faac {_ceebf :=_faffff -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_ceebf ;};case *Image :_gcae :=_ebdbc ;_bgbg :=_gcae .Height ()+_gcae ._cceed ._efbe +_gcae ._cceed ._abcd ;if _bgbg > _faac {_cfef :=_bgbg -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_cfef ;};case *Table :_aede :=_ebdbc ;_gfec :=_aede .Height ()+_aede ._abb ._efbe +_aede ._abb ._abcd ;if _gfec > _faac {_agebf :=_gfec -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_agebf ;};case *List :_abad :=_ebdbc ;_cbbf :=_abad .tableHeight (_dbec -_fgcff ._ggbf )+_abad ._gfeg ._efbe +_abad ._gfeg ._abcd ;if _cbbf > _faac {_dcbad :=_cbbf -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_dcbad ;};case *Division :_geef :=_ebdbc ;_bdefe :=ctx ;_bdefe .X =_cgdbbe ;_bdefe .Y =_eddg ;_bdefe .Width =_dbec ;_egef ,_ ,_gcgf :=_geef .GeneratePageBlocks (_bdefe );if _gcgf !=nil {return nil ,ctx ,_gcgf ;};if len (_egef )> 1{_cdec :=_bdefe .Height -_faac ;if _cdec > _faac {_bafad :=_cdec -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_bafad ;};};_ggdd :=_geef .Height ()+_geef ._gcceg ._efbe +_geef ._gcceg ._abcd ;if _ggdd > _faac {_ebda :=_ggdd -_faac ;_eedda ._ccaae [_fgcff ._degfg +_fgcff ._cgfb -2]+=_ebda ;};};};var _ecgbb bool ;var _gbeg ,_agag int ;for _dbbdc :=0;_dbbdc < len (_eedda ._eafba );_dbbdc ++{_edee :=_eedda ._eafba [_dbbdc ];_edab :=float64 (0.0);for _acfce :=0;_acfce < _edee ._aeccf ;_acfce ++{_edab +=_eedda ._abac [_edee ._effad +_acfce -1];};_agbde :=float64 (0.0);for _fggc :=0;_fggc < _edee ._effad -1;_fggc ++{_agbde +=_eedda ._abac [_fggc ]*_dcbb ;};_cdce :=float64 (0.0);for _fbda :=_cecc ;_fbda < _edee ._degfg -1;_fbda ++{_cdce +=_eedda ._ccaae [_fbda ];};_gbbbd :=_edab *_dcbb ;_bcgee :=float64 (0.0);for _afee :=0;_afee < _edee ._cgfb ;_afee ++{_bcgee +=_eedda ._ccaae [_edee ._degfg +_afee -1];};ctx .Height =_ebgg -_cdce ;if _bcgee > ctx .Height {_affa =append (_affa ,_eadd );_eadd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gfcc =ctx .Margins ._eccf ;_abbf =ctx .Margins ._efbe ;ctx .Height =ctx .PageHeight -ctx .Margins ._efbe -ctx .Margins ._abcd ;ctx .Page ++;_ebgg =ctx .Height ;_cecc =_edee ._degfg -1;_cdce =0;if _eedda ._gagg &&_eccg >=0{_gbeg =_dbbdc ;_dbbdc =_eccg -1;_agag =_cecc ;_cecc =_eedda ._cbeg -1;_ecgbb =true ;continue ;};};ctx .Width =_gbbbd ;ctx .X =_gfcc +_agbde ;ctx .Y =_abbf +_cdce ;_ddeba :=_deg (ctx .X ,ctx .Y ,_gbbbd ,_bcgee );if _edee ._eefe !=nil {_cbfe :=_edee ._eefe .R ();_daca :=_edee ._eefe .G ();_geaca :=_edee ._eefe .B ();_ddeba .SetFillColor (ColorRGBFromArithmetic (_cbfe ,_daca ,_geaca ));};_ddeba .LineStyle =_edee ._fbbb ;_ddeba ._bda =_edee ._bagb ;_ddeba ._cag =_edee ._gaac ;_ddeba ._fdcf =_edee ._fega ;_ddeba ._gbad =_edee ._efbea ;if _edee ._gfdea !=nil {_ddeba .SetColorLeft (ColorRGBFromArithmetic (_edee ._gfdea .R (),_edee ._gfdea .G (),_edee ._gfdea .B ()));};if _edee ._cfbb !=nil {_ddeba .SetColorBottom (ColorRGBFromArithmetic (_edee ._cfbb .R (),_edee ._cfbb .G (),_edee ._cfbb .B ()));};if _edee ._deeec !=nil {_ddeba .SetColorRight (ColorRGBFromArithmetic (_edee ._deeec .R (),_edee ._deeec .G (),_edee ._deeec .B ()));};if _edee ._gbbcc !=nil {_ddeba .SetColorTop (ColorRGBFromArithmetic (_edee ._gbbcc .R (),_edee ._gbbcc .G (),_edee ._gbbcc .B ()));};_ddeba .SetWidthBottom (_edee ._bedg );_ddeba .SetWidthLeft (_edee ._eedfc );_ddeba .SetWidthRight (_edee ._eadce );_ddeba .SetWidthTop (_edee ._ffce );_ddbaa :=_eadd .Draw (_ddeba );if _ddbaa !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ddbaa );};if _edee ._dbaec !=nil {_bdbcf :=_edee ._dbaec .Width ();_eaag :=_edee ._dbaec .Height ();_ddaag :=0.0;switch _gbgf :=_edee ._dbaec .(type ){case *Paragraph :if _gbgf ._aabde {_bdbcf =_gbgf .getMaxLineWidth ()/1000.0;};case *StyledParagraph :if _gbgf ._afgdg {_bdbcf =_gbgf .getMaxLineWidth ()/1000.0;};_efef ,_gfcg :=_gbgf .getLineHeight (0);if len (_gbgf ._baedf )==1{_eaag =_efef ;}else {_eaag =_eaag -_gfcg +_efef ;};_ddaag =_efef -_gfcg ;switch _edee ._fdcfe {case CellVerticalAlignmentTop :_ddaag +=_efef *0.5;case CellVerticalAlignmentBottom :_ddaag -=_efef *0.5;};case *Table :_bdbcf =_gbbbd ;case *List :_bdbcf =_gbbbd ;};switch _edee ._eebdc {case CellHorizontalAlignmentLeft :ctx .X +=_edee ._ggbf ;ctx .Width -=_edee ._ggbf ;case CellHorizontalAlignmentCenter :_bgccg :=_gbbbd -_bdbcf ;if _bgccg > 0{ctx .X +=_bgccg /2;ctx .Width -=_bgccg /2;};case CellHorizontalAlignmentRight :if _gbbbd > _bdbcf {ctx .X =ctx .X +_gbbbd -_bdbcf -_edee ._ggbf ;ctx .Width -=_edee ._ggbf ;};};ctx .Y +=_ddaag ;switch _edee ._fdcfe {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :_abdb :=_bcgee -_eaag ;if _abdb > 0{ctx .Y +=_abdb /2;ctx .Height -=_abdb /2;};case CellVerticalAlignmentBottom :if _bcgee > _eaag {ctx .Y =ctx .Y +_bcgee -_eaag ;ctx .Height =_bcgee ;};};_fgbeg :=_eadd .DrawWithContext (_edee ._dbaec ,ctx );if _fgbeg !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgbeg );};ctx .Y -=_ddaag ;};ctx .Y +=_bcgee ;ctx .Height -=_bcgee ;if _ecgbb &&_dbbdc +1> _dead {_abbf +=_cdce +_bcgee ;_ebgg -=_bcgee +_cdce ;_cecc =_agag ;_dbbdc =_gbeg -1;_ecgbb =false ;};};_affa =append (_affa ,_eadd );if _eedda ._gceb .isAbsolute (){return _affa ,_gced ,nil ;};ctx .X =_gced .X ;ctx .Width =_gced .Width ;ctx .Y +=_eedda ._abb ._abcd ;ctx .Height -=_eedda ._abb ._abcd ;return _affa ,ctx ,nil ;};

// SetOpacity sets opacity for Image.
func (_acgd *Image )SetOpacity (opacity float64 ){_acgd ._adcf =opacity };

// SetMargins sets the Paragraph's margins.
func (_dgfd *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_dgfd ._fcgc ._eccf =left ;_dgfd ._fcgc ._gdce =right ;_dgfd ._fcgc ._efbe =top ;_dgfd ._fcgc ._abcd =bottom ;};func (_fdgd *Invoice )generateInformationBlocks (_cabgfa DrawContext )([]*Block ,DrawContext ,error ){_fddfc :=_abdg (_fdgd ._ggaa );_fddfc .SetMargins (0,0,0,20);_ebac :=_fdgd .drawAddress (_fdgd ._cfac );_ebac =append (_ebac ,_fddfc );_ebac =append (_ebac ,_fdgd .drawAddress (_fdgd ._gdb )...);_gcadf :=_bdag ();for _ ,_adee :=range _ebac {_gcadf .Add (_adee );};_dcad :=_fdgd .drawInformation ();_acge :=_eaed (2);_acge .SetMargins (0,0,25,0);_adfdb :=_acge .NewCell ();_adfdb .SetIndent (0);_adfdb .SetContent (_gcadf );_adfdb =_acge .NewCell ();_adfdb .SetContent (_dcad );return _acge .GeneratePageBlocks (_cabgfa );};

// TextAlignment options for paragraph.
type TextAlignment int ;func _edgg (_fbff string )*_c .PdfAnnotation {_bggd :=_c .NewPdfAnnotationLink ();_efgaa :=_c .NewBorderStyle ();_efgaa .SetBorderWidth (0);_bggd .BS =_efgaa .ToPdfObject ();_aceb :=_c .NewPdfActionURI ();_aceb .URI =_ec .MakeString (_fbff );_bggd .SetAction (_aceb .PdfAction );return _bggd .PdfAnnotation ;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// The color of the text.
Color Color ;

// The font the text will use.
Font *_c .PdfFont ;

// The size of the font.
FontSize float64 ;

// The character spacing.
CharSpacing float64 ;

// The rendering mode.
RenderingMode TextRenderingMode ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_eeag *Division )Add (d VectorDrawable )error {_bbeec :=false ;switch d .(type ){case *Paragraph :_bbeec =true ;case *StyledParagraph :_bbeec =true ;case *Image :_bbeec =true ;};if !_bbeec {return _f .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_eeag ._gab =append (_eeag ._gab ,d );return nil ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_fgf *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acfc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cece ,_ccdc :=_acfc .setOpacity (_fgf ._ddcfb ,_fgf ._bfeb );if _ccdc !=nil {return nil ,ctx ,_ccdc ;};_dgge :=_fgf ._gbdgd ;_dgge .FillEnabled =_dgge .FillColor !=nil ;_fcdgb :=_dgge .Curves ;_bcgac :=ctx .PageHeight ;for _aade :=range _fcdgb {_eaac :=&_fcdgb [_aade ];_eaac .P0 .Y =_bcgac -_eaac .P0 .Y ;_eaac .P1 .Y =_bcgac -_eaac .P1 .Y ;_eaac .P2 .Y =_bcgac -_eaac .P2 .Y ;_eaac .P3 .Y =_bcgac -_eaac .P3 .Y ;};_cfbde ,_ ,_ccdc :=_dgge .Draw (_cece );if _ccdc !=nil {return nil ,ctx ,_ccdc ;};if _ccdc =_acfc .addContentsByString (string (_cfbde ));_ccdc !=nil {return nil ,ctx ,_ccdc ;};return []*Block {_acfc },ctx ,nil ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bagf *Creator )NewParagraph (text string )*Paragraph {return _befa (text ,_bagf .NewTextStyle ())};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fcbf *Creator )Finalize ()error {if _fcbf ._cgec {return nil ;};_deee :=len (_fcbf ._fcc );_gebf :=0;if _fcbf ._ecea !=nil {_gebf ++;};if _fcbf .AddTOC {_fcbf .initContext ();_fcbf ._eged .Page =_gebf +1;if _fcbf ._fbbd !=nil {if _gcec :=_fcbf ._fbbd (_fcbf ._bcdg );_gcec !=nil {return _gcec ;};};_efbg ,_ ,_fgaf :=_fcbf ._bcdg .GeneratePageBlocks (_fcbf ._eged );if _fgaf !=nil {_ga .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_fgaf );return _fgaf ;};_gebf +=len (_efbg );_feeff :=_fcbf ._bcdg .Lines ();for _ ,_dffe :=range _feeff {_ggbdc ,_edga :=_eg .Atoi (_dffe .Page .Text );if _edga !=nil {continue ;};_dffe .Page .Text =_eg .Itoa (_ggbdc +_gebf );};};_dfe :=false ;if _fcbf ._ecea !=nil {_deee ++;_egaa :=_fcbf .newPage ();_fcbf ._fcc =append ([]*_c .PdfPage {_egaa },_fcbf ._fcc ...);_fcbf .setActivePage (_egaa );_ceaf :=FrontpageFunctionArgs {PageNum :1,TotalPages :_deee };_fcbf ._ecea (_ceaf );_dfe =true ;};if _fcbf .AddTOC {_fcbf .initContext ();if _fcbf ._fbbd !=nil {if _bdcb :=_fcbf ._fbbd (_fcbf ._bcdg );_bdcb !=nil {_ga .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bdcb );return _bdcb ;};};_fbab :=_fcbf ._bcdg .Lines ();for _ ,_ebg :=range _fbab {_ebg ._aced +=int64 (_gebf );};var _bebc []*_c .PdfPage ;_fbeb ,_ ,_ :=_fcbf ._bcdg .GeneratePageBlocks (_fcbf ._eged );for _ ,_ggagg :=range _fbeb {_ggagg .SetPos (0,0);_deee ++;_fgcf :=_fcbf .newPage ();_bebc =append (_bebc ,_fgcf );_fcbf .setActivePage (_fgcf );_fcbf .Draw (_ggagg );};if _dfe {_agef :=_fcbf ._fcc [0];_aee :=_fcbf ._fcc [1:];_fcbf ._fcc =append ([]*_c .PdfPage {_agef },_bebc ...);_fcbf ._fcc =append (_fcbf ._fcc ,_aee ...);}else {_fcbf ._fcc =append (_bebc ,_fcbf ._fcc ...);};};if _fcbf ._eab !=nil &&_fcbf .AddOutlines {var _cdaaa func (_ceef *_c .OutlineItem );_cdaaa =func (_eadc *_c .OutlineItem ){_eadc .Dest .Page +=int64 (_gebf );if _gddfb :=int (_eadc .Dest .Page );_gddfb >=0&&_gddfb < len (_fcbf ._fcc ){_eadc .Dest .PageObj =_fcbf ._fcc [_gddfb ].GetPageAsIndirectObject ();}else {_ga .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gddfb );};_eadc .Dest .Y =_fcbf ._beeb -_eadc .Dest .Y ;_edge :=_eadc .Items ();for _ ,_dac :=range _edge {_cdaaa (_dac );};};_fabf :=_fcbf ._eab .Items ();for _ ,_beff :=range _fabf {_cdaaa (_beff );};if _fcbf .AddTOC {var _cageg int ;if _dfe {_cageg =1;};_gefe :=_c .NewOutlineDest (int64 (_cageg ),0,_fcbf ._beeb );if _cageg >=0&&_cageg < len (_fcbf ._fcc ){_gefe .PageObj =_fcbf ._fcc [_cageg ].GetPageAsIndirectObject ();}else {_ga .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cageg );};_fcbf ._eab .Insert (0,_c .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gefe ));};};for _gfac ,_feea :=range _fcbf ._fcc {_fcbf .setActivePage (_feea );if _fcbf ._cefd !=nil {_fbgd :=NewBlock (_fcbf ._ecbg ,_fcbf ._dcb ._efbe );_ecbd :=HeaderFunctionArgs {PageNum :_gfac +1,TotalPages :_deee };_fcbf ._cefd (_fbgd ,_ecbd );_fbgd .SetPos (0,0);if _fagf :=_fcbf .Draw (_fbgd );_fagf !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_fagf );return _fagf ;};};if _fcbf ._gdc !=nil {_bbea :=NewBlock (_fcbf ._ecbg ,_fcbf ._dcb ._abcd );_agde :=FooterFunctionArgs {PageNum :_gfac +1,TotalPages :_deee };_fcbf ._gdc (_bbea ,_agde );_bbea .SetPos (0,_fcbf ._beeb -_bbea ._gg );if _dfg :=_fcbf .Draw (_bbea );_dfg !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dfg );return _dfg ;};};_gdcb ,_efga :=_fcbf ._bff [_feea ];if !_efga {continue ;};if _ffbd ,_gea :=_fcbf ._ggbd [_feea ];_gea {_gdcb .transform (_ffbd );};if _gcfa :=_gdcb .drawToPage (_feea );_gcfa !=nil {_ga .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gfac +1,_gcfa );return _gcfa ;};};_fcbf ._cgec =true ;return nil ;};

// SetTotal sets the total of the invoice.
func (_bdfac *Invoice )SetTotal (value string ){_bdfac ._aegf [1].Value =value };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ggafa *TOC )SetLineStyle (style TextStyle ){_ggafa .SetLineNumberStyle (style );_ggafa .SetLineTitleStyle (style );_ggafa .SetLineSeparatorStyle (style );_ggafa .SetLinePageStyle (style );};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_adea *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _f .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_adea ._gagg =true ;_adea ._cbeg =startRow ;_adea ._ggbg =endRow ;return nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_cadf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_cadf ._gdb =address };

// SetBorderColor sets border color.
func (_gedg *Rectangle )SetBorderColor (col Color ){_gedg ._cfbgg =_c .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetColorLeft sets border color for left.
func (_ddcf *border )SetColorLeft (col Color ){_ddcf ._fdc =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gcgb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_efaae :=[2]*InvoiceCell {_gcgb .newCell (description ,_gcgb ._cgba ),_gcgb .newCell (value ,_gcgb ._cgba )};_gcgb ._ecff =append (_gcgb ._ecff ,_efaae );return _efaae [0],_efaae [1];};

// NewCellProps returns the default properties of an invoice cell.
func (_eacg *Invoice )NewCellProps ()InvoiceCellProps {_deea :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_eacg ._ggaa ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_deea ,BorderColor :_deea ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_bad *Invoice )AddressHeadingStyle ()TextStyle {return _bad ._effa };

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_ddd *Chapter )GetHeading ()*Paragraph {return _ddd ._dcf };

// SetWidthBottom sets border width for bottom.
func (_ddada *border )SetWidthBottom (bw float64 ){_ddada ._fgbc =bw };

// NewImage create a new image from a unidoc image (model.Image).
func (_efad *Creator )NewImage (img *_c .Image )(*Image ,error ){return _dece (img )};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_abcbg *TOCLine )SetStyle (style TextStyle ){_abcbg .Number .Style =style ;_abcbg .Title .Style =style ;_abcbg .Separator .Style =style ;_abcbg .Page .Style =style ;};func _adce ()*PageBreak {return &PageBreak {}};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dcfa *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eadg :=ctx ;_fabbf ,ctx ,_cbbc :=_dcfa ._afdf .GeneratePageBlocks (ctx );if _cbbc !=nil {return _fabbf ,ctx ,_cbbc ;};if _dcfa ._dgbba .isRelative (){ctx .X =_eadg .X ;};if _dcfa ._dgbba .isAbsolute (){return _fabbf ,_eadg ,nil ;};return _fabbf ,ctx ,nil ;};

// NewList creates a new list.
func (_acaf *Creator )NewList ()*List {return _bccbc (_acaf .NewTextStyle ())};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_eceag *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_eceag ._eebdc =halign ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_egc *Invoice )SetAddressHeadingStyle (style TextStyle ){_egc ._ecbf =style };func (_gce *Block )mergeBlocks (_dgd *Block )error {_de :=_efd (_gce ._ca ,_gce ._ab ,_dgd ._ca ,_dgd ._ab );if _de !=nil {return _de ;};for _ ,_agda :=range _dgd ._agd {_gce .AddAnnotation (_agda );};return nil ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_bafa *Creator )DrawHeader (drawHeaderFunc func (_bbdf *Block ,_afba HeaderFunctionArgs )){_bafa ._cefd =drawHeaderFunc ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_eggb *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _aefc (x1 ,y1 ,x2 ,y2 )};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_bebd *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cffff :=ctx ;var _ccea []*Block ;_cbabd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bebd ._cgdb .isRelative (){ctx .X +=_bebd ._fcgc ._eccf ;ctx .Y +=_bebd ._fcgc ._efbe ;ctx .Width -=_bebd ._fcgc ._eccf +_bebd ._fcgc ._gdce ;ctx .Height -=_bebd ._fcgc ._efbe +_bebd ._fcgc ._abcd ;_bebd .SetWidth (ctx .Width );}else {if int (_bebd ._fbbf )<=0{_bebd .SetWidth (_bebd .getTextWidth ());};ctx .X =_bebd ._dcaa ;ctx .Y =_bebd ._dfbd ;};if _bebd ._abae !=nil {_bebd ._abae (_bebd ,ctx );};if _cgce :=_bebd .wrapText ();_cgce !=nil {return nil ,ctx ,_cgce ;};_bdeg :=_bebd ._baedf ;for {_eefd ,_fded ,_gegd :=_cdge (_cbabd ,_bebd ,_bdeg ,ctx );if _gegd !=nil {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gegd );return nil ,ctx ,_gegd ;};ctx =_eefd ;_ccea =append (_ccea ,_cbabd );if _bdeg =_fded ;len (_fded )==0{break ;};_cbabd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_eefd =ctx ;_eefd .Y =ctx .Margins ._efbe ;_eefd .X =ctx .Margins ._eccf +_bebd ._fcgc ._eccf ;_eefd .Height =ctx .PageHeight -ctx .Margins ._efbe -ctx .Margins ._abcd -_bebd ._fcgc ._abcd ;_eefd .Width =ctx .PageWidth -ctx .Margins ._eccf -ctx .Margins ._gdce -_bebd ._fcgc ._eccf -_bebd ._fcgc ._gdce ;ctx =_eefd ;};if _bebd ._cgdb .isRelative (){ctx .X -=_bebd ._fcgc ._eccf ;ctx .Width =_cffff .Width ;return _ccea ,ctx ,nil ;};return _ccea ,_cffff ,nil ;};

// SetAngle sets the rotation angle in degrees.
func (_ff *Block )SetAngle (angleDeg float64 ){_ff ._aff =angleDeg };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_bdef *Invoice )AddressStyle ()TextStyle {return _bdef ._geag };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_afa *Creator )NewTextStyle ()TextStyle {return _gcaee (_afa ._fbea )};

// NewTOCLine creates a new table of contents line with the default style.
func (_egag *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _bagg (number ,title ,page ,level ,_egag .NewTextStyle ());};func (_ad *Block )addContentsByString (_gc string )error {_fbd :=_ba .NewContentStreamParser (_gc );_ae ,_cba :=_fbd .Parse ();if _cba !=nil {return _cba ;};_ad ._ca .WrapIfNeeded ();_ae .WrapIfNeeded ();*_ad ._ca =append (*_ad ._ca ,*_ae ...);return nil ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_dcabf *Invoice )Sections ()[][2]string {return _dcabf ._aeegf };

// Inline returns whether the inline mode of the division is active.
func (_eebe *Division )Inline ()bool {return _eebe ._edae };

// NewTOC creates a new table of contents.
func (_gdgd *Creator )NewTOC (title string )*TOC {_ggbdd :=_gdgd .NewTextStyle ();_ggbdd .Font =_gdgd ._adbb ;return _ccbb (title ,_gdgd .NewTextStyle (),_ggbdd );};func _caddf (_eagd *_c .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_eagd ,FontSize :10};};

// New creates a new instance of the PDF Creator.
func New ()*Creator {_dgc :=&Creator {};_dgc ._fcc =[]*_c .PdfPage {};_dgc ._bff =map[*_c .PdfPage ]*Block {};_dgc .SetPageSize (PageSizeLetter );_aaaf :=0.1*_dgc ._ecbg ;_dgc ._dcb ._eccf =_aaaf ;_dgc ._dcb ._gdce =_aaaf ;_dgc ._dcb ._efbe =_aaaf ;_dgc ._dcb ._abcd =_aaaf ;var _dfb error ;_dgc ._fbea ,_dfb =_c .NewStandard14Font (_c .HelveticaName );if _dfb !=nil {_dgc ._fbea =_c .DefaultFont ();};_dgc ._adbb ,_dfb =_c .NewStandard14Font (_c .HelveticaBoldName );if _dfb !=nil {_dgc ._fbea =_c .DefaultFont ();};_dgc ._bcdg =_dgc .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_dgc .AddOutlines =true ;_dgc ._eab =_c .NewOutline ();return _dgc ;};func _cadfa (_aage *_c .PdfRectangle ,_gegf _ee .Matrix )*_c .PdfRectangle {var _begc _c .PdfRectangle ;_begc .Llx ,_begc .Lly =_gegf .Transform (_aage .Llx ,_aage .Lly );_begc .Urx ,_begc .Ury =_gegf .Transform (_aage .Urx ,_aage .Ury );_begc .Normalize ();return &_begc ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_gddb *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fffg :=_ef .Rectangle {Opacity :1.0,X :_gddb ._ggea ,Y :ctx .PageHeight -_gddb ._agff -_gddb ._bcee ,Height :_gddb ._bcee ,Width :_gddb ._debg };if _gddb ._dgec !=nil {_fffg .FillEnabled =true ;_fffg .FillColor =_gddb ._dgec ;};if _gddb ._cfbgg !=nil &&_gddb ._dcgc > 0{_fffg .BorderEnabled =true ;_fffg .BorderColor =_gddb ._cfbgg ;_fffg .BorderWidth =_gddb ._dcgc ;};_daae ,_bafc :=_dbbd .setOpacity (_gddb ._cbgf ,_gddb ._ceaa );if _bafc !=nil {return nil ,ctx ,_bafc ;};_bcdc ,_ ,_bafc :=_fffg .Draw (_daae );if _bafc !=nil {return nil ,ctx ,_bafc ;};if _bafc =_dbbd .addContentsByString (string (_bcdc ));_bafc !=nil {return nil ,ctx ,_bafc ;};return []*Block {_dbbd },ctx ,nil ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_aefg *FilledCurve )AppendCurve (curve _ef .CubicBezierCurve )*FilledCurve {_aefg ._gccf =append (_aefg ._gccf ,curve );return _aefg ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_cacaf *_c .PdfAnnotation ;_fec bool ;};func (_efab *Invoice )generateNoteBlocks (_ddbg DrawContext )([]*Block ,DrawContext ,error ){_bgded :=_bdag ();_fbabd :=append ([][2]string {_efab ._bbfd ,_efab ._ddag },_efab ._aeegf ...);for _ ,_dgcg :=range _fbabd {if _dgcg [1]!=""{_dfdbd :=_efab .drawSection (_dgcg [0],_dgcg [1]);for _ ,_cedg :=range _dfdbd {_bgded .Add (_cedg );};_ccef :=_abdg (_efab ._ggaa );_ccef .SetMargins (0,0,10,0);_bgded .Add (_ccef );};};return _bgded .GeneratePageBlocks (_ddbg );};

// Context returns the current drawing context.
func (_gfca *Creator )Context ()DrawContext {return _gfca ._eged };

// SetAngle sets the rotation angle of the text.
func (_feecf *StyledParagraph )SetAngle (angle float64 ){_feecf ._egda =angle };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_acb :=&Block {};_acb ._ca =&_ba .ContentStreamOperations {};_acb ._ab =_c .NewPdfPageResources ();_acb ._fe =width ;_acb ._gg =height ;return _acb ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cddf *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cddf ._fdcfe =valign };

// GeneratePageBlocks implements drawable interface.
func (_gggg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_age :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffd :=_gggg ._agf ;_aebe :=ctx .PageHeight -_gggg ._aef ;if _gggg ._cfg !=nil {_cbac :=_ef .Rectangle {Opacity :1.0,X :_gggg ._agf ,Y :ctx .PageHeight -_gggg ._aef -_gggg ._gda ,Height :_gggg ._gda ,Width :_gggg ._efgce };_cbac .FillEnabled =true ;_cbac .FillColor =_gggg ._cfg ;_cbac .BorderEnabled =false ;_adba ,_ ,_dbg :=_cbac .Draw ("");if _dbg !=nil {return nil ,ctx ,_dbg ;};_dbg =_age .addContentsByString (string (_adba ));if _dbg !=nil {return nil ,ctx ,_dbg ;};};_dgea :=_gggg ._eed ;_fcad :=_gggg ._fgbc ;_gaec :=_gggg ._gba ;_efae :=_gggg ._fga ;_cffa :=_gggg ._eed ;if _gggg ._fdcf ==CellBorderStyleDouble {_cffa +=2*_dgea ;};_dgde :=_gggg ._fgbc ;if _gggg ._gbad ==CellBorderStyleDouble {_dgde +=2*_fcad ;};_bcd :=_gggg ._gba ;if _gggg ._bda ==CellBorderStyleDouble {_bcd +=2*_gaec ;};_gbaf :=_gggg ._fga ;if _gggg ._cag ==CellBorderStyleDouble {_gbaf +=2*_efae ;};if _gggg ._eed !=0{_eea :=_ffd ;_cfgc :=_aebe ;if _gggg ._fdcf ==CellBorderStyleDouble {_cfgc -=_dgea ;_eef :=_ef .BasicLine {};_eef .X1 =_eea -_cffa /2;_eef .Y1 =_cfgc +2*_dgea ;_eef .X2 =_eea +_gggg ._efgce +_cffa /2;_eef .Y2 =_cfgc +2*_dgea ;_eef .LineColor =_gggg ._gcc ;_eef .LineWidth =_gggg ._eed ;_eef .LineStyle =_gggg .LineStyle ;_bgba ,_ ,_ffc :=_eef .Draw ("");if _ffc !=nil {return nil ,ctx ,_ffc ;};_ffc =_age .addContentsByString (string (_bgba ));if _ffc !=nil {return nil ,ctx ,_ffc ;};};_dag :=_ef .BasicLine {LineWidth :_gggg ._eed ,Opacity :1.0,LineColor :_gggg ._gcc ,X1 :_eea -_cffa /2+(_bcd -_gggg ._gba ),Y1 :_cfgc ,X2 :_eea +_gggg ._efgce +_cffa /2-(_gbaf -_gggg ._fga ),Y2 :_cfgc ,LineStyle :_gggg .LineStyle };_ebb ,_ ,_fda :=_dag .Draw ("");if _fda !=nil {return nil ,ctx ,_fda ;};_fda =_age .addContentsByString (string (_ebb ));if _fda !=nil {return nil ,ctx ,_fda ;};};if _gggg ._fgbc !=0{_ffe :=_ffd ;_fbb :=_aebe -_gggg ._gda ;if _gggg ._gbad ==CellBorderStyleDouble {_fbb +=_fcad ;_bfa :=_ef .BasicLine {LineWidth :_gggg ._fgbc ,Opacity :1.0,LineColor :_gggg ._eff ,X1 :_ffe -_dgde /2,Y1 :_fbb -2*_fcad ,X2 :_ffe +_gggg ._efgce +_dgde /2,Y2 :_fbb -2*_fcad ,LineStyle :_gggg .LineStyle };_bcge ,_ ,_gcg :=_bfa .Draw ("");if _gcg !=nil {return nil ,ctx ,_gcg ;};_gcg =_age .addContentsByString (string (_bcge ));if _gcg !=nil {return nil ,ctx ,_gcg ;};};_bfc :=_ef .BasicLine {LineWidth :_gggg ._fgbc ,Opacity :1.0,LineColor :_gggg ._eff ,X1 :_ffe -_dgde /2+(_bcd -_gggg ._gba ),Y1 :_fbb ,X2 :_ffe +_gggg ._efgce +_dgde /2-(_gbaf -_gggg ._fga ),Y2 :_fbb ,LineStyle :_gggg .LineStyle };_afc ,_ ,_fag :=_bfc .Draw ("");if _fag !=nil {return nil ,ctx ,_fag ;};_fag =_age .addContentsByString (string (_afc ));if _fag !=nil {return nil ,ctx ,_fag ;};};if _gggg ._gba !=0{_dec :=_ffd ;_bbfa :=_aebe ;if _gggg ._bda ==CellBorderStyleDouble {_dec +=_gaec ;_dbcb :=_ef .BasicLine {LineWidth :_gggg ._gba ,Opacity :1.0,LineColor :_gggg ._fdc ,X1 :_dec -2*_gaec ,Y1 :_bbfa +_bcd /2,X2 :_dec -2*_gaec ,Y2 :_bbfa -_gggg ._gda -_bcd /2,LineStyle :_gggg .LineStyle };_ecdc ,_ ,_gcff :=_dbcb .Draw ("");if _gcff !=nil {return nil ,ctx ,_gcff ;};_gcff =_age .addContentsByString (string (_ecdc ));if _gcff !=nil {return nil ,ctx ,_gcff ;};};_efgcg :=_ef .BasicLine {LineWidth :_gggg ._gba ,Opacity :1.0,LineColor :_gggg ._fdc ,X1 :_dec ,Y1 :_bbfa +_bcd /2-(_cffa -_gggg ._eed ),X2 :_dec ,Y2 :_bbfa -_gggg ._gda -_bcd /2+(_dgde -_gggg ._fgbc ),LineStyle :_gggg .LineStyle };_egg ,_ ,_bggg :=_efgcg .Draw ("");if _bggg !=nil {return nil ,ctx ,_bggg ;};_bggg =_age .addContentsByString (string (_egg ));if _bggg !=nil {return nil ,ctx ,_bggg ;};};if _gggg ._fga !=0{_ceec :=_ffd +_gggg ._efgce ;_ebec :=_aebe ;if _gggg ._cag ==CellBorderStyleDouble {_ceec -=_efae ;_bge :=_ef .BasicLine {LineWidth :_gggg ._fga ,Opacity :1.0,LineColor :_gggg ._ecfb ,X1 :_ceec +2*_efae ,Y1 :_ebec +_gbaf /2,X2 :_ceec +2*_efae ,Y2 :_ebec -_gggg ._gda -_gbaf /2,LineStyle :_gggg .LineStyle };_gfe ,_ ,_fgg :=_bge .Draw ("");if _fgg !=nil {return nil ,ctx ,_fgg ;};_fgg =_age .addContentsByString (string (_gfe ));if _fgg !=nil {return nil ,ctx ,_fgg ;};};_cgcb :=_ef .BasicLine {LineWidth :_gggg ._fga ,Opacity :1.0,LineColor :_gggg ._ecfb ,X1 :_ceec ,Y1 :_ebec +_gbaf /2-(_cffa -_gggg ._eed ),X2 :_ceec ,Y2 :_ebec -_gggg ._gda -_gbaf /2+(_dgde -_gggg ._fgbc ),LineStyle :_gggg .LineStyle };_bbb ,_ ,_ebcd :=_cgcb .Draw ("");if _ebcd !=nil {return nil ,ctx ,_ebcd ;};_ebcd =_age .addContentsByString (string (_bbb ));if _ebcd !=nil {return nil ,ctx ,_ebcd ;};};return []*Block {_age },ctx ,nil ;};func (_badc *Invoice )drawInformation ()*Table {_baa :=_eaed (2);_bcgeg :=append ([][2]*InvoiceCell {_badc ._eacd ,_badc ._bccb ,_badc ._dbcc },_badc ._ecff ...);for _ ,_gdage :=range _bcgeg {_ede ,_dege :=_gdage [0],_gdage [1];if _dege .Value ==""{continue ;};_gbec :=_baa .NewCell ();_gbec .SetBackgroundColor (_ede .BackgroundColor );_badc .setCellBorder (_gbec ,_ede );_bdaf :=_abdg (_ede .TextStyle );_bdaf .Append (_ede .Value );_bdaf .SetMargins (0,0,2,1);_gbec .SetContent (_bdaf );_gbec =_baa .NewCell ();_gbec .SetBackgroundColor (_dege .BackgroundColor );_badc .setCellBorder (_gbec ,_dege );_bdaf =_abdg (_dege .TextStyle );_bdaf .Append (_dege .Value );_bdaf .SetMargins (0,0,2,1);_gbec .SetContent (_bdaf );};return _baa ;};

// SellerAddress returns the seller address used in the invoice template.
func (_becdc *Invoice )SellerAddress ()*InvoiceAddress {return _becdc ._cfac };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_fabd *Paragraph )SetWidth (width float64 ){_fabd ._adbbc =width ;_fabd .wrapText ()};

// AddLine appends a new line to the invoice line items table.
func (_aabd *Invoice )AddLine (values ...string )[]*InvoiceCell {_becb :=len (_aabd ._fdfd );var _fbbdg []*InvoiceCell ;for _adcb ,_cfde :=range values {_abde :=_aabd .newCell (_cfde ,_aabd ._ddcd );if _adcb < _becb {_abde .Alignment =_aabd ._fdfd [_adcb ].Alignment ;};_fbbdg =append (_fbbdg ,_abde );};_aabd ._gfb =append (_aabd ._gfb ,_fbbdg );return _fbbdg ;};func _fbbab (_dgff ,_dcfc ,_cfa ,_faag float64 )*Ellipse {_aebf :=&Ellipse {};_aebf ._ffab =_dgff ;_aebf ._dgg =_dcfc ;_aebf ._degg =_cfa ;_aebf ._cfee =_faag ;_aebf ._dbeb =_c .NewPdfColorDeviceRGB (0,0,0);_aebf ._dce =1.0;return _aebf ;};

// SetWidthLeft sets border width for left.
func (_bbf *border )SetWidthLeft (bw float64 ){_bbf ._gba =bw };

// SetRowHeight sets the height for a specified row.
func (_gbeea *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_gbeea ._ccaae ){return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gbeea ._ccaae [row -1]=h ;return nil ;};func (_ggce *List )tableHeight (_efec float64 )float64 {var _bfaf float64 ;for _ ,_cdee :=range _ggce ._ddg {switch _baad :=_cdee ._daaa .(type ){case *Paragraph :_efda :=_baad ;if _efda ._aabde {_efda .SetWidth (_efec );};_bfaf +=_efda .Height ()+_efda ._bcgb ._abcd +_efda ._bcgb ._abcd ;_bfaf +=0.5*_efda ._dgaa *_efda ._gaga ;case *StyledParagraph :_bcf :=_baad ;if _bcf ._afgdg {_bcf .SetWidth (_efec );};_bfaf +=_bcf .Height ()+_bcf ._fcgc ._efbe +_bcf ._fcgc ._abcd ;_bfaf +=0.5*_bcf .getTextHeight ();default:_bfaf +=_cdee ._daaa .Height ();};};return _bfaf ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_cfbg *Invoice )drawSection (_gdda ,_ebbc string )[]*StyledParagraph {var _bbdfd []*StyledParagraph ;if _gdda !=""{_cgcbc :=_abdg (_cfbg ._ccag );_cgcbc .SetMargins (0,0,0,5);_cgcbc .Append (_gdda );_bbdfd =append (_bbdfd ,_cgcbc );};if _ebbc !=""{_bbad :=_abdg (_cfbg ._afgd );_bbad .Append (_ebbc );_bbdfd =append (_bbdfd ,_bbad );};return _bbdfd ;};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_b .Max (_b .Min (r ,1.0),0.0);g =_b .Max (_b .Min (g ,1.0),0.0);b =_b .Max (_b .Min (b ,1.0),0.0);_ecc :=rgbColor {};_ecc ._ggd =r ;_ecc ._gggcd =g ;_ecc ._gcad =b ;return _ecc ;};

// SetBorderOpacity sets the border opacity.
func (_dacd *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dacd ._bfeb =opacity };

// NewFilledCurve returns a instance of filled curve.
func (_bdcc *Creator )NewFilledCurve ()*FilledCurve {return _ceee ()};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_gebd *TOC )SetLineNumberStyle (style TextStyle ){_gebd ._aagd =style };func _eabbc (_dcgg *Block ,_agcag *Paragraph ,_ccbd DrawContext )(DrawContext ,error ){_ccfe :=1;_dgbb :=_ec .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eg .Itoa (_ccfe ));for _dcgg ._ab .HasFontByName (_dgbb ){_ccfe ++;_dgbb =_ec .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eg .Itoa (_ccfe ));};_eadaa :=_dcgg ._ab .SetFontByName (_dgbb ,_agcag ._feeda .ToPdfObject ());if _eadaa !=nil {return _ccbd ,_eadaa ;};_agcag .wrapText ();_cfdc :=_ba .NewContentCreator ();_cfdc .Add_q ();_cfcag :=_ccbd .PageHeight -_ccbd .Y -_agcag ._dgaa *_agcag ._gaga ;_cfdc .Translate (_ccbd .X ,_cfcag );if _agcag ._egf !=0{_cfdc .RotateDeg (_agcag ._egf );};_cfdc .Add_BT ().Add_rg (_agcag ._ddba .R (),_agcag ._ddba .G (),_agcag ._ddba .B ()).Add_Tf (_dgbb ,_agcag ._dgaa ).Add_TL (_agcag ._dgaa *_agcag ._gaga );for _ggec ,_fgcg :=range _agcag ._ecca {if _ggec !=0{_cfdc .Add_Tstar ();};_ebbg :=[]rune (_fgcg );_daega :=0.0;_eggg :=0;for _bgcf ,_agbd :=range _ebbg {if _agbd ==' '{_eggg ++;continue ;};if _agbd =='\u000A'{continue ;};_bbgd ,_cdfa :=_agcag ._feeda .GetRuneMetrics (_agbd );if !_cdfa {_ga .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_bgcf ,_agbd ,_agbd ,_agcag ._feeda .BaseFont (),_agcag ._feeda .Subtype ());return _ccbd ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_daega +=_agcag ._dgaa *_bbgd .Wx ;};var _eeeg []_ec .PdfObject ;_gcgc ,_gbfb :=_agcag ._feeda .GetRuneMetrics (' ');if !_gbfb {return _ccbd ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_eeegg :=_gcgc .Wx ;switch _agcag ._aeed {case TextAlignmentJustify :if _eggg > 0&&_ggec < len (_agcag ._ecca )-1{_eeegg =(_agcag ._adbbc *1000.0-_daega )/float64 (_eggg )/_agcag ._dgaa ;};case TextAlignmentCenter :_fafc :=_daega +float64 (_eggg )*_eeegg *_agcag ._dgaa ;_decd :=(_agcag ._adbbc *1000.0-_fafc )/2/_agcag ._dgaa ;_eeeg =append (_eeeg ,_ec .MakeFloat (-_decd ));case TextAlignmentRight :_adae :=_daega +float64 (_eggg )*_eeegg *_agcag ._dgaa ;_bbgaa :=(_agcag ._adbbc *1000.0-_adae )/_agcag ._dgaa ;_eeeg =append (_eeeg ,_ec .MakeFloat (-_bbgaa ));};_dfaf :=_agcag ._feeda .Encoder ();var _dbeec []byte ;for _ ,_agce :=range _ebbg {if _agce =='\u000A'{continue ;};if _agce ==' '{if len (_dbeec )> 0{_eeeg =append (_eeeg ,_ec .MakeStringFromBytes (_dbeec ));_dbeec =nil ;};_eeeg =append (_eeeg ,_ec .MakeFloat (-_eeegg ));}else {if _ ,_gaeg :=_dfaf .RuneToCharcode (_agce );!_gaeg {_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_agce ,_agce );continue ;};_dbeec =append (_dbeec ,_dfaf .Encode (string (_agce ))...);};};if len (_dbeec )> 0{_eeeg =append (_eeeg ,_ec .MakeStringFromBytes (_dbeec ));};_cfdc .Add_TJ (_eeeg ...);};_cfdc .Add_ET ();_cfdc .Add_Q ();_cdcd :=_cfdc .Operations ();_cdcd .WrapIfNeeded ();_dcgg .addContents (_cdcd );if _agcag ._cbade .isRelative (){_gcda :=_agcag .Height ()+_agcag ._bcgb ._abcd ;_ccbd .Y +=_gcda ;_ccbd .Height -=_gcda ;if _ccbd .Inline {_ccbd .X +=_agcag .Width ()+_agcag ._bcgb ._gdce ;};};return _ccbd ,nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_cbde *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_cbde ._baag =append (_cbde ._baag ,line );return line ;};

// CurRow returns the currently active cell's row number.
func (_gafc *Table )CurRow ()int {_dgafg :=(_gafc ._abed -1)/_gafc ._ecgb +1;return _dgafg };func _ffaea (_bdega *_e .File )([]*_c .PdfPage ,error ){_ebdcg ,_febag :=_c .NewPdfReader (_bdega );if _febag !=nil {return nil ,_febag ;};_acad ,_febag :=_ebdcg .GetNumPages ();if _febag !=nil {return nil ,_febag ;};var _gdge []*_c .PdfPage ;for _abgg :=0;_abgg < _acad ;_abgg ++{_ddgf ,_cade :=_ebdcg .GetPage (_abgg +1);if _cade !=nil {return nil ,_cade ;};_gdge =append (_gdge ,_ddgf );};return _gdge ,nil ;};func _gbef (_gcd []byte )(*Image ,error ){_cbga :=_fc .NewReader (_gcd );_bbdfg ,_dfdc :=_c .ImageHandling .Read (_cbga );if _dfdc !=nil {_ga .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dfdc );return nil ,_dfdc ;};return _dece (_bbdfg );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_begb *Table )SetPos (x ,y float64 ){_begb ._gceb =_cdaa ;_begb ._bafda =x ;_begb ._fbcgb =y };func _eaed (_dcbc int )*Table {_adbag :=&Table {_ecgb :_dcbc ,_dacf :10.0,_abac :[]float64 {},_ccaae :[]float64 {},_eafba :[]*TableCell {}};_adbag .resetColumnWidths ();return _adbag ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_febb *TOCLine )SetLevelOffset (levelOffset float64 ){_febb ._cddd =levelOffset ;_febb ._afdf ._fcgc ._eccf =_febb ._gagce +float64 (_febb ._cgca -1)*_febb ._cddd ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dgce *Creator )NewStyledParagraph ()*StyledParagraph {return _abdg (_dgce .NewTextStyle ())};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// GeneratePageBlocks draws the curve onto page blocks.
func (_abef *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbbde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _ddef []string ;_ddef =append (_ddef ,_af .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_abef ._ggeg ));_ddef =append (_ddef ,_af .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_abef ._becf [0],_abef ._becf [1],_abef ._becf [2]));_ddef =append (_ddef ,_af .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_abef ._efdc ,ctx .PageHeight -_abef ._gcce ));_ddef =append (_ddef ,_af .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_abef ._bbag ,ctx .PageHeight -_abef ._cffc ,_abef ._fcadc ,ctx .PageHeight -_abef ._bfcf ));_gfee :=_fbbde .addContentsByString (_be .Join (_ddef ,"\u000a"));if _gfee !=nil {return nil ,ctx ,_gfee ;};return []*Block {_fbbde },ctx ,nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_bgfc *TOC )SetShowLinks (showLinks bool ){_bgfc ._gbgg =showLinks };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_efc *TOC )SetLinePageStyle (style TextStyle ){_efc ._accfc =style };type positioning int ;

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_fade *TOC )SetLineLevelOffset (levelOffset float64 ){_fade ._dced =levelOffset };

// SetBorderWidth sets the border width.
func (_deag *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_deag ._gbdgd .BorderWidth =borderWidth ;};func _cdge (_baeca *Block ,_ddce *StyledParagraph ,_debgb [][]*TextChunk ,_gddfg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_agbb :=1;_eafb :=_ec .PdfObjectName (_af .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agbb ));for _baeca ._ab .HasFontByName (_eafb ){_agbb ++;_eafb =_ec .PdfObjectName (_af .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agbb ));};_gebb :=_baeca ._ab .SetFontByName (_eafb ,_ddce ._fbfe .Font .ToPdfObject ());if _gebb !=nil {return _gddfg ,nil ,_gebb ;};_agbb ++;_gceg :=_eafb ;_cbdd :=_ddce ._fbfe .FontSize ;_gafb :=_ddce ._cgdb .isRelative ();var _adad [][]_ec .PdfObjectName ;var _gdgdc float64 ;var _cbdda [][]*TextChunk ;var _ebga float64 ;for _cdcf ,_cffab :=range _debgb {var _dgca []_ec .PdfObjectName ;var _bgfa float64 ;for _ ,_gdgg :=range _cffab {_bcb :=_gdgg .Style ;if _cdcf ==0&&_bcb .FontSize > _gdgdc {_gdgdc =_bcb .FontSize ;};if _bcb .FontSize > _bgfa {_bgfa =_bcb .FontSize ;};_eafb =_ec .PdfObjectName (_af .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agbb ));_gec :=_baeca ._ab .SetFontByName (_eafb ,_bcb .Font .ToPdfObject ());if _gec !=nil {return _gddfg ,nil ,_gec ;};_dgca =append (_dgca ,_eafb );_agbb ++;};_bgfa *=_ddce ._fdae ;if _gafb &&_ebga +_bgfa > _gddfg .Height {_cbdda =_debgb [_cdcf :];_debgb =_debgb [:_cdcf ];break ;};_ebga +=_bgfa ;_adad =append (_adad ,_dgca );};_dbbe :=_ba .NewContentCreator ();_dbbe .Add_q ();_cgbgd :=_gddfg .PageHeight -_gddfg .Y -_gdgdc *_ddce ._fdae ;_dbbe .Translate (_gddfg .X ,_cgbgd );if _ddce ._egda !=0{_dbbe .RotateDeg (_ddce ._egda );};_dbbe .Add_BT ();_acef :=_cgbgd ;for _eeda ,_fdcaf :=range _debgb {_cegb :=_gddfg .X ;if _eeda !=0{_dbbe .Add_Tstar ();};_feac :=_eeda ==len (_debgb )-1;var (_cdd float64 ;_egggf float64 ;_feba float64 ;_daff uint ;);var _adagf []float64 ;for _ ,_eggf :=range _fdcaf {_ecg :=&_eggf .Style ;if _ecg .FontSize > _egggf {_egggf =_ecg .FontSize ;};_dgag ,_ggcaa :=_ecg .Font .GetRuneMetrics (' ');if !_ggcaa {return _gddfg ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _ebdc uint ;var _dfef float64 ;_baab :=len (_eggf .Text );for _adbf ,_gdga :=range _eggf .Text {if _gdga ==' '{_ebdc ++;continue ;};if _gdga =='\u000A'{continue ;};_gcaa ,_dgdaa :=_ecg .Font .GetRuneMetrics (_gdga );if !_dgdaa {_ga .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gdga );return _gddfg ,nil ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dfef +=_ecg .FontSize *_gcaa .Wx ;if _adbf !=_baab -1{_dfef +=_ecg .CharSpacing *1000.0;};};_adagf =append (_adagf ,_dfef );_cdd +=_dfef ;_feba +=float64 (_ebdc )*_dgag .Wx *_ecg .FontSize ;_daff +=_ebdc ;};_egggf *=_ddce ._fdae ;var _aae []_ec .PdfObject ;_dfga :=_ddce ._fbbf *1000.0;if _ddce ._dfge ==TextAlignmentJustify {if _daff > 0&&!_feac {_feba =(_dfga -_cdd )/float64 (_daff )/_cbdd ;};}else if _ddce ._dfge ==TextAlignmentCenter {_ggaf :=(_dfga -_cdd -_feba )/2;_cgfa :=_ggaf /_cbdd ;_aae =append (_aae ,_ec .MakeFloat (-_cgfa ));_cegb +=_ggaf /1000.0;}else if _ddce ._dfge ==TextAlignmentRight {_dagfe :=(_dfga -_cdd -_feba );_agfe :=_dagfe /_cbdd ;_aae =append (_aae ,_ec .MakeFloat (-_agfe ));_cegb +=_dagfe /1000.0;};if len (_aae )> 0{_dbbe .Add_Tf (_gceg ,_cbdd ).Add_TL (_cbdd *_ddce ._fdae ).Add_TJ (_aae ...);};for _cacf ,_dbd :=range _fdcaf {_gfff :=&_dbd .Style ;_fedc ,_bgfb ,_acga :=_gfff .Color .ToRGB ();_aagg :=_gceg ;_deff :=_cbdd ;_dbbe .Add_Tr (int64 (_gfff .RenderingMode ));_dbbe .Add_Tc (_gfff .CharSpacing );if _ddce ._dfge !=TextAlignmentJustify ||_feac {_gaag ,_eeade :=_gfff .Font .GetRuneMetrics (' ');if !_eeade {return _gddfg ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aagg =_adad [_eeda ][_cacf ];_deff =_gfff .FontSize ;_feba =_gaag .Wx ;};_cgdc :=_gfff .Font .Encoder ();var _adaf []byte ;for _ ,_eedf :=range _dbd .Text {if _fedc =='\u000A'{continue ;};if _eedf ==' '{if len (_adaf )> 0{_dbbe .Add_rg (_fedc ,_bgfb ,_acga ).Add_Tf (_adad [_eeda ][_cacf ],_gfff .FontSize ).Add_TL (_gfff .FontSize *_ddce ._fdae ).Add_TJ ([]_ec .PdfObject {_ec .MakeStringFromBytes (_adaf )}...);_adaf =nil ;};_dbbe .Add_Tf (_aagg ,_deff ).Add_TL (_deff *_ddce ._fdae ).Add_TJ ([]_ec .PdfObject {_ec .MakeFloat (-_feba )}...);_adagf [_cacf ]+=_feba *_deff ;}else {if _ ,_dgfbd :=_cgdc .RuneToCharcode (_eedf );!_dgfbd {_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eedf ,_eedf );continue ;};_adaf =append (_adaf ,_cgdc .Encode (string (_eedf ))...);};};if len (_adaf )> 0{_dbbe .Add_rg (_fedc ,_bgfb ,_acga ).Add_Tf (_adad [_eeda ][_cacf ],_gfff .FontSize ).Add_TL (_gfff .FontSize *_ddce ._fdae ).Add_TJ ([]_ec .PdfObject {_ec .MakeStringFromBytes (_adaf )}...);};_bfec :=_adagf [_cacf ]/1000.0;if _dbd ._cacaf !=nil {var _bcgbf *_ec .PdfObjectArray ;if !_dbd ._fec {switch _aebc :=_dbd ._cacaf .GetContext ().(type ){case *_c .PdfAnnotationLink :_bcgbf =_ec .MakeArray ();_aebc .Rect =_bcgbf ;_egace ,_fgca :=_aebc .Dest .(*_ec .PdfObjectArray );if _fgca &&_egace .Len ()==5{_bbcc ,_efac :=_egace .Get (1).(*_ec .PdfObjectName );if _efac &&_bbcc .String ()=="\u0058\u0059\u005a"{_dbagc ,_dfbaa :=_ec .GetNumberAsFloat (_egace .Get (3));if _dfbaa ==nil {_egace .Set (3,_ec .MakeFloat (_gddfg .PageHeight -_dbagc ));};};};};_dbd ._fec =true ;};if _bcgbf !=nil {_cded :=_ef .NewPoint (_cegb -_gddfg .X ,_acef -_cgbgd ).Rotate (_ddce ._egda );_cded .X +=_gddfg .X ;_cded .Y +=_cgbgd ;_deeac ,_efbge ,_cbfa ,_edgea :=_bdaeg (_bfec ,_egggf ,_ddce ._egda );_cded .X +=_deeac ;_cded .Y +=_efbge ;_bcgbf .Clear ();_bcgbf .Append (_ec .MakeFloat (_cded .X ));_bcgbf .Append (_ec .MakeFloat (_cded .Y ));_bcgbf .Append (_ec .MakeFloat (_cded .X +_cbfa ));_bcgbf .Append (_ec .MakeFloat (_cded .Y +_edgea ));};_baeca .AddAnnotation (_dbd ._cacaf );};_cegb +=_bfec ;_dbbe .Add_Tr (int64 (TextRenderingModeFill ));_dbbe .Add_Tc (0);};_acef -=_egggf ;};_dbbe .Add_ET ();_dbbe .Add_Q ();_afge :=_dbbe .Operations ();_afge .WrapIfNeeded ();_baeca .addContents (_afge );if _gafb {_faaf :=_ebga +_ddce ._fcgc ._abcd ;_gddfg .Y +=_faaf ;_gddfg .Height -=_faaf ;if _gddfg .Inline {_gddfg .X +=_ddce .Width ()+_ddce ._fcgc ._gdce ;};};return _gddfg ,_cbdda ,nil ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_faa *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _eeba []*Block ;_fcff :=ctx ;if _faa ._faec .isRelative (){ctx .X +=_faa ._gcceg ._eccf ;ctx .Y +=_faa ._gcceg ._efbe ;ctx .Width -=_faa ._gcceg ._eccf +_faa ._gcceg ._gdce ;ctx .Height -=_faa ._gcceg ._efbe +_faa ._gcceg ._abcd ;};ctx .Inline =_faa ._edae ;_cfffd :=ctx ;_ggfb :=ctx ;var _cae float64 ;for _ ,_fcdf :=range _faa ._gab {if ctx .Inline {if (ctx .X -_cfffd .X )+_fcdf .Width ()<=ctx .Width {ctx .Y =_ggfb .Y ;ctx .Height =_ggfb .Height ;}else {ctx .X =_cfffd .X ;ctx .Width =_cfffd .Width ;_ggfb .Y +=_cae ;_ggfb .Height -=_cae ;_cae =0;};};_babg ,_efeg ,_adfd :=_fcdf .GeneratePageBlocks (ctx );if _adfd !=nil {_ga .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_adfd );return nil ,ctx ,_adfd ;};if len (_babg )< 1{continue ;};if len (_eeba )> 0{_eeba [len (_eeba )-1].mergeBlocks (_babg [0]);_eeba =append (_eeba ,_babg [1:]...);}else {_eeba =append (_eeba ,_babg [0:]...);};if ctx .Inline {if ctx .Page !=_efeg .Page {_cfffd .Y =ctx .Margins ._efbe ;_cfffd .Height =ctx .PageHeight -ctx .Margins ._efbe ;_ggfb .Y =_cfffd .Y ;_ggfb .Height =_cfffd .Height ;_cae =_efeg .Height -_cfffd .Height ;}else {if _cfdb :=ctx .Height -_efeg .Height ;_cfdb > _cae {_cae =_cfdb ;};};}else {_efeg .X =ctx .X ;};ctx =_efeg ;};ctx .Inline =_fcff .Inline ;if _faa ._faec .isRelative (){ctx .X =_fcff .X ;};if _faa ._faec .isAbsolute (){return _eeba ,_fcff ,nil ;};return _eeba ,ctx ,nil ;};type border struct{_agf float64 ;_aef float64 ;_efgce float64 ;_gda float64 ;_cfg *_c .PdfColorDeviceRGB ;_fdc *_c .PdfColorDeviceRGB ;_gba float64 ;_eff *_c .PdfColorDeviceRGB ;_fgbc float64 ;_ecfb *_c .PdfColorDeviceRGB ;_fga float64 ;_gcc *_c .PdfColorDeviceRGB ;_eed float64 ;LineStyle _ef .LineStyle ;_bda CellBorderStyle ;_cag CellBorderStyle ;_fdcf CellBorderStyle ;_gbad CellBorderStyle ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_bc *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bc ._cf ._eccf ,_bc ._cf ._gdce ,_bc ._cf ._efbe ,_bc ._cf ._abcd ;};func (_gacg positioning )isRelative ()bool {return _gacg ==_abfc };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_dfaga *Table )Width ()float64 {return 0};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_ggac *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffdc ,_edce :=_cbaa .setOpacity (_ggac ._afdg ,_ggac ._bggb );if _edce !=nil {return nil ,ctx ,_edce ;};_dgaf :=_ggac ._cdcg ;_dgaf .FillEnabled =_dgaf .FillColor !=nil ;_dgaf .BorderEnabled =_dgaf .BorderColor !=nil &&_dgaf .BorderWidth > 0;_ebbgg :=_dgaf .Points ;for _cfdd :=range _ebbgg {for _edba :=range _ebbgg [_cfdd ]{_fgdf :=&_ebbgg [_cfdd ][_edba ];_fgdf .Y =ctx .PageHeight -_fgdf .Y ;};};_badcb ,_ ,_edce :=_dgaf .Draw (_ffdc );if _edce !=nil {return nil ,ctx ,_edce ;};if _edce =_cbaa .addContentsByString (string (_badcb ));_edce !=nil {return nil ,ctx ,_edce ;};return []*Block {_cbaa },ctx ,nil ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cgecd *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _cgecd ._bccb [0],_cgecd ._bccb [1]};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_bced int ;_ecgb int ;_abed int ;_abac []float64 ;_ccaae []float64 ;_dacf float64 ;_eafba []*TableCell ;_gceb positioning ;_bafda ,_fbcgb float64 ;_abb margins ;_gagg bool ;_cbeg int ;_ggbg int ;};

// SetBorderColor sets the cell's border color.
func (_egefb *TableCell )SetBorderColor (col Color ){_egefb ._gfdea =_c .NewPdfColorDeviceRGB (col .ToRGB ());_egefb ._cfbb =_c .NewPdfColorDeviceRGB (col .ToRGB ());_egefb ._deeec =_c .NewPdfColorDeviceRGB (col .ToRGB ());_egefb ._gbbcc =_c .NewPdfColorDeviceRGB (col .ToRGB ());};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_bgcc string ;_feeda *_c .PdfFont ;_dgaa float64 ;_gaga float64 ;_ddba _c .PdfColorDeviceRGB ;_aeed TextAlignment ;_aabde bool ;_adbbc float64 ;_cbef int ;_faga bool ;_egf float64 ;_bcgb margins ;_cbade positioning ;_bgeg float64 ;_adabb float64 ;_fcea ,_beaf float64 ;_ecca []string ;};func _gcaee (_ddde *_c .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_ddde ,FontSize :10};};

// SetTitleStyle sets the style properties of the invoice title.
func (_dfeg *Invoice )SetTitleStyle (style TextStyle ){_dfeg ._fcdg =style };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func (_ffda *Invoice )generateLineBlocks (_eead DrawContext )([]*Block ,DrawContext ,error ){_dagf :=_eaed (len (_ffda ._fdfd ));_dagf .SetMargins (0,0,25,0);for _ ,_dgfa :=range _ffda ._fdfd {_edfa :=_abdg (_dgfa .TextStyle );_edfa .SetMargins (0,0,1,0);_edfa .Append (_dgfa .Value );_fbbge :=_dagf .NewCell ();_fbbge .SetHorizontalAlignment (_dgfa .Alignment );_fbbge .SetBackgroundColor (_dgfa .BackgroundColor );_ffda .setCellBorder (_fbbge ,_dgfa );_fbbge .SetContent (_edfa );};for _ ,_dafg :=range _ffda ._gfb {for _ ,_ace :=range _dafg {_baae :=_abdg (_ace .TextStyle );_baae .SetMargins (0,0,3,2);_baae .Append (_ace .Value );_baed :=_dagf .NewCell ();_baed .SetHorizontalAlignment (_ace .Alignment );_baed .SetBackgroundColor (_ace .BackgroundColor );_ffda .setCellBorder (_baed ,_ace );_baed .SetContent (_baae );};};return _dagf .GeneratePageBlocks (_eead );};func (_ceffc *Chapter )headingText ()string {_egac :=_ceffc ._cage ;if _bee :=_ceffc .headingNumber ();_bee !=""{_egac =_af .Sprintf ("\u0025\u0073\u0020%\u0073",_bee ,_egac );};return _egac ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_efff *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_efff ._cfae =alignment };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_eeadc *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_affbc :=&_eeadc ._edeef ;_affbc ._eccf =left ;_affbc ._gdce =right ;_affbc ._efbe =top ;_affbc ._abcd =bottom ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_gbd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gbd ._acg ._eccf ,_gbd ._acg ._gdce ,_gbd ._acg ._efbe ,_gbd ._acg ._abcd ;};

// Add adds a new Drawable to the chapter.
func (_bfda *Chapter )Add (d Drawable )error {if Drawable (_bfda )==d {_ga .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_bfda ._bcgc =append (_bfda ._bcgc ,d );default:_ga .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetWidthTop sets border width for top.
func (_gfde *border )SetWidthTop (bw float64 ){_gfde ._eed =bw };

// NewCell returns a new invoice table cell.
func (_deb *Invoice )NewCell (value string )*InvoiceCell {return _deb .newCell (value ,_deb .NewCellProps ());};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_dgb *Invoice )NoteHeadingStyle ()TextStyle {return _dgb ._ccag };

// SetWidthRight sets border width for right.
func (_gca *border )SetWidthRight (bw float64 ){_gca ._fga =bw };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_caaee *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ddbgg :=NewTextChunk (text ,_caaee ._cbbb );_ddbgg ._cacaf =_dfc (page -1,x ,y ,zoom );return _caaee .appendChunk (_ddbgg );};

// Height returns the total height of all rows.
func (_egecg *Table )Height ()float64 {_ffgc :=float64 (0.0);for _ ,_fabdb :=range _egecg ._ccaae {_ffgc +=_fabdb ;};return _ffgc ;};

// SetBackgroundColor sets the cell's background color.
func (_geec *TableCell )SetBackgroundColor (col Color ){_geec ._eefe =_c .NewPdfColorDeviceRGB (col .ToRGB ());};func (_fdf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _fdf ._ggd ,_fdf ._gggcd ,_fdf ._gcad };

// Add adds a new line with the default style to the table of contents.
func (_bfcc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_fccbg :=_bfcc .AddLine (_fdff (TextChunk {Text :number ,Style :_bfcc ._aagd },TextChunk {Text :title ,Style :_bfcc ._dfgea },TextChunk {Text :page ,Style :_bfcc ._accfc },level ,_bfcc ._dbeeg ));if _fccbg ==nil {return nil ;};_cagea :=&_bfcc ._edeef ;_fccbg .SetMargins (_cagea ._eccf ,_cagea ._gdce ,_cagea ._efbe ,_cagea ._abcd );_fccbg .SetLevelOffset (_bfcc ._dced );_fccbg .Separator .Text =_bfcc ._aadc ;_fccbg .Separator .Style =_bfcc ._egabb ;return _fccbg ;};

// SetLineHeight sets the line height (1.0 default).
func (_cafed *Paragraph )SetLineHeight (lineheight float64 ){_cafed ._gaga =lineheight };

// SetBorderColor sets the border color.
func (_cegg *PolyBezierCurve )SetBorderColor (color Color ){_cegg ._gbdgd .BorderColor =_c .NewPdfColorDeviceRGB (color .ToRGB ());};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_gbbc *Invoice )NoteStyle ()TextStyle {return _gbbc ._afgd };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_bcaf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_egd :=_abdg (_bcaf ._caae );_egd .Append (text );_cfbd ,_ebde :=_bcaf .Add (_egd );return _egd ,_cfbd ,_ebde ;};func (_afcg *Creator )setActivePage (_ded *_c .PdfPage ){_afcg ._baff =_ded };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);func (_babe *Image )rotatedSize ()(float64 ,float64 ){_cafe :=_babe ._aeeg ;_cfbe :=_babe ._add ;_gfea :=_babe ._bdg ;if _gfea ==0{return _cafe ,_cfbe ;};_baec :=_ef .Path {Points :[]_ef .Point {_ef .NewPoint (0,0).Rotate (_gfea ),_ef .NewPoint (_cafe ,0).Rotate (_gfea ),_ef .NewPoint (0,_cfbe ).Rotate (_gfea ),_ef .NewPoint (_cafe ,_cfbe ).Rotate (_gfea )}}.GetBoundingBox ();return _baec .Width ,_baec .Height ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_dgda *Image )SetPos (x ,y float64 ){_dgda ._dade =_cdaa ;_dgda ._cgg =x ;_dgda ._eeaf =y };

// GetOptimizer returns current PDF optimizer.
func (_gbbb *Creator )GetOptimizer ()_c .Optimizer {return _gbbb ._fgbb };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gfdb *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eagb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_daeg ,_ ,_ddb :=_gfdb .draw ("");_ddb =_eagb .addContentsByString (string (_daeg ));if _ddb !=nil {return nil ,ctx ,_ddb ;};return []*Block {_eagb },ctx ,nil ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fdcd *Creator )MoveTo (x ,y float64 ){_fdcd ._eged .X =x ;_fdcd ._eged .Y =y };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_baefe *StyledParagraph )SetWidth (width float64 ){_baefe ._fbbf =width ;_baefe .wrapText ()};func (_cg *Block )setOpacity (_bef float64 ,_ed float64 )(string ,error ){if (_bef < 0||_bef >=1.0)&&(_ed < 0||_ed >=1.0){return "",nil ;};_gfd :=0;_ege :=_af .Sprintf ("\u0047\u0053\u0025\u0064",_gfd );for _cg ._ab .HasExtGState (_ec .PdfObjectName (_ege )){_gfd ++;_ege =_af .Sprintf ("\u0047\u0053\u0025\u0064",_gfd );};_ggg :=_ec .MakeDict ();if _bef >=0&&_bef < 1.0{_ggg .Set ("\u0063\u0061",_ec .MakeFloat (_bef ));};if _ed >=0&&_ed < 1.0{_ggg .Set ("\u0043\u0041",_ec .MakeFloat (_ed ));};_edd :=_cg ._ab .AddExtGState (_ec .PdfObjectName (_ege ),_ggg );if _edd !=nil {return "",_edd ;};return _ege ,nil ;};func _befbf (_cceg *Block ,_feb *Image ,_fddf DrawContext )(DrawContext ,error ){_baef :=_fddf ;_ffcfe :=1;_dcec :=_ec .PdfObjectName (_af .Sprintf ("\u0049\u006d\u0067%\u0064",_ffcfe ));for _cceg ._ab .HasXObjectByName (_dcec ){_ffcfe ++;_dcec =_ec .PdfObjectName (_af .Sprintf ("\u0049\u006d\u0067%\u0064",_ffcfe ));};_fcbb :=_cceg ._ab .SetXObjectImageByName (_dcec ,_feb ._bbg );if _fcbb !=nil {return _fddf ,_fcbb ;};_cgbg :=0;_bbbf :=_ec .PdfObjectName (_af .Sprintf ("\u0047\u0053\u0025\u0064",_cgbg ));for _cceg ._ab .HasExtGState (_bbbf ){_cgbg ++;_bbbf =_ec .PdfObjectName (_af .Sprintf ("\u0047\u0053\u0025\u0064",_cgbg ));};_gaad :=_ec .MakeDict ();_gaad .Set ("\u0042\u004d",_ec .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _feb ._adcf < 1.0{_gaad .Set ("\u0043\u0041",_ec .MakeFloat (_feb ._adcf ));_gaad .Set ("\u0063\u0061",_ec .MakeFloat (_feb ._adcf ));};_fcbb =_cceg ._ab .AddExtGState (_bbbf ,_ec .MakeIndirectObject (_gaad ));if _fcbb !=nil {return _fddf ,_fcbb ;};_adgb :=_feb .Width ();_dgffd :=_feb .Height ();_ ,_cbdc :=_feb .rotatedSize ();_fefe :=_fddf .X ;_gdca :=_fddf .PageHeight -_fddf .Y -_dgffd ;if _feb ._dade .isRelative (){_gdca -=(_cbdc -_dgffd )/2;switch _feb ._cfae {case HorizontalAlignmentCenter :_fefe +=(_fddf .Width -_adgb )/2;case HorizontalAlignmentRight :_fefe =_fddf .PageWidth -_fddf .Margins ._gdce -_feb ._cceed ._gdce -_adgb ;};};_dceg :=_feb ._bdg ;_afcga :=_ba .NewContentCreator ();_afcga .Add_gs (_bbbf );_afcga .Translate (_fefe ,_gdca );if _dceg !=0{_afcga .Translate (_adgb /2,_dgffd /2);_afcga .RotateDeg (_dceg );_afcga .Translate (-_adgb /2,-_dgffd /2);};_afcga .Scale (_adgb ,_dgffd ).Add_Do (_dcec );_fafaa :=_afcga .Operations ();_fafaa .WrapIfNeeded ();_cceg .addContents (_fafaa );if _feb ._dade .isRelative (){_fddf .Y +=_cbdc ;_fddf .Height -=_cbdc ;return _fddf ,nil ;};return _baef ,nil ;};func _bbbd (_ddeg ,_ffcbb TextStyle )*Invoice {_eabc :=&Invoice {_eabe :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gdgfb :"\u002c\u0020",_ggaa :_ddeg ,_effa :_ffcbb };_eabc ._cfac =&InvoiceAddress {Separator :_eabc ._gdgfb };_eabc ._gdb =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_eabc ._gdgfb };_fdac :=ColorRGBFrom8bit (245,245,245);_fagc :=ColorRGBFrom8bit (155,155,155);_eabc ._fcdg =_ffcbb ;_eabc ._fcdg .Color =_fagc ;_eabc ._fcdg .FontSize =20;_eabc ._geag =_ddeg ;_eabc ._ecbf =_ffcbb ;_eabc ._afgd =_ddeg ;_eabc ._ccag =_ffcbb ;_eabc ._cgba =_eabc .NewCellProps ();_eabc ._cgba .BackgroundColor =_fdac ;_eabc ._cgba .TextStyle =_ffcbb ;_eabc ._dcab =_eabc .NewCellProps ();_eabc ._dcab .TextStyle =_ffcbb ;_eabc ._dcab .BackgroundColor =_fdac ;_eabc ._dcab .BorderColor =_fdac ;_eabc ._ddcd =_eabc .NewCellProps ();_eabc ._ddcd .BorderColor =_fdac ;_eabc ._ddcd .BorderSides =[]CellBorderSide {CellBorderSideBottom };_eabc ._ddcd .Alignment =CellHorizontalAlignmentRight ;_eabc ._feae =_eabc .NewCellProps ();_eabc ._feae .Alignment =CellHorizontalAlignmentRight ;_eabc ._eacd =[2]*InvoiceCell {_eabc .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_eabc ._cgba ),_eabc .newCell ("",_eabc ._cgba )};_eabc ._bccb =[2]*InvoiceCell {_eabc .newCell ("\u0044\u0061\u0074\u0065",_eabc ._cgba ),_eabc .newCell ("",_eabc ._cgba )};_eabc ._dbcc =[2]*InvoiceCell {_eabc .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_eabc ._cgba ),_eabc .newCell ("",_eabc ._cgba )};_eabc ._eagg =[2]*InvoiceCell {_eabc .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_eabc ._feae ),_eabc .newCell ("",_eabc ._feae )};_ffag :=_eabc ._feae ;_ffag .TextStyle =_ffcbb ;_ffag .BackgroundColor =_fdac ;_ffag .BorderColor =_fdac ;_eabc ._aegf =[2]*InvoiceCell {_eabc .newCell ("\u0054\u006f\u0074a\u006c",_ffag ),_eabc .newCell ("",_ffag )};_eabc ._bbfd =[2]string {"\u004e\u006f\u0074e\u0073",""};_eabc ._ddag =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_eabc ._fdfd =[]*InvoiceCell {_eabc .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_eabc .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_eabc .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_eabc .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _eabc ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_edgad *Table )MultiColCell (colspan int )*TableCell {return _edgad .newCell (colspan )};

// SetColorTop sets border color for top.
func (_bcg *border )SetColorTop (col Color ){_bcg ._gcc =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Margins returns the margins of the list: left, right, top, bottom.
func (_ggfa *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _ggfa ._gfeg ._eccf ,_ggfa ._gfeg ._gdce ,_ggfa ._gfeg ._efbe ,_ggfa ._gfeg ._abcd ;};func _fdbd (_feggd []_ef .Point )*Polyline {return &Polyline {_gbefb :&_ef .Polyline {Points :_feggd ,LineColor :_c .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_ebfg :1.0};};func _bdaeg (_efaf ,_adeea ,_gcge float64 )(_egbd ,_gfaf ,_daagg ,_afad float64 ){if _gcge ==0{return 0,0,_efaf ,_adeea ;};_bfcfd :=_ef .Path {Points :[]_ef .Point {_ef .NewPoint (0,0).Rotate (_gcge ),_ef .NewPoint (_efaf ,0).Rotate (_gcge ),_ef .NewPoint (0,_adeea ).Rotate (_gcge ),_ef .NewPoint (_efaf ,_adeea ).Rotate (_gcge )}}.GetBoundingBox ();return _bfcfd .X ,_bfcfd .Y ,_bfcfd .Width ,_bfcfd .Height ;};func _eaeb (_gfdd *_c .PdfAnnotationLink )*_c .PdfAnnotationLink {if _gfdd ==nil {return nil ;};_bcea :=_c .NewPdfAnnotationLink ();_bcea .BS =_gfdd .BS ;_bcea .A =_gfdd .A ;if _gdbf ,_ggacc :=_gfdd .GetAction ();_ggacc ==nil &&_gdbf !=nil {_bcea .SetAction (_gdbf );};if _cdcdf ,_afdd :=_gfdd .Dest .(*_ec .PdfObjectArray );_afdd {_bcea .Dest =_ec .MakeArray (_cdcdf .Elements ()...);};return _bcea ;};

// Text sets the text content of the Paragraph.
func (_gdee *Paragraph )Text ()string {return _gdee ._bgcc };

// SetText sets the text content of the Paragraph.
func (_cdeb *Paragraph )SetText (text string ){_cdeb ._bgcc =text };func _deg (_ccaa ,_ffg ,_fbe ,_dcg float64 )*border {_eddaf :=&border {};_eddaf ._agf =_ccaa ;_eddaf ._aef =_ffg ;_eddaf ._efgce =_fbe ;_eddaf ._gda =_dcg ;_eddaf ._gcc =_c .NewPdfColorDeviceRGB (0,0,0);_eddaf ._eff =_c .NewPdfColorDeviceRGB (0,0,0);_eddaf ._fdc =_c .NewPdfColorDeviceRGB (0,0,0);_eddaf ._ecfb =_c .NewPdfColorDeviceRGB (0,0,0);_eddaf ._eed =0;_eddaf ._fgbc =0;_eddaf ._gba =0;_eddaf ._fga =0;_eddaf .LineStyle =_ef .LineStyleSolid ;return _eddaf ;};

// SetFillColor sets the fill color.
func (_acafa *Ellipse )SetFillColor (col Color ){_acafa ._bfdeb =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fgge *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgge ._fcgc ._eccf ,_fgge ._fcgc ._gdce ,_fgge ._fcgc ._efbe ,_fgge ._fcgc ._abcd ;};func _bdfa (_gcea _ag .Image )(*Image ,error ){_efgf ,_efdgg :=_c .ImageHandling .NewImageFromGoImage (_gcea );if _efdgg !=nil {return nil ,_efdgg ;};return _dece (_efgf );};

// Width returns the cell's width based on the input draw context.
func (_cbegg *TableCell )Width (ctx DrawContext )float64 {_edac :=float64 (0.0);for _dcda :=0;_dcda < _cbegg ._aeccf ;_dcda ++{_edac +=_cbegg ._bbgdf ._abac [_cbegg ._effad +_dcda -1];};_ffbc :=ctx .Width *_edac ;return _ffbc ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_ge *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bf ,_ ,_ffa :=d .GeneratePageBlocks (ctx );if _ffa !=nil {return _ffa ;};if len (_bf )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cab :=range _bf {if _dgf :=_ge .mergeBlocks (_cab );_dgf !=nil {return _dgf ;};};return nil ;};func (_deac *Paragraph )getTextLineWidth (_bdbcg string )float64 {var _gcdeb float64 ;for _ ,_bffg :=range _bdbcg {if _bffg =='\u000A'{continue ;};_caac ,_fdca :=_deac ._feeda .GetRuneMetrics (_bffg );if !_fdca {_ga .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bffg ,_bffg );return -1;};_gcdeb +=_deac ._dgaa *_caac .Wx ;};return _gcdeb ;};func _acdg (_gegc ,_bbeb ,_gdde ,_bbac ,_gcffg ,_afff float64 )*Curve {_dbe :=&Curve {};_dbe ._efdc =_gegc ;_dbe ._gcce =_bbeb ;_dbe ._bbag =_gdde ;_dbe ._cffc =_bbac ;_dbe ._fcadc =_gcffg ;_dbe ._bfcf =_afff ;_dbe ._becf =_c .NewPdfColorDeviceRGB (0,0,0);_dbe ._ggeg =1.0;return _dbe ;};

// GeneratePageBlocks generates a page break block.
func (_ceab *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcfag :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_adcbd :=ctx ;_adcbd .Y =ctx .Margins ._efbe ;_adcbd .X =ctx .Margins ._eccf ;_adcbd .Height =ctx .PageHeight -ctx .Margins ._efbe -ctx .Margins ._abcd ;_adcbd .Width =ctx .PageWidth -ctx .Margins ._eccf -ctx .Margins ._gdce ;ctx =_adcbd ;return _gcfag ,ctx ,nil ;};

// NewPolyline creates a new polyline.
func (_dbbb *Creator )NewPolyline (points []_ef .Point )*Polyline {return _fdbd (points )};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_bbec *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_fcgab :=NewTextChunk (text ,_bbec ._cbbb );_fcgab ._cacaf =_edgg (url );return _bbec .appendChunk (_fcgab );};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_gccf []_ef .CubicBezierCurve ;FillEnabled bool ;_feggc *_c .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_bbcda *_c .PdfColorDeviceRGB ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_edda *Block )SetPos (x ,y float64 ){_edda ._agc =_cdaa ;_edda ._d =x ;_edda ._db =y };

// SkipOver skips over a specified number of rows and cols.
func (_efacf *Table )SkipOver (rows ,cols int ){_eadb :=rows *_efacf ._ecgb +cols -1;if _eadb < 0{_ga .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_efacf ._abed +=_eadb ;};

// SetColor sets the line color.
func (_dga *Curve )SetColor (col Color ){_dga ._becf =_c .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetMargins sets the Paragraph's margins.
func (_dfag *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dfag ._bcgb ._eccf =left ;_dfag ._bcgb ._gdce =right ;_dfag ._bcgb ._efbe =top ;_dfag ._bcgb ._abcd =bottom ;};func _cgbb (_cbad ,_fad *_c .PdfPageResources )error {_cad ,_ :=_cbad .GetColorspaces ();if _cad !=nil &&len (_cad .Colorspaces )> 0{for _bbe ,_ada :=range _cad .Colorspaces {_afe :=*_ec .MakeName (_bbe );if _fad .HasColorspaceByName (_afe ){continue ;};_baf :=_fad .SetColorspaceByName (_afe ,_ada );if _baf !=nil {return _baf ;};};};return nil ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_fedfc *Creator )EnableFontSubsetting (font *_c .PdfFont ){_fedfc ._cecd =append (_fedfc ._cecd ,font );};

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_gbed :=rgbColor {};_gbed ._ggd =float64 (r )/255.0;_gbed ._gggcd =float64 (g )/255.0;_gbed ._gcad =float64 (b )/255.0;return _gbed ;};

// SetFillColor sets the fill color.
func (_debe *PolyBezierCurve )SetFillColor (color Color ){_debe ._gbdgd .FillColor =_c .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_cfc *Creator )SetOutlineTree (outlineTree *_c .PdfOutlineTreeNode ){_cfc ._ceg =outlineTree };

// SetIndent sets the cell's left indent.
func (_agba *TableCell )SetIndent (indent float64 ){_agba ._ggbf =indent };

// SetEnableWrap sets the line wrapping enabled flag.
func (_eaccd *StyledParagraph )SetEnableWrap (enableWrap bool ){_eaccd ._afgdg =enableWrap ;_eaccd ._eaaf =false ;};

// SkipRows skips over a specified number of rows in the table.
func (_gdfd *Table )SkipRows (num int ){_fcbc :=num *_gdfd ._ecgb -1;if _fcbc < 0{_ga .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_gdfd ._abed +=_fcbc ;};

// Height returns the current page height.
func (_bdb *Creator )Height ()float64 {return _bdb ._beeb };